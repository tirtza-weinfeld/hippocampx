{
  "core.bellman-ford.classic:bellman_ford_classic": {
    "args": [
      "vertices",
      "source",
      "edges"
    ],
    "code": "def bellman_ford_classic(\n    vertices: list[str], edges: list[tuple[str, str, float]], source: str\n) -> dict[str, float]:\n\n    d = [float(\"inf\")] * (V := len(vertices))\n    d[source] = 0\n\n    for _ in range(V - 1):\n        updated = False\n        for u, v, w in edges:\n            if d[u] + w < d[v]:\n                d[v] = d[u] + w\n                updated = True\n        if not updated:\n            return d\n\n    for u, v, w in edges:\n        if d[u] + w < d[v]:\n            raise Exception(\"Negative-weight cycle\")\n\n    return d",
    "expressions": {
      "if not updated": "distances have stabilized—no negative cycles reachable",
      "range(V - 1)": "relax up to V-1 times, but return early if no update"
    },
    "file_path": "backend/algorithms/core/bellman-ford/classic.py",
    "intuition": "- Classic Bellman-Ford with early exit:\n    - Raises on a reachable negative-weight cycle;\n    - otherwise returns dist[v] = δ(s,v).",
    "kind": "function",
    "label": "def bellman_ford_classic(vertices: list[str], edges: list[tuple[str, str, float]], source: str) -> dict[str, float]",
    "name": "bellman_ford_classic",
    "returns": {
      "label": "dict[str, float]"
    }
  },
  "core.bellman-ford.classic:bellman_ford_classic.if not updated": {
    "kind": "expression",
    "name": "if not updated",
    "summary": "distances have stabilized—no negative cycles reachable"
  },
  "core.bellman-ford.classic:bellman_ford_classic.range(V - 1)": {
    "kind": "expression",
    "name": "range(V - 1)",
    "summary": "relax up to V-1 times, but return early if no update"
  },
  "core.bellman-ford.layered_dag:bellman_ford_layered_dag": {
    "args": [
      "source",
      "edges",
      "vertices"
    ],
    "code": "def bellman_ford_layered_dag(\n    vertices: list[str], edges: list[tuple[str, str, float]], source: str\n) -> dict[str, float]:\n\n    d = {v: float(\"inf\") for v in vertices}\n    d[source], V = 0, len(vertices)\n\n    for k in range(V):\n        d_k = {**d}\n        for u, v, w in edges:\n            if d[u] + w < d_k[v]:\n                d_k[v] = d[u] + w\n        d = d_k\n\n    witnesses = {v for u, v, w in edges if d[u] + w < d[v]}\n\n    if not witnesses:\n        return d\n\n    adj = defaultdict(list)\n    for u, v, _ in edges:\n        adj[u].append(v)\n\n    stack = list(witnesses)\n    reachable = set(witnesses)\n\n    while stack:\n        u = stack.pop()\n        d[u] = float(\"-inf\")\n        for v in adj[u]:\n            if v not in reachable:\n                reachable.add(v)\n                stack.append(v)\n\n    return d",
    "file_path": "backend/algorithms/core/bellman-ford/layered_dag.py",
    "intuition": "- Compute k-edge shortest-path distances and detect negative cycles via layered relaxation.\n    1. δ₀(s,v): initialize distances (0 at source, ∞ elsewhere).\n    2. For i = 1…V: perform one pass of edge-relaxation to compute δᵢ(s,v),\n       - the best cost using ≤ i edges.\n    3. Identify any vertex v where δ_V(s,v) < δ_{V−1}(s,v) as a negative-cycle witness.\n    4. Flood successors of those witnesses and mark their distances as −∞.",
    "kind": "function",
    "label": "def bellman_ford_layered_dag(vertices: list[str], edges: list[tuple[str, str, float]], source: str) -> dict[str, float]",
    "name": "bellman_ford_layered_dag",
    "returns": {
      "label": "dict[str, float]",
      "summary": "A dict mapping each vertex to its true shortest-path cost from `source`,\n      or float('-inf') if it's reachable from a negative-weight cycle."
    }
  },
  "core.bellman-ford.layered_dag:bellman_ford_layered_dag.edges": {
    "kind": "parameter",
    "label": "edges: list[tuple[str, str, float]]",
    "name": "edges",
    "summary": "Iterable of (u, v, weight) tuples."
  },
  "core.bellman-ford.layered_dag:bellman_ford_layered_dag.source": {
    "kind": "parameter",
    "label": "source: str",
    "name": "source",
    "summary": "Starting vertex."
  },
  "core.bellman-ford.layered_dag:bellman_ford_layered_dag.vertices": {
    "kind": "parameter",
    "label": "vertices: list[str]",
    "name": "vertices",
    "summary": "All hashable vertex identifiers."
  },
  "core.binary-search.bisect_left:simple_bisect_left": {
    "args": [
      "a",
      "x"
    ],
    "code": "def simple_bisect_left(a: list[int], x: int):\n\n    l, r = 0, len(a)\n    while l < r:\n        mid = (l + r) // 2\n        if x > a[mid]:\n            l = mid + 1\n        else:\n            r = mid\n    return l",
    "expressions": {
      "l = mid + 1": "If the target `x` is greater than the middle element `a[mid]`, the insertion point must be to the right of `mid`.",
      "r = mid": "If the target `x` is less than or equal to `a[mid]`, then `mid` is a potential answer, so we search the left half including `mid`."
    },
    "file_path": "backend/algorithms/core/binary-search/bisect_left.py",
    "intuition": "Return the index where to insert item x in list a, assuming a is sorted.",
    "kind": "function",
    "label": "def simple_bisect_left(a: list[int], x: int)",
    "name": "simple_bisect_left",
    "title": "Simple Bisect Left"
  },
  "core.binary-search.bisect_left:simple_bisect_left.l = mid + 1": {
    "kind": "expression",
    "name": "l = mid + 1",
    "summary": "If the target `x` is greater than the middle element `a[mid]`, the insertion point must be to the right of `mid`."
  },
  "core.binary-search.bisect_left:simple_bisect_left.r = mid": {
    "kind": "expression",
    "name": "r = mid",
    "summary": "If the target `x` is less than or equal to `a[mid]`, then `mid` is a potential answer, so we search the left half including `mid`."
  },
  "core.binary-search.bisect_right:simple_bisect_right": {
    "args": [
      "a",
      "x"
    ],
    "code": "def simple_bisect_right(a, x):\n\n    l, r = 0, len(a)\n    while l < r:\n        mid = (l + r) // 2\n        if x < a[mid]:\n            r = mid\n        else: \n            l = mid + 1 \n    return l",
    "expressions": {
      "l = mid + 1": "If the x is >= middle element, the insertion point must be to the right of `mid`.",
      "r = mid": "If the x is less than the middle element, the insertion point could be `mid` or to its left. Shrink search space to the left half."
    },
    "file_path": "backend/algorithms/core/binary-search/bisect_right.py",
    "intuition": "Return the index where to insert item x in list a, assuming a is sorted.",
    "kind": "function",
    "label": "def simple_bisect_right(a, x)",
    "name": "simple_bisect_right",
    "title": "Simple Bisect Right"
  },
  "core.binary-search.bisect_right:simple_bisect_right.l = mid + 1": {
    "kind": "expression",
    "name": "l = mid + 1",
    "summary": "If the x is >= middle element, the insertion point must be to the right of `mid`."
  },
  "core.binary-search.bisect_right:simple_bisect_right.r = mid": {
    "kind": "expression",
    "name": "r = mid",
    "summary": "If the x is less than the middle element, the insertion point could be `mid` or to its left. Shrink search space to the left half."
  },
  "core.dijkstra.algorithm:dijkstra": {
    "args": [
      "graph",
      "s"
    ],
    "code": "def dijkstra(graph: dict[str, dict[str, int]], s: str):\n\n    d = {v: float('inf') for v in graph} | {s: 0}\n    p = {v: None for v in graph}\n\n    pq = [(0, s)]\n\n    while pq:\n        d_u, u = heapq.heappop(pq)\n        if d_u > d[u]:\n            continue\n        for v ,w in graph[u]:\n            if (weight := d_u + w) < d[v]:\n                d[v], p[v] = weight, u\n                heapq.heappush(pq, (weight, v))\n\n    return d, p",
    "file_path": "backend/algorithms/core/dijkstra/algorithm.py",
    "kind": "function",
    "label": "def dijkstra(graph: dict[str, dict[str, int]], s: str)",
    "name": "dijkstra",
    "time_complexity": "O((V + E) log V)"
  },
  "core.dijkstra.algorithm:dijkstra.graph": {
    "kind": "parameter",
    "label": "graph: dict[str, dict[str, int]]",
    "name": "graph",
    "summary": "A dictionary representing the graph."
  },
  "core.dijkstra.algorithm:dijkstra.s": {
    "kind": "parameter",
    "label": "s: str",
    "name": "s",
    "summary": "The source vertex."
  },
  "core.modular-arithmetic.congruent1:congruent1": {
    "args": [
      "b",
      "a",
      "n"
    ],
    "code": "def congruent1(a: int, b: int, n: int) -> bool:\n    return (a - b) % n == 0",
    "file_path": "backend/algorithms/core/modular-arithmetic/congruent1.py",
    "kind": "function",
    "label": "def congruent1(a: int, b: int, n: int) -> bool",
    "name": "congruent1",
    "returns": {
      "label": "bool",
      "summary": "bool"
    },
    "summary": "a ≡ b (mod n)"
  },
  "core.modular-arithmetic.congruent1:congruent1.a": {
    "kind": "parameter",
    "label": "a: int",
    "name": "a",
    "summary": "the first number2"
  },
  "core.modular-arithmetic.congruent1:congruent1.b": {
    "kind": "parameter",
    "label": "b: int",
    "name": "b",
    "summary": "the second number"
  },
  "core.modular-arithmetic.congruent1:congruent1.n": {
    "kind": "parameter",
    "label": "n: int",
    "name": "n",
    "summary": "the modulus, the number by which we are dividing"
  },
  "core.modular-arithmetic.congruent2:congruent2": {
    "args": [
      "b",
      "a",
      "n"
    ],
    "code": "def congruent2(a: int, b: int, n: int) -> bool:\n    return a % n == b % n",
    "file_path": "backend/algorithms/core/modular-arithmetic/congruent2.py",
    "kind": "function",
    "label": "def congruent2(a: int, b: int, n: int) -> bool",
    "name": "congruent2",
    "returns": {
      "label": "bool",
      "summary": "bool"
    },
    "summary": "a ≡ b (mod n)"
  },
  "core.modular-arithmetic.congruent2:congruent2.a": {
    "kind": "parameter",
    "label": "a: int",
    "name": "a",
    "summary": "the first number3"
  },
  "core.modular-arithmetic.congruent2:congruent2.b": {
    "kind": "parameter",
    "label": "b: int",
    "name": "b",
    "summary": "the second number"
  },
  "core.modular-arithmetic.congruent2:congruent2.n": {
    "kind": "parameter",
    "label": "n: int",
    "name": "n",
    "summary": "the modulus, the number by which we are dividing"
  },
  "core.modular-arithmetic.mod:mod": {
    "args": [
      "a",
      "b"
    ],
    "code": "def mod(a: int, b: int) -> int:\n    return a % b",
    "file_path": "backend/algorithms/core/modular-arithmetic/mod.py",
    "kind": "function",
    "label": "def mod(a: int, b: int) -> int",
    "name": "mod",
    "returns": {
      "label": "int",
      "summary": "int"
    },
    "summary": "a mod b"
  },
  "core.modular-arithmetic.mod:mod.a": {
    "kind": "parameter",
    "label": "a: int",
    "name": "a",
    "summary": "the first number1"
  },
  "core.modular-arithmetic.mod:mod.b": {
    "kind": "parameter",
    "label": "b: int",
    "name": "b",
    "summary": "the second number"
  },
  "more.tictactoe.game:Game": {
    "code": "class Game(ABC, Generic[StateType, ActionType, PlayerType]):\n\n    @abstractmethod\n    def initial_state(self) -> StateType:\n        pass\n\n    @abstractmethod\n    def player(self, state: StateType) -> PlayerType:\n        pass\n\n    @abstractmethod\n    def actions(self, state: StateType) -> set[ActionType]:\n        pass\n\n    @abstractmethod\n    def result(self, state: StateType, action: ActionType) -> StateType:\n        pass\n\n    @abstractmethod\n    def terminal(self, state: StateType) -> bool:\n        pass\n\n    @abstractmethod\n    def utility(self, state: StateType) -> int | float:\n        pass\n\n    @abstractmethod\n    def minimax(self, state: StateType) -> ActionType | None:\n        pass",
    "file_path": "backend/algorithms/more/tictactoe/game.py",
    "kind": "class",
    "name": "Game",
    "summary": "Abstract base class for two-player, zero-sum, deterministic games.\nType Parameters:\n    StateType: The representation of a game state (e.g., board configuration)\n    ActionType: The representation of a move (e.g., (row, col) tuple)\n    PlayerType: The representation of a player (e.g., \"X\", \"O\", or enum)\nAll methods must be implemented by subclasses to define game-specific logic."
  },
  "more.tictactoe.game:Game.actions": {
    "args": [
      "state"
    ],
    "code": "    def actions(self, state: StateType) -> set[ActionType]:",
    "file_path": "backend/algorithms/more/tictactoe/game.py",
    "kind": "method",
    "label": "def actions(self, state: StateType) -> set[ActionType]",
    "name": "actions",
    "returns": {
      "label": "set[ActionType]"
    },
    "summary": "Set of all legal actions available in the given state."
  },
  "more.tictactoe.game:Game.initial_state": {
    "args": [
      "self"
    ],
    "code": "    def initial_state(self) -> StateType:",
    "file_path": "backend/algorithms/more/tictactoe/game.py",
    "kind": "method",
    "label": "def initial_state(self) -> StateType",
    "name": "initial_state",
    "returns": {
      "label": "StateType"
    },
    "summary": "Initial game state with empty/default configuration."
  },
  "more.tictactoe.game:Game.minimax": {
    "args": [
      "state"
    ],
    "code": "    def minimax(self, state: StateType) -> ActionType | None:\n        pass",
    "file_path": "backend/algorithms/more/tictactoe/game.py",
    "kind": "method",
    "label": "def minimax(self, state: StateType) -> ActionType | None",
    "name": "minimax",
    "returns": {
      "label": "ActionType | None"
    },
    "summary": "Optimal action for the current player using minimax algorithm.\nReturns None if state is terminal."
  },
  "more.tictactoe.game:Game.player": {
    "args": [
      "state"
    ],
    "code": "    def player(self, state: StateType) -> PlayerType:",
    "file_path": "backend/algorithms/more/tictactoe/game.py",
    "kind": "method",
    "label": "def player(self, state: StateType) -> PlayerType",
    "name": "player",
    "returns": {
      "label": "PlayerType"
    },
    "summary": "Which player has the next turn in the given state."
  },
  "more.tictactoe.game:Game.result": {
    "args": [
      "state",
      "action"
    ],
    "code": "    def result(self, state: StateType, action: ActionType) -> StateType:\n        pass",
    "file_path": "backend/algorithms/more/tictactoe/game.py",
    "kind": "method",
    "label": "def result(self, state: StateType, action: ActionType) -> StateType",
    "name": "result",
    "raises": [
      "ValueError: If action is illegal in the given state"
    ],
    "returns": {
      "label": "StateType"
    },
    "summary": "New state resulting from applying the action."
  },
  "more.tictactoe.game:Game.terminal": {
    "args": [
      "state"
    ],
    "code": "    def terminal(self, state: StateType) -> bool:",
    "file_path": "backend/algorithms/more/tictactoe/game.py",
    "kind": "method",
    "label": "def terminal(self, state: StateType) -> bool",
    "name": "terminal",
    "returns": {
      "label": "bool"
    },
    "summary": "True if the game is over, False otherwise."
  },
  "more.tictactoe.game:Game.utility": {
    "args": [
      "state"
    ],
    "code": "    def utility(self, state: StateType) -> int | float:\n        pass",
    "file_path": "backend/algorithms/more/tictactoe/game.py",
    "kind": "method",
    "label": "def utility(self, state: StateType) -> int | float",
    "name": "utility",
    "returns": {
      "label": "int | float"
    },
    "summary": "Utility value of a terminal state.\nPositive for first player win, negative for second player win, zero for draw."
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe": {
    "code": "class TicTacToe(Game[Board, Action, Player]):\n\n    def __init__(self):\n        self._memo: dict[tuple[str, str], int] = {}\n\n    def initial_state(self) -> Board:\n        return [[EMPTY] * 3 for _ in range(3)]\n\n    def player(self, board: Board) -> Player:\n        x_count = sum(row.count(X) for row in board)\n        o_count = sum(row.count(O) for row in board)\n        return X if x_count == o_count else O\n\n    def actions(self, board: Board) -> set[Action]:\n        return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\n    def result(self, board: Board, action: Action) -> Board:\n        i, j = action\n        if board[i][j] != EMPTY:\n            raise ValueError(\"Invalid action: cell already occupied\")\n\n        current_player = self.player(board)\n        new_board = [row[:] for row in board]\n        new_board[i][j] = current_player\n        return new_board\n\n    def winner(self, board: Board) -> Player | None:\n        for row in board:\n            if row[0] == row[1] == row[2] != EMPTY:\n                return row[0]\n\n        for j in range(3):\n            if board[0][j] == board[1][j] == board[2][j] != EMPTY:\n                return board[0][j]\n\n        if board[0][0] == board[1][1] == board[2][2] != EMPTY:\n            return board[0][0]\n        if board[0][2] == board[1][1] == board[2][0] != EMPTY:\n            return board[0][2]\n\n        return None\n\n    def terminal(self, board: Board) -> bool:\n        return self.winner(board) is not None or all(cell != EMPTY for row in board for cell in row)\n\n    def utility(self, board: Board) -> int:\n        game_winner = self.winner(board)\n        return 1 if game_winner == X else (-1 if game_winner == O else 0)\n\n    def minimax(self, board: Board) -> Action | None:\n        if self.terminal(board):\n            return None\n\n        def dp(state: Board, curr_player: Player, alpha: float, beta: float) -> int:\n            state_key = (str(state), curr_player)\n            if state_key in self._memo:\n                return self._memo[state_key]\n\n            if self.terminal(state):\n                w = self.winner(state)\n                self._memo[state_key] = 1 if w == curr_player else (0 if w is None else -1)\n                return self._memo[state_key]\n\n            opponent = O if curr_player == X else X\n            value = float('-inf')\n            for action in self.actions(state):\n                value = max(value, -dp(self.result(state, action), opponent, -beta, -alpha))\n                alpha = max(alpha, value)\n                if alpha >= beta:\n                    break\n\n            self._memo[state_key] = int(value)\n            return int(value)\n\n        curr = self.player(board)\n        opponent = O if curr == X else X\n        return max(\n            self.actions(board),\n            key=lambda action: -dp(self.result(board, action), opponent, float('-inf'), float('inf'))\n        )\n\n    def reset_cache(self) -> None:\n        self._memo.clear()",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "class",
    "name": "TicTacToe",
    "summary": "Tic-tac-toe game implementation with optimal AI player.\nGame Rules:\n    - 3x3 grid\n    - Players alternate placing X and O\n    - First to get 3 in a row (horizontal, vertical, diagonal) wins\n    - Draw if board fills without winner\nTime Complexity Summary:\n    - State generation: O(1)\n    - Move generation: O(1) - fixed 3x3 board\n    - Minimax: O(b^d) where b≈5 avg, d≈9 max\n    - With alpha-beta pruning: O(b^(d/2)) average case\n    - Persistent memoization across moves for performance"
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.__init__": {
    "args": [
      "self"
    ],
    "code": "    def __init__(self):",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def __init__(self)",
    "name": "__init__",
    "summary": "Initialize with empty memoization cache for persistent optimization."
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.actions": {
    "args": [
      "board"
    ],
    "code": "    def actions(self, board: Board) -> set[Action]:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def actions(self, board: Board) -> set[Action]",
    "name": "actions",
    "returns": {
      "label": "set[Action]"
    },
    "summary": "All empty cell positions (i, j) on the 3x3 board."
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.initial_state": {
    "args": [
      "self"
    ],
    "code": "    def initial_state(self) -> Board:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def initial_state(self) -> Board",
    "name": "initial_state",
    "returns": {
      "label": "Board"
    },
    "summary": "3x3 grid filled with EMPTY (None) values."
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.minimax": {
    "args": [
      "board"
    ],
    "code": "    def minimax(self, board: Board) -> Action | None:\n            Args:\n                alpha: α = the best value the maximizing player (X) can guarantee so far\n                beta: β = the best value the minimizing player (O) can guarantee so far\n\n",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def minimax(self, board: Board) -> Action | None",
    "name": "minimax",
    "returns": {
      "label": "Action | None"
    },
    "summary": "Optimal move using minimax with alpha-beta pruning and memoization."
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.minimax.dp": {
    "args": [
      "curr_player",
      "beta",
      "alpha",
      "state"
    ],
    "code": "        def dp(state: Board, curr_player: Player, alpha: float, beta: float) -> int:\n            state_key = (str(state), curr_player)\n            if state_key in self._memo:\n                return self._memo[state_key]\n\n            if self.terminal(state):\n                w = self.winner(state)\n                self._memo[state_key] = 1 if w == curr_player else (0 if w is None else -1)\n                return self._memo[state_key]\n\n            opponent = O if curr_player == X else X\n            value = float('-inf')\n            for action in self.actions(state):\n                value = max(value, -dp(self.result(state, action), opponent, -beta, -alpha))\n                alpha = max(alpha, value)\n                if alpha >= beta:\n                    break\n\n            self._memo[state_key] = int(value)\n            return int(value)",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def dp(state: Board, curr_player: Player, alpha: float, beta: float) -> int",
    "name": "dp",
    "returns": {
      "label": "int"
    }
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.minimax.dp.alpha": {
    "kind": "parameter",
    "label": "alpha: float",
    "name": "alpha",
    "summary": "α = the best value the maximizing player (X) can guarantee so far"
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.minimax.dp.beta": {
    "kind": "parameter",
    "label": "beta: float",
    "name": "beta",
    "summary": "β = the best value the minimizing player (O) can guarantee so far"
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.player": {
    "args": [
      "board"
    ],
    "code": "    def player(self, board: Board) -> Player:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def player(self, board: Board) -> Player",
    "name": "player",
    "returns": {
      "label": "Player"
    },
    "summary": "X if move counts are equal (X goes first), otherwise O."
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.reset_cache": {
    "args": [
      "self"
    ],
    "code": "    def reset_cache(self) -> None:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def reset_cache(self) -> None",
    "name": "reset_cache",
    "returns": {
      "label": "None"
    },
    "summary": "Clear the memoization cache (useful when starting a new game)."
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.result": {
    "args": [
      "board",
      "action"
    ],
    "code": "    def result(self, board: Board, action: Action) -> Board:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def result(self, board: Board, action: Action) -> Board",
    "name": "result",
    "returns": {
      "label": "Board"
    },
    "summary": "Deep copy of board with current player's mark at action position."
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.terminal": {
    "args": [
      "board"
    ],
    "code": "    def terminal(self, board: Board) -> bool:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def terminal(self, board: Board) -> bool",
    "name": "terminal",
    "returns": {
      "label": "bool"
    },
    "summary": "True if there's a winner or board is full."
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.utility": {
    "args": [
      "board"
    ],
    "code": "    def utility(self, board: Board) -> int:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def utility(self, board: Board) -> int",
    "name": "utility",
    "returns": {
      "label": "int"
    },
    "summary": "1 if X won, -1 if O won, 0 for draw."
  },
  "more.tictactoe.tictactoe copy 2:TicTacToe.winner": {
    "args": [
      "board"
    ],
    "code": "    def winner(self, board: Board) -> Player | None:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy 2.py",
    "kind": "method",
    "label": "def winner(self, board: Board) -> Player | None",
    "name": "winner",
    "returns": {
      "label": "Player | None"
    },
    "summary": "Player with 3-in-a-row (horizontal, vertical, or diagonal), or None."
  },
  "more.tictactoe.tictactoe copy:actions": {
    "args": [
      "board"
    ],
    "code": "def actions(board):\n    return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy.py",
    "intuition": "Find all empty cells. Each empty cell is a valid action.",
    "kind": "function",
    "label": "def actions(board)",
    "name": "actions",
    "summary": "Returns set of all possible actions (i, j) available on the board.",
    "time_complexity": "O(n²) - iterate through all cells"
  },
  "more.tictactoe.tictactoe copy:initial_state": {
    "code": "def initial_state():\n    return [[EMPTY] * 3 for _ in range(3)]",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy.py",
    "kind": "function",
    "label": "def initial_state()",
    "name": "initial_state",
    "summary": "Returns starting state of the board\n(**State**: A configuration of an agent in its environment.\n**Initial State**: The state from which the search algorithm starts.)"
  },
  "more.tictactoe.tictactoe copy:minimax": {
    "args": [
      "board"
    ],
    "code": "def minimax(board):\n    if terminal(board):\n        return None\n\n    memo = {}\n\n    def dp(state, curr_player, alpha, beta):\n        state_key = (str(state), curr_player)\n        if state_key in memo:\n            return memo[state_key]\n\n        if terminal(state):\n            w = winner(state)\n            memo[state_key] = 1 if w == curr_player else (0 if w is None else -1)\n            return memo[state_key]\n\n        opponent = O if curr_player == X else X\n        value = float('-inf')\n        for action in actions(state):\n            value = max(value, -dp(result(state, action), opponent, -beta, -alpha))\n            alpha = max(alpha, value)\n            if alpha >= beta:\n                break\n\n        memo[state_key] = value\n        return value\n\n    curr = player(board)\n    opponent = O if curr == X else X\n    return max(\n        actions(board),\n        key=lambda action: -dp(result(board, action), opponent, float('-inf'), float('inf'))\n    )",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy.py",
    "intuition": "- Minimax with Alpha-Beta Pruning:\n    - *Paradigm*: Zero-sum game. Each player maximizes their own score.\n    - *Insight*: `dp(state, curr_player, alpha, beta)` returns best score with pruning.\n    - Alpha-beta prunes when alpha ≥ beta. Memoization caches repeated states.",
    "kind": "function",
    "label": "def minimax(board)",
    "name": "minimax",
    "summary": "Returns the optimal action for the current player on the board.",
    "time_complexity": "O(b^(d/2)) average case with pruning\nwhere b is branching factor (~5 avg), d is depth (~9 max)"
  },
  "more.tictactoe.tictactoe copy:player": {
    "args": [
      "board"
    ],
    "code": "def player(board):\n    x_count = sum(row.count(X) for row in board)\n    o_count = sum(row.count(O) for row in board)\n    return X if x_count == o_count else O",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy.py",
    "intuition": "- Count moves: X goes first, so if X and O have equal counts, it's X's turn.\n    - Otherwise, it's O's turn.",
    "kind": "function",
    "label": "def player(board)",
    "name": "player",
    "summary": "Returns player who has the next turn on a board.",
    "time_complexity": "O(n²) - iterate through all cells"
  },
  "more.tictactoe.tictactoe copy:result": {
    "args": [
      "board",
      "action"
    ],
    "code": "def result(board, action):\n    i, j = action\n    if board[i][j] != EMPTY:\n        raise ValueError(\"Invalid action: cell already occupied\")\n\n    current_player = player(board)\n    new_board = [row[:] for row in board]\n    new_board[i][j] = current_player\n    return new_board",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy.py",
    "intuition": "- Create deep copy of board, apply the action for current player.\n    - Validates action is legal.",
    "kind": "function",
    "label": "def result(board, action)",
    "name": "result",
    "summary": "Returns the board that results from making move (i, j) on the board.",
    "time_complexity": "O(n²) - deep copy the board"
  },
  "more.tictactoe.tictactoe copy:terminal": {
    "args": [
      "board"
    ],
    "code": "def terminal(board):\n    return winner(board) is not None or all(cell != EMPTY for row in board for cell in row)",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy.py",
    "intuition": "Game is over if there's a winner or no empty cells remain.",
    "kind": "function",
    "label": "def terminal(board)",
    "name": "terminal",
    "summary": "Returns True if game is over, False otherwise.",
    "time_complexity": "O(1) for winner check, O(n²) for board full check"
  },
  "more.tictactoe.tictactoe copy:utility": {
    "args": [
      "board"
    ],
    "code": "def utility(board):\n    game_winner = winner(board)\n    return 1 if game_winner == X else (-1 if game_winner == O else 0)",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy.py",
    "intuition": "Terminal utility value for minimax. X maximizes, O minimizes.",
    "kind": "function",
    "label": "def utility(board)",
    "name": "utility",
    "summary": "Returns 1 if X has won the game, -1 if O has won, 0 otherwise.",
    "time_complexity": "O(1) - winner check is constant time"
  },
  "more.tictactoe.tictactoe copy:winner": {
    "args": [
      "board"
    ],
    "code": "def winner(board):\n    for row in board:\n        if row[0] == row[1] == row[2] != EMPTY:\n            return row[0]\n\n    for j in range(3):\n        if board[0][j] == board[1][j] == board[2][j] != EMPTY:\n            return board[0][j]\n\n    if board[0][0] == board[1][1] == board[2][2] != EMPTY:\n        return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] != EMPTY:\n        return board[0][2]\n\n    return None",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe copy.py",
    "intuition": "- Check all possible winning lines: 3 rows, 3 columns, 2 diagonals.\n    - Return the player if they have 3 in a row.",
    "kind": "function",
    "label": "def winner(board)",
    "name": "winner",
    "summary": "Returns the winner of the game, if there is one.",
    "time_complexity": "O(1) - constant 8 lines to check"
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe": {
    "code": "class TicTacToe(Game[Board, Action, Player]):\n\n    def __init__(self):\n        self._memo: dict[tuple[str, str], int] = {}\n\n    def initial_state(self) -> Board:\n        return [[EMPTY] * 3 for _ in range(3)]\n\n    def player(self, board: Board) -> Player:\n        x_count = sum(row.count(X) for row in board)\n        o_count = sum(row.count(O) for row in board)\n        return X if x_count == o_count else O\n\n    def actions(self, board: Board) -> set[Action]:\n        return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\n    def result(self, board: Board, action: Action) -> Board:\n        i, j = action\n        if board[i][j] != EMPTY:\n            raise ValueError(\"Invalid action: cell already occupied\")\n\n        current_player = self.player(board)\n        new_board = [row[:] for row in board]\n        new_board[i][j] = current_player\n        return new_board\n\n    def winner(self, board: Board) -> Player | None:\n        for row in board:\n            if row[0] == row[1] == row[2] != EMPTY:\n                return row[0]\n\n        for j in range(3):\n            if board[0][j] == board[1][j] == board[2][j] != EMPTY:\n                return board[0][j]\n\n        if board[0][0] == board[1][1] == board[2][2] != EMPTY:\n            return board[0][0]\n        if board[0][2] == board[1][1] == board[2][0] != EMPTY:\n            return board[0][2]\n\n        return None\n\n    def terminal(self, board: Board) -> bool:\n        return self.winner(board) is not None or all(cell != EMPTY for row in board for cell in row)\n\n    def utility(self, board: Board) -> int:\n        game_winner = self.winner(board)\n        return 1 if game_winner == X else (-1 if game_winner == O else 0)\n\n    def minimax(self, board: Board) -> Action | None:\n        if self.terminal(board):\n            return None\n\n        def dp(state: Board, curr_player: Player, alpha: float, beta: float) -> int:\n            key = (str(state), curr_player)\n            if key in self._memo:\n                return self._memo[key]\n\n            if self.terminal(state):\n                val = self.utility(state)\n                self._memo[key] = val\n                return val\n\n            maximizing = (curr_player == X)\n            next_player = O if curr_player == X else X\n\n            if maximizing:\n                value = float(\"-inf\")\n                for action in self.actions(state):\n                    value = max(value, dp(self.result(state, action), next_player, alpha, beta))\n                    alpha = max(alpha, value)\n                    if alpha >= beta:\n                        break\n            else:\n                value = float(\"inf\")\n                for action in self.actions(state):\n                    value = min(value, dp(self.result(state, action), next_player, alpha, beta))\n                    beta = min(beta, value)\n                    if alpha >= beta:\n                        break\n\n            self._memo[key] = int(value)\n            return self._memo[key]\n\n        curr = self.player(board)\n        next_player = O if curr == X else X\n\n        if curr == X:\n            return max(\n                self.actions(board),\n                key=lambda action: dp(self.result(board, action), next_player, float(\"-inf\"), float(\"inf\")),\n            )\n        else:\n            return min(\n                self.actions(board),\n                key=lambda action: dp(self.result(board, action), next_player, float(\"-inf\"), float(\"inf\")),\n            )\n    def reset_cache(self) -> None:\n        self._memo.clear()",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "class",
    "name": "TicTacToe",
    "summary": "Tic-tac-toe game implementation with optimal AI player.\nGame Rules:\n    - 3x3 grid\n    - Players alternate placing X and O\n    - First to get 3 in a row (horizontal, vertical, diagonal) wins\n    - Draw if board fills without winner\nTime Complexity Summary:\n    - State generation: O(1)\n    - Move generation: O(1) - fixed 3x3 board\n    - Minimax: O(b^d) where b≈5 avg, d≈9 max\n    - With alpha-beta pruning: O(b^(d/2)) average case\n    - Persistent memoization across moves for performance"
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe.__init__": {
    "args": [
      "self"
    ],
    "code": "    def __init__(self):",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "method",
    "label": "def __init__(self)",
    "name": "__init__",
    "summary": "Initialize with empty memoization cache for persistent optimization."
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe.actions": {
    "args": [
      "board"
    ],
    "code": "    def actions(self, board: Board) -> set[Action]:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "method",
    "label": "def actions(self, board: Board) -> set[Action]",
    "name": "actions",
    "returns": {
      "label": "set[Action]"
    },
    "summary": "All empty cell positions (i, j) on the 3x3 board."
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe.initial_state": {
    "args": [
      "self"
    ],
    "code": "    def initial_state(self) -> Board:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "method",
    "label": "def initial_state(self) -> Board",
    "name": "initial_state",
    "returns": {
      "label": "Board"
    },
    "summary": "3x3 grid filled with EMPTY (None) values."
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe.minimax": {
    "args": [
      "board"
    ],
    "code": "    def minimax(self, board: Board) -> Action | None:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "method",
    "label": "def minimax(self, board: Board) -> Action | None",
    "name": "minimax",
    "returns": {
      "label": "Action | None"
    },
    "summary": "Optimal move using classical minimax with alpha-beta pruning."
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe.player": {
    "args": [
      "board"
    ],
    "code": "    def player(self, board: Board) -> Player:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "method",
    "label": "def player(self, board: Board) -> Player",
    "name": "player",
    "returns": {
      "label": "Player"
    },
    "summary": "X if move counts are equal (X goes first), otherwise O."
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe.reset_cache": {
    "args": [
      "self"
    ],
    "code": "    def reset_cache(self) -> None:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "method",
    "label": "def reset_cache(self) -> None",
    "name": "reset_cache",
    "returns": {
      "label": "None"
    },
    "summary": "Clear the memoization cache (useful when starting a new game)."
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe.result": {
    "args": [
      "board",
      "action"
    ],
    "code": "    def result(self, board: Board, action: Action) -> Board:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "method",
    "label": "def result(self, board: Board, action: Action) -> Board",
    "name": "result",
    "returns": {
      "label": "Board"
    },
    "summary": "Deep copy of board with current player's mark at action position."
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe.terminal": {
    "args": [
      "board"
    ],
    "code": "    def terminal(self, board: Board) -> bool:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "method",
    "label": "def terminal(self, board: Board) -> bool",
    "name": "terminal",
    "returns": {
      "label": "bool"
    },
    "summary": "True if there's a winner or board is full."
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe.utility": {
    "args": [
      "board"
    ],
    "code": "    def utility(self, board: Board) -> int:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "method",
    "label": "def utility(self, board: Board) -> int",
    "name": "utility",
    "returns": {
      "label": "int"
    },
    "summary": "1 if X won, -1 if O won, 0 for draw."
  },
  "more.tictactoe.tictactoe-minimax:TicTacToe.winner": {
    "args": [
      "board"
    ],
    "code": "    def winner(self, board: Board) -> Player | None:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe-minimax.py",
    "kind": "method",
    "label": "def winner(self, board: Board) -> Player | None",
    "name": "winner",
    "returns": {
      "label": "Player | None"
    },
    "summary": "Player with 3-in-a-row (horizontal, vertical, or diagonal), or None."
  },
  "more.tictactoe.tictactoe:TicTacToe": {
    "code": "class TicTacToe(Game[Board, Action, Player]):\n\n    def __init__(self):\n        self._memo: dict[tuple[str, str], int] = {}\n\n    def initial_state(self) -> Board:\n        return [[EMPTY] * 3 for _ in range(3)]\n\n    def player(self, board: Board) -> Player:\n        x_count = sum(row.count(X) for row in board)\n        o_count = sum(row.count(O) for row in board)\n        return X if x_count == o_count else O\n\n    def actions(self, board: Board) -> set[Action]:\n        return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\n    def result(self, board: Board, action: Action) -> Board:\n        i, j = action\n        if board[i][j] != EMPTY:\n            raise ValueError(\"Invalid action: cell already occupied\")\n\n        current_player = self.player(board)\n        new_board = [row[:] for row in board]\n        new_board[i][j] = current_player\n        return new_board\n\n    def winner(self, board: Board) -> Player | None:\n        for row in board:\n            if row[0] == row[1] == row[2] != EMPTY:\n                return row[0]\n\n        for j in range(3):\n            if board[0][j] == board[1][j] == board[2][j] != EMPTY:\n                return board[0][j]\n\n        if board[0][0] == board[1][1] == board[2][2] != EMPTY:\n            return board[0][0]\n        if board[0][2] == board[1][1] == board[2][0] != EMPTY:\n            return board[0][2]\n\n        return None\n\n    def terminal(self, board: Board) -> bool:\n        return self.winner(board) is not None or all(cell != EMPTY for row in board for cell in row)\n\n    def utility(self, board: Board) -> int:\n        game_winner = self.winner(board)\n        return 1 if game_winner == X else (-1 if game_winner == O else 0)\n\n    def minimax(self, board: Board) -> Action | None:\n        if self.terminal(board):\n            return None\n\n        def dp(state: Board, curr_player: Player, alpha: float, beta: float) -> int:\n            state_key = (str(state), curr_player)\n            if state_key not in self._memo:\n\n                if self.terminal(state):\n                    w = self.winner(state)\n                    self._memo[state_key] = 1 if w == curr_player else (0 if w is None else -1)\n                    return self._memo[state_key]\n\n                opponent = O if curr_player == X else X\n                value = float('-inf')\n                for action in self.actions(state):\n                    value = max(value, -dp(self.result(state, action), opponent, -beta, -alpha))\n                    alpha = max(alpha, value)\n                    if alpha >= beta:\n                        break\n\n                self._memo[state_key] = int(value)\n            return  self._memo[state_key] \n\n        curr = self.player(board)\n        opponent = O if curr == X else X\n        return max(\n            self.actions(board),\n            key=lambda action: -dp(self.result(board, action), opponent, float('-inf'), float('inf'))\n        )\n\n    def reset_cache(self) -> None:\n        self._memo.clear()",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "class",
    "name": "TicTacToe",
    "summary": "Tic-tac-toe game implementation with optimal AI player.\nGame Rules:\n    - 3x3 grid\n    - Players alternate placing X and O\n    - First to get 3 in a row (horizontal, vertical, diagonal) wins\n    - Draw if board fills without winner\nTime Complexity Summary:\n    - State generation: O(1)\n    - Move generation: O(1) - fixed 3x3 board\n    - Minimax: O(b^d) where b≈5 avg, d≈9 max\n    - With alpha-beta pruning: O(b^(d/2)) average case\n    - Persistent memoization across moves for performance"
  },
  "more.tictactoe.tictactoe:TicTacToe.__init__": {
    "args": [
      "self"
    ],
    "code": "    def __init__(self):",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def __init__(self)",
    "name": "__init__",
    "summary": "Initialize with empty memoization cache for persistent optimization."
  },
  "more.tictactoe.tictactoe:TicTacToe.actions": {
    "args": [
      "board"
    ],
    "code": "    def actions(self, board: Board) -> set[Action]:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def actions(self, board: Board) -> set[Action]",
    "name": "actions",
    "returns": {
      "label": "set[Action]"
    },
    "summary": "All empty cell positions (i, j) on the 3x3 board."
  },
  "more.tictactoe.tictactoe:TicTacToe.initial_state": {
    "args": [
      "self"
    ],
    "code": "    def initial_state(self) -> Board:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def initial_state(self) -> Board",
    "name": "initial_state",
    "returns": {
      "label": "Board"
    },
    "summary": "3x3 grid filled with EMPTY (None) values."
  },
  "more.tictactoe.tictactoe:TicTacToe.minimax": {
    "args": [
      "board"
    ],
    "code": "    def minimax(self, board: Board) -> Action | None:\n            Args:\n                alpha: α = the best value the maximizing player (X) can guarantee so far\n                beta: β = the best value the minimizing player (O) can guarantee so far\n\n",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def minimax(self, board: Board) -> Action | None",
    "name": "minimax",
    "returns": {
      "label": "Action | None"
    },
    "summary": "Optimal move using minimax with alpha-beta pruning and memoization."
  },
  "more.tictactoe.tictactoe:TicTacToe.minimax.dp": {
    "args": [
      "curr_player",
      "beta",
      "alpha",
      "state"
    ],
    "code": "        def dp(state: Board, curr_player: Player, alpha: float, beta: float) -> int:\n            state_key = (str(state), curr_player)\n            if state_key not in self._memo:\n\n                if self.terminal(state):\n                    w = self.winner(state)\n                    self._memo[state_key] = 1 if w == curr_player else (0 if w is None else -1)\n                    return self._memo[state_key]\n\n                opponent = O if curr_player == X else X\n                value = float('-inf')\n                for action in self.actions(state):\n                    value = max(value, -dp(self.result(state, action), opponent, -beta, -alpha))\n                    alpha = max(alpha, value)\n                    if alpha >= beta:\n                        break\n\n                self._memo[state_key] = int(value)\n            return  self._memo[state_key] ",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def dp(state: Board, curr_player: Player, alpha: float, beta: float) -> int",
    "name": "dp",
    "returns": {
      "label": "int"
    }
  },
  "more.tictactoe.tictactoe:TicTacToe.minimax.dp.alpha": {
    "kind": "parameter",
    "label": "alpha: float",
    "name": "alpha",
    "summary": "α = the best value the maximizing player (X) can guarantee so far"
  },
  "more.tictactoe.tictactoe:TicTacToe.minimax.dp.beta": {
    "kind": "parameter",
    "label": "beta: float",
    "name": "beta",
    "summary": "β = the best value the minimizing player (O) can guarantee so far"
  },
  "more.tictactoe.tictactoe:TicTacToe.player": {
    "args": [
      "board"
    ],
    "code": "    def player(self, board: Board) -> Player:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def player(self, board: Board) -> Player",
    "name": "player",
    "returns": {
      "label": "Player"
    },
    "summary": "X if move counts are equal (X goes first), otherwise O."
  },
  "more.tictactoe.tictactoe:TicTacToe.reset_cache": {
    "args": [
      "self"
    ],
    "code": "    def reset_cache(self) -> None:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def reset_cache(self) -> None",
    "name": "reset_cache",
    "returns": {
      "label": "None"
    },
    "summary": "Clear the memoization cache (useful when starting a new game)."
  },
  "more.tictactoe.tictactoe:TicTacToe.result": {
    "args": [
      "board",
      "action"
    ],
    "code": "    def result(self, board: Board, action: Action) -> Board:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def result(self, board: Board, action: Action) -> Board",
    "name": "result",
    "returns": {
      "label": "Board"
    },
    "summary": "Deep copy of board with current player's mark at action position."
  },
  "more.tictactoe.tictactoe:TicTacToe.terminal": {
    "args": [
      "board"
    ],
    "code": "    def terminal(self, board: Board) -> bool:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def terminal(self, board: Board) -> bool",
    "name": "terminal",
    "returns": {
      "label": "bool"
    },
    "summary": "True if there's a winner or board is full."
  },
  "more.tictactoe.tictactoe:TicTacToe.utility": {
    "args": [
      "board"
    ],
    "code": "    def utility(self, board: Board) -> int:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def utility(self, board: Board) -> int",
    "name": "utility",
    "returns": {
      "label": "int"
    },
    "summary": "1 if X won, -1 if O won, 0 for draw."
  },
  "more.tictactoe.tictactoe:TicTacToe.winner": {
    "args": [
      "board"
    ],
    "code": "    def winner(self, board: Board) -> Player | None:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe.py",
    "kind": "method",
    "label": "def winner(self, board: Board) -> Player | None",
    "name": "winner",
    "returns": {
      "label": "Player | None"
    },
    "summary": "Player with 3-in-a-row (horizontal, vertical, or diagonal), or None."
  },
  "more.tictactoe.tictactoe_no_player_in_state:TicTacToe": {
    "code": "class TicTacToe(Game[Board, Action, Player]):\n\n    def __init__(self):\n        self._memo: dict[tuple[str, str], int] = {}\n\n    def initial_state(self) -> Board:\n        return [[EMPTY] * 3 for _ in range(3)]\n\n    def player(self, board: Board) -> Player:\n        x_count = sum(row.count(X) for row in board)\n        o_count = sum(row.count(O) for row in board)\n        return X if x_count == o_count else O\n\n    def actions(self, board: Board) -> set[Action]:\n        return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\n    def result(self, board: Board, action: Action) -> Board:\n        i, j = action\n        if board[i][j] != EMPTY:\n            raise ValueError(\"Invalid action: cell already occupied\")\n\n        current_player = self.player(board)\n        new_board = [row[:] for row in board]\n        new_board[i][j] = current_player\n        return new_board\n\n    def winner(self, board: Board) -> Player | None:\n        for row in board:\n            if row[0] == row[1] == row[2] != EMPTY:\n                return row[0]\n\n        for j in range(3):\n            if board[0][j] == board[1][j] == board[2][j] != EMPTY:\n                return board[0][j]\n\n        if board[0][0] == board[1][1] == board[2][2] != EMPTY:\n            return board[0][0]\n        if board[0][2] == board[1][1] == board[2][0] != EMPTY:\n            return board[0][2]\n\n        return None\n\n    def terminal(self, board: Board) -> bool:\n        return self.winner(board) is not None or all(cell != EMPTY for row in board for cell in row)\n\n    def utility(self, board: Board) -> int:\n        game_winner = self.winner(board)\n        return 1 if game_winner == X else (-1 if game_winner == O else 0)\n\n    def minimax(self, board: Board) -> Action | None:\n        if self.terminal(board):\n            return None\n\n        memo: dict[str, int] = {}\n\n        def eval_state(state: Board, alpha: int, beta: int) -> int:\n            key = str(state)\n            if key in memo:\n                return memo[key]\n            if self.terminal(state):\n                v = self.utility(state)\n                memo[key] = v\n                return v\n\n            curr = self.player(state)\n            if curr == X:\n                value = -2\n                for action in self.actions(state):\n                    value = max(value, eval_state(self.result(state, action), alpha, beta))\n                    alpha = max(alpha, value)\n                    if alpha >= beta:\n                        break\n            else:\n                value = 2\n                for action in self.actions(state):\n                    value = min(value, eval_state(self.result(state, action), alpha, beta))\n                    beta = min(beta, value)\n                    if alpha >= beta:\n                        break\n\n            memo[key] = value\n            return value\n\n        curr = self.player(board)\n        acts = self.actions(board)\n        if curr == X:\n            return max(acts, key=lambda a: eval_state(self.result(board, a), -2, 2))\n        else:\n            return min(acts, key=lambda a: eval_state(self.result(board, a), -2, 2))\n\n    def reset_cache(self) -> None:\n        self._memo.clear()",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_no_player_in_state.py",
    "kind": "class",
    "name": "TicTacToe",
    "summary": "Tic-tac-toe game implementation with optimal AI player.\nGame Rules:\n    - 3x3 grid\n    - Players alternate placing X and O\n    - First to get 3 in a row (horizontal, vertical, diagonal) wins\n    - Draw if board fills without winner\nTime Complexity Summary:\n    - State generation: O(1)\n    - Move generation: O(1) - fixed 3x3 board\n    - Minimax: O(b^d) where b≈5 avg, d≈9 max\n    - With alpha-beta pruning: O(b^(d/2)) average case\n    - Persistent memoization across moves for performance"
  },
  "more.tictactoe.tictactoe_no_player_in_state:TicTacToe.__init__": {
    "args": [
      "self"
    ],
    "code": "    def __init__(self):",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_no_player_in_state.py",
    "kind": "method",
    "label": "def __init__(self)",
    "name": "__init__",
    "summary": "Initialize with empty memoization cache for persistent optimization."
  },
  "more.tictactoe.tictactoe_no_player_in_state:TicTacToe.actions": {
    "args": [
      "board"
    ],
    "code": "    def actions(self, board: Board) -> set[Action]:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_no_player_in_state.py",
    "kind": "method",
    "label": "def actions(self, board: Board) -> set[Action]",
    "name": "actions",
    "returns": {
      "label": "set[Action]"
    },
    "summary": "All empty cell positions (i, j) on the 3x3 board."
  },
  "more.tictactoe.tictactoe_no_player_in_state:TicTacToe.initial_state": {
    "args": [
      "self"
    ],
    "code": "    def initial_state(self) -> Board:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_no_player_in_state.py",
    "kind": "method",
    "label": "def initial_state(self) -> Board",
    "name": "initial_state",
    "returns": {
      "label": "Board"
    },
    "summary": "3x3 grid filled with EMPTY (None) values."
  },
  "more.tictactoe.tictactoe_no_player_in_state:TicTacToe.player": {
    "args": [
      "board"
    ],
    "code": "    def player(self, board: Board) -> Player:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_no_player_in_state.py",
    "kind": "method",
    "label": "def player(self, board: Board) -> Player",
    "name": "player",
    "returns": {
      "label": "Player"
    },
    "summary": "X if move counts are equal (X goes first), otherwise O."
  },
  "more.tictactoe.tictactoe_no_player_in_state:TicTacToe.reset_cache": {
    "args": [
      "self"
    ],
    "code": "    def reset_cache(self) -> None:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_no_player_in_state.py",
    "kind": "method",
    "label": "def reset_cache(self) -> None",
    "name": "reset_cache",
    "returns": {
      "label": "None"
    },
    "summary": "Clear the memoization cache (useful when starting a new game)."
  },
  "more.tictactoe.tictactoe_no_player_in_state:TicTacToe.result": {
    "args": [
      "board",
      "action"
    ],
    "code": "    def result(self, board: Board, action: Action) -> Board:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_no_player_in_state.py",
    "kind": "method",
    "label": "def result(self, board: Board, action: Action) -> Board",
    "name": "result",
    "returns": {
      "label": "Board"
    },
    "summary": "Deep copy of board with current player's mark at action position."
  },
  "more.tictactoe.tictactoe_no_player_in_state:TicTacToe.terminal": {
    "args": [
      "board"
    ],
    "code": "    def terminal(self, board: Board) -> bool:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_no_player_in_state.py",
    "kind": "method",
    "label": "def terminal(self, board: Board) -> bool",
    "name": "terminal",
    "returns": {
      "label": "bool"
    },
    "summary": "True if there's a winner or board is full."
  },
  "more.tictactoe.tictactoe_no_player_in_state:TicTacToe.utility": {
    "args": [
      "board"
    ],
    "code": "    def utility(self, board: Board) -> int:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_no_player_in_state.py",
    "kind": "method",
    "label": "def utility(self, board: Board) -> int",
    "name": "utility",
    "returns": {
      "label": "int"
    },
    "summary": "1 if X won, -1 if O won, 0 for draw."
  },
  "more.tictactoe.tictactoe_no_player_in_state:TicTacToe.winner": {
    "args": [
      "board"
    ],
    "code": "    def winner(self, board: Board) -> Player | None:",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_no_player_in_state.py",
    "kind": "method",
    "label": "def winner(self, board: Board) -> Player | None",
    "name": "winner",
    "returns": {
      "label": "Player | None"
    },
    "summary": "Player with 3-in-a-row (horizontal, vertical, or diagonal), or None."
  },
  "more.tictactoe.tictactoe_old:actions": {
    "args": [
      "board"
    ],
    "code": "def actions(board):\n    return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_old.py",
    "intuition": "Find all empty cells. Each empty cell is a valid action.",
    "kind": "function",
    "label": "def actions(board)",
    "name": "actions",
    "summary": "Returns set of all possible actions (i, j) available on the board.",
    "time_complexity": "O(n²) - iterate through all cells"
  },
  "more.tictactoe.tictactoe_old:initial_state": {
    "code": "def initial_state():\n    return [[EMPTY] * 3 for _ in range(3)]",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_old.py",
    "kind": "function",
    "label": "def initial_state()",
    "name": "initial_state",
    "summary": "Returns starting state of the board."
  },
  "more.tictactoe.tictactoe_old:minimax": {
    "args": [
      "board"
    ],
    "code": "def minimax(board):\n    if terminal(board):\n        return None\n\n    memo = {}\n\n    def dp(state, curr_player, alpha, beta):\n        state_key = (str(state), curr_player)\n        if state_key in memo:\n            return memo[state_key]\n\n        if terminal(state):\n            w = winner(state)\n            memo[state_key] = 1 if w == curr_player else (0 if w is None else -1)\n            return memo[state_key]\n\n        opponent = O if curr_player == X else X\n        value = float('-inf')\n        for action in actions(state):\n            value = max(value, -dp(result(state, action), opponent, -beta, -alpha))\n            alpha = max(alpha, value)\n            if alpha >= beta:\n                break\n\n        memo[state_key] = value\n        return value\n\n    curr = player(board)\n    opponent = O if curr == X else X\n    return max(\n        actions(board),\n        key=lambda action: -dp(result(board, action), opponent, float('-inf'), float('inf'))\n    )",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_old.py",
    "intuition": "- Minimax with Alpha-Beta Pruning:\n    - *Paradigm*: Zero-sum game. Each player maximizes their own score.\n    - *Insight*: `dp(state, curr_player, alpha, beta)` returns best score with pruning.\n    - Alpha-beta prunes when alpha ≥ beta. Memoization caches repeated states.",
    "kind": "function",
    "label": "def minimax(board)",
    "name": "minimax",
    "summary": "Returns the optimal action for the current player on the board.",
    "time_complexity": "O(b^(d/2)) average case with pruning\nwhere b is branching factor (~5 avg), d is depth (~9 max)"
  },
  "more.tictactoe.tictactoe_old:player": {
    "args": [
      "board"
    ],
    "code": "def player(board):\n    x_count = sum(row.count(X) for row in board)\n    o_count = sum(row.count(O) for row in board)\n    return X if x_count == o_count else O",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_old.py",
    "intuition": "- Count moves: X goes first, so if X and O have equal counts, it's X's turn.\n    - Otherwise, it's O's turn.",
    "kind": "function",
    "label": "def player(board)",
    "name": "player",
    "summary": "Returns player who has the next turn on a board.",
    "time_complexity": "O(n²) - iterate through all cells"
  },
  "more.tictactoe.tictactoe_old:result": {
    "args": [
      "board",
      "action"
    ],
    "code": "def result(board, action):\n    i, j = action\n    if board[i][j] != EMPTY:\n        raise ValueError(\"Invalid action: cell already occupied\")\n\n    current_player = player(board)\n    new_board = [row[:] for row in board]\n    new_board[i][j] = current_player\n    return new_board",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_old.py",
    "intuition": "- Create deep copy of board, apply the action for current player.\n    - Validates action is legal.",
    "kind": "function",
    "label": "def result(board, action)",
    "name": "result",
    "summary": "Returns the board that results from making move (i, j) on the board.",
    "time_complexity": "O(n²) - deep copy the board"
  },
  "more.tictactoe.tictactoe_old:terminal": {
    "args": [
      "board"
    ],
    "code": "def terminal(board):\n    return winner(board) is not None or all(cell != EMPTY for row in board for cell in row)",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_old.py",
    "intuition": "Game is over if there's a winner or no empty cells remain.",
    "kind": "function",
    "label": "def terminal(board)",
    "name": "terminal",
    "summary": "Returns True if game is over, False otherwise.",
    "time_complexity": "O(1) for winner check, O(n²) for board full check"
  },
  "more.tictactoe.tictactoe_old:utility": {
    "args": [
      "board"
    ],
    "code": "def utility(board):\n    game_winner = winner(board)\n    return 1 if game_winner == X else (-1 if game_winner == O else 0)",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_old.py",
    "intuition": "Terminal utility value for minimax. X maximizes, O minimizes.",
    "kind": "function",
    "label": "def utility(board)",
    "name": "utility",
    "summary": "Returns 1 if X has won the game, -1 if O has won, 0 otherwise.",
    "time_complexity": "O(1) - winner check is constant time"
  },
  "more.tictactoe.tictactoe_old:winner": {
    "args": [
      "board"
    ],
    "code": "def winner(board):\n    for row in board:\n        if row[0] == row[1] == row[2] != EMPTY:\n            return row[0]\n\n    for j in range(3):\n        if board[0][j] == board[1][j] == board[2][j] != EMPTY:\n            return board[0][j]\n\n    if board[0][0] == board[1][1] == board[2][2] != EMPTY:\n        return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] != EMPTY:\n        return board[0][2]\n\n    return None",
    "file_path": "backend/algorithms/more/tictactoe/tictactoe_old.py",
    "intuition": "- Check all possible winning lines: 3 rows, 3 columns, 2 diagonals.\n    - Return the player if they have 3 in a row.",
    "kind": "function",
    "label": "def winner(board)",
    "name": "winner",
    "summary": "Returns the winner of the game, if there is one.",
    "time_complexity": "O(1) - constant 8 lines to check"
  },
  "problems.1-two-sum.solution:two_sum": {
    "args": [
      "target",
      "nums"
    ],
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n\n    seen = {}\n\n    for i, num in enumerate(nums):\n        if (x := target - num) in seen:\n            return seen[x], i\n        seen[num] = i",
    "file_path": "backend/algorithms/problems/1-two-sum/solution.py",
    "kind": "function",
    "label": "def two_sum(nums: list[int], target: int) -> list[int]",
    "name": "two_sum",
    "returns": {
      "label": "list[int]"
    },
    "time_complexity": "O(n)\nwhere n is the length of the nums array. We iterate through the array once."
  },
  "problems.1000-minimum-cost-to-merge-stones.solution:Solution.mergeStones": {
    "args": [
      "stones",
      "K"
    ],
    "code": "    def mergeStones(self, stones: list[int], K: int) -> int:\n        if ((n := len(stones)) - 1) % (K - 1):return -1\n\n        prefix, memo = [0], {}\n        for x in stones: prefix.append(prefix[-1] + x)\n        cost = lambda l, r: 0 if (r - l) % (K - 1) else prefix[r + 1] - prefix[l]\n\n        def dp(l, r):\n            if (key := (l, r)) not in memo:\n                memo[key] = min(\n                    (dp(l, t) + dp(t + 1, r) + cost(l, r) for t in range(l, r, K - 1)),\n                    default=0,\n                )\n            return memo[key]\n\n        return dp(0, n - 1)",
    "expressions": {
      "(r - l) % (K - 1)": "- Each merge reduces the pile count by K - 1\n            - Start: **n** piles\n                - After 1 merge → **n - (K - 1)** piles\n                - After 2 merges → **n - 2(K - 1)** piles\n                - After 3 merges → **n - 3(K - 1)** piles\n                - …and so on, until (if possible) you reach 1 pile\n        - So to reach 1 pile from `n`, we need:\n            - *n - x(K - 1) = 1*,\n            - *n - 1 = x (K - 1)* for some integer *x*.\n        - Thus (n - 1) must be divisible by (K - 1)\n           - checked in code by `(n - 1) % (K - 1) == 0`\n           - If not, merging all piles into one is impossible."
    },
    "file_path": "backend/algorithms/problems/1000-minimum-cost-to-merge-stones/solution.py",
    "kind": "method",
    "label": "def mergeStones(self, stones: list[int], K: int) -> int",
    "name": "mergeStones",
    "returns": {
      "label": "int"
    },
    "space_complexity": "O(n²) for memoization",
    "time_complexity": "O(n^3):\nThere are **O(n²)** subproblems (`l, r` pairs)\nFor each subproblem, the loop `[language=\"python\"]for t in range(l, r, K - 1)`\n    tries up to **O(n / (K - 1))** split points.\n    Each operation inside is *O(1)* (thanks to *[2!]prefix sums*)\nSo the time complexity is O(n^3 / (K - 1))"
  },
  "problems.1000-minimum-cost-to-merge-stones.solution:Solution.mergeStones.(r - l) % (K - 1)": {
    "kind": "expression",
    "name": "(r - l) % (K - 1)",
    "summary": "- Each merge reduces the pile count by K - 1\n            - Start: **n** piles\n                - After 1 merge → **n - (K - 1)** piles\n                - After 2 merges → **n - 2(K - 1)** piles\n                - After 3 merges → **n - 3(K - 1)** piles\n                - …and so on, until (if possible) you reach 1 pile\n        - So to reach 1 pile from `n`, we need:\n            - *n - x(K - 1) = 1*,\n            - *n - 1 = x (K - 1)* for some integer *x*.\n        - Thus (n - 1) must be divisible by (K - 1)\n           - checked in code by `(n - 1) % (K - 1) == 0`\n           - If not, merging all piles into one is impossible."
  },
  "problems.1000-minimum-cost-to-merge-stones.solution:Solution.mergeStones.dp": {
    "args": [
      "l",
      "r"
    ],
    "code": "        def dp(l, r):\n            if (key := (l, r)) not in memo:\n                memo[key] = min(\n                    (dp(l, t) + dp(t + 1, r) + cost(l, r) for t in range(l, r, K - 1)),\n                    default=0,\n                )\n            return memo[key]",
    "expressions": {
      "default=0": "If `r - l < K - 1` (the range of split points `range(l, r, K - 1`) is empty),                     meaning there aren't enough piles to form a *K-merge* yet — so no merge is possible yet,                    so no merge occurs so the cost is *0*.",
      "range(l, r, K - 1)": "The loop `range(l, r, K - 1)` enforces valid split points                     so each merge step always combines exactly *K* piles."
    },
    "file_path": "backend/algorithms/problems/1000-minimum-cost-to-merge-stones/solution.py",
    "kind": "method",
    "label": "def dp(l, r)",
    "name": "dp",
    "summary": "**Subproblem `dp(l, r)`**\n     Minimum total cost to reduce *stones[l..r]*             to the smallest legally attainable pile count under *K-merges*, which is *1 + ((r - l) % (K - 1))*.\n    When do we add a merge cost? Only if `(r - l) % (K - 1) == 0` (segment can fully collapse to one pile), in which case we include `cost(l, r)`."
  },
  "problems.1000-minimum-cost-to-merge-stones.solution:Solution.mergeStones.dp.default=0": {
    "kind": "expression",
    "name": "default=0",
    "summary": "If `r - l < K - 1` (the range of split points `range(l, r, K - 1`) is empty),                     meaning there aren't enough piles to form a *K-merge* yet — so no merge is possible yet,                    so no merge occurs so the cost is *0*."
  },
  "problems.1000-minimum-cost-to-merge-stones.solution:Solution.mergeStones.dp.range(l, r, K - 1)": {
    "kind": "expression",
    "name": "range(l, r, K - 1)",
    "summary": "The loop `range(l, r, K - 1)` enforces valid split points                     so each merge step always combines exactly *K* piles."
  },
  "problems.1011-capacity-to-ship-packages-within-d-days.solution:capacity_to_ship_packages_within_d_days": {
    "args": [
      "weights",
      "days"
    ],
    "code": "def capacity_to_ship_packages_within_d_days(weights: list[int], days: int) -> int:\n    def days_needed(capacity: int) -> int:\n        d, load = 1, 0\n        for w in weights:\n            if load + w <= capacity:\n                load += w\n            else:\n                d += 1\n                load = w\n        return d\n\n    l, r = max(weights), sum(weights)\n    while l < r:\n        capacity = (l + r) // 2\n        if days_needed(capacity) <= days:\n            r = capacity\n        else:\n            l = capacity + 1\n    return l",
    "file_path": "backend/algorithms/problems/1011-capacity-to-ship-packages-within-d-days/solution.py",
    "intuition": "- Binary searching the answer space, (the ship's capacity)\n    - The range of possible capacities is from `max(weights)` to `sum(weights)`.\n    - The problem has a **monotonic property** ideal for binary search. The function `daysNeeded(capacity)` is monotonically non-increasing: as `capacity` grows, the days required can only decrease or stay the same.\n    - This creates a predictable `\\[False, ..., False, True, ..., True\\]` sequence for our condition, `daysNeeded(capacity) <= days`. The goal is to find the leftmost `True`, which represents the minimal valid capacity.\n        - If `daysNeeded(capacity) <= days` is `True`, then `capacity` is a potential answer, and we try for a better (smaller) one in the left half by setting `r = capacity`.\n        - If it is `False`, then `capacity` is too small, and we must search for a larger capacity in the right half by setting `l = capacity + 1`.",
    "kind": "function",
    "label": "def capacity_to_ship_packages_within_d_days(weights: list[int], days: int) -> int",
    "name": "capacity_to_ship_packages_within_d_days",
    "returns": {
      "label": "int"
    }
  },
  "problems.102-binary-tree-level-order-traversal.solution:Solution.levelOrder": {
    "args": [
      "root"
    ],
    "code": "    def levelOrder(self, root: TreeNode | None) -> list[list[int]]:\n        if not root:\n            return []\n        q, result = deque([root]), []\n        while q:\n            level = []\n            for _ in range(len(q)):\n                u = q.popleft()\n                level.append(u.val)\n                if u.left:\n                    q.append(u.left)\n                if u.right:\n                    q.append(u.right)\n            result.append(level)\n        return result",
    "file_path": "backend/algorithms/problems/102-binary-tree-level-order-traversal/solution.py",
    "intuition": "- The core logic hinges on the inner `for` loop\n    - The expression `len(queue)` takes a \"snapshot\" of the number of nodes on the current level before the loop begins. The loop then dequeues and processes exactly that many nodes, ensuring that only nodes from the current level are handled while their children are queued up for the next iteration. This technique is the key to cleanly separating the levels.",
    "kind": "method",
    "label": "def levelOrder(self, root: TreeNode | None) -> list[list[int]]",
    "name": "levelOrder",
    "returns": {
      "label": "list[list[int]]",
      "summary": "List of lists, where each inner list contains values of nodes at the same level"
    },
    "time_complexity": "O(n)\nwhere n is the total number of nodes in the tree. This is optimal as every node must be visited once."
  },
  "problems.102-binary-tree-level-order-traversal.solution:Solution.levelOrder.root": {
    "kind": "parameter",
    "label": "root: TreeNode | None",
    "name": "root",
    "summary": "Root node of the binary tree"
  },
  "problems.121-best-time-to-buy-and-sell-stock.solution:best_time_to_buy_and_sell_stock": {
    "args": [
      "prices"
    ],
    "code": "def best_time_to_buy_and_sell_stock(prices: list[int]) -> int:\n    cost, profit = float(\"inf\"), 0\n    for price in prices:\n        cost = min(cost, price)\n        profit = max(profit, price - cost)\n    return profit",
    "file_path": "backend/algorithms/problems/121-best-time-to-buy-and-sell-stock/solution.py",
    "kind": "function",
    "label": "def best_time_to_buy_and_sell_stock(prices: list[int]) -> int",
    "name": "best_time_to_buy_and_sell_stock",
    "returns": {
      "label": "int",
      "summary": "Maximum profit from buying and selling stock"
    },
    "time_complexity": "O(n)\nwhere n is the length of the prices array. We iterate through the array once."
  },
  "problems.121-best-time-to-buy-and-sell-stock.solution:best_time_to_buy_and_sell_stock.prices": {
    "kind": "parameter",
    "label": "prices: list[int]",
    "name": "prices",
    "summary": "List of stock prices"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.dp:best_time_to_buy_and_sell_stock_III": {
    "args": [
      "prices"
    ],
    "code": "def best_time_to_buy_and_sell_stock_III(prices: list[int]) -> int:\n\n    t1_cost = t2_cost = float(\"inf\")\n    t1_profit = t2_profit = 0\n\n    for p in prices:\n\n        t1_cost = min(t1_cost, p) \n        t1_profit = max(t1_profit, p - t1_cost)\n\n        t2_cost = min(t2_cost, p - t1_profit)\n        t2_profit = max(t2_profit, p - t2_cost)\n\n    return t2_profit",
    "expressions": {
      "p - t1_profit": "money you'd need now if earlier profit covered part of this buy"
    },
    "file_path": "backend/algorithms/problems/123-best-time-to-buy-and-sell-stock-iii/dp.py",
    "intuition": "- Cost profit tracking\n    - Track the cost and profit for two separate trades, using the profit from the first trade to reduce the cost of the second trade.",
    "kind": "function",
    "label": "def best_time_to_buy_and_sell_stock_III(prices: list[int]) -> int",
    "name": "best_time_to_buy_and_sell_stock_III",
    "returns": {
      "label": "int",
      "summary": "Maximum profit from at most two transactions"
    },
    "time_complexity": "O(n)\nwhere n is the length of the prices array. We iterate through the array once.",
    "variables": [
      "t1_cost",
      "t1_profit",
      "t2_cost",
      "t2_profit"
    ]
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.dp:best_time_to_buy_and_sell_stock_III.p - t1_profit": {
    "kind": "expression",
    "name": "p - t1_profit",
    "summary": "money you'd need now if earlier profit covered part of this buy"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.dp:best_time_to_buy_and_sell_stock_III.prices": {
    "kind": "parameter",
    "label": "prices: list[int]",
    "name": "prices",
    "summary": "List of stock prices"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.dp:best_time_to_buy_and_sell_stock_III.t1_cost": {
    "kind": "variable",
    "name": "t1_cost",
    "summary": "cost of first trade"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.dp:best_time_to_buy_and_sell_stock_III.t1_profit": {
    "kind": "variable",
    "name": "t1_profit",
    "summary": "profit of first trade"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.dp:best_time_to_buy_and_sell_stock_III.t2_cost": {
    "kind": "variable",
    "name": "t2_cost",
    "summary": "cost of second trade"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.dp:best_time_to_buy_and_sell_stock_III.t2_profit": {
    "kind": "variable",
    "name": "t2_profit",
    "summary": "profit of second trade"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.state:best_time_to_buy_and_sell_stock_III": {
    "args": [
      "prices"
    ],
    "code": "def best_time_to_buy_and_sell_stock_III(prices: list[int]) -> int:\n    hold1 = hold2 = float(\"-inf\")\n    sell1 = sell2 = 0\n\n    for p in prices:\n        hold1 = max(hold1, -p)\n        sell1 = max(sell1, hold1 + p)\n        hold2 = max(hold2, sell1 - p)\n        sell2 = max(sell2, hold2 + p)\n    return sell2",
    "expressions": {
      "hold1 = hold2 = float(\"-inf\")": "money you'd have if holding first stock",
      "hold1 = max(hold1, -p)": "buy first stock",
      "hold2 = max(hold2, sell1 - p)": "buy second stock",
      "sell1 = max(sell1, hold1 + p)": "sell first stock",
      "sell1 = sell2 = 0": "money you'd have if not holding first stock",
      "sell2 = max(sell2, hold2 + p)": "sell second stock"
    },
    "file_path": "backend/algorithms/problems/123-best-time-to-buy-and-sell-stock-iii/state.py",
    "intuition": "hold sell states",
    "kind": "function",
    "label": "def best_time_to_buy_and_sell_stock_III(prices: list[int]) -> int",
    "name": "best_time_to_buy_and_sell_stock_III",
    "returns": {
      "label": "int"
    }
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.state:best_time_to_buy_and_sell_stock_III.hold1 = hold2 = float(\"-inf\")": {
    "kind": "expression",
    "name": "hold1 = hold2 = float(\"-inf\")",
    "summary": "money you'd have if holding first stock"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.state:best_time_to_buy_and_sell_stock_III.hold1 = max(hold1, -p)": {
    "kind": "expression",
    "name": "hold1 = max(hold1, -p)",
    "summary": "buy first stock"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.state:best_time_to_buy_and_sell_stock_III.hold2 = max(hold2, sell1 - p)": {
    "kind": "expression",
    "name": "hold2 = max(hold2, sell1 - p)",
    "summary": "buy second stock"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.state:best_time_to_buy_and_sell_stock_III.sell1 = max(sell1, hold1 + p)": {
    "kind": "expression",
    "name": "sell1 = max(sell1, hold1 + p)",
    "summary": "sell first stock"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.state:best_time_to_buy_and_sell_stock_III.sell1 = sell2 = 0": {
    "kind": "expression",
    "name": "sell1 = sell2 = 0",
    "summary": "money you'd have if not holding first stock"
  },
  "problems.123-best-time-to-buy-and-sell-stock-iii.state:best_time_to_buy_and_sell_stock_III.sell2 = max(sell2, hold2 + p)": {
    "kind": "expression",
    "name": "sell2 = max(sell2, hold2 + p)",
    "summary": "sell second stock"
  },
  "problems.1235-maximum-profit-in-job-scheduling.top_down:maximum_profit_in_job_scheduling": {
    "args": [
      "endTime",
      "startTime",
      "profit"
    ],
    "code": "def maximum_profit_in_job_scheduling(\n    startTime: list[int], endTime: list[int], profit: list[int]\n) -> int:\n\n    jobs = sorted(zip(startTime, endTime, profit))\n    memo = {}\n\n    def dp(i: int) -> int:\n        if i == len(jobs):\n            return 0\n        if i not in memo:\n            _, e, p = jobs[i]\n            memo[i] = max(dp(i + 1), p + dp(bisect_left(jobs, e, key=lambda x: x[0])))\n        return memo[i]\n\n    return dp(0)",
    "expressions": {
      "bisect_left(jobs, e, key=lambda x: x[0]))": "Find the index of the first job whose start time is greater than or equal to the end time `e` of this job",
      "dp(i + 1)": "Skip this job and move to the next one",
      "p + dp(": "Take this job and move accordingly",
      "sorted(zip(startTime, endTime, profit))": "pack and sort by start so we can jump to the next non-overlapping job"
    },
    "file_path": "backend/algorithms/problems/1235-maximum-profit-in-job-scheduling/top_down.py",
    "kind": "function",
    "label": "def maximum_profit_in_job_scheduling(startTime: list[int], endTime: list[int], profit: list[int]) -> int",
    "name": "maximum_profit_in_job_scheduling",
    "returns": {
      "label": "int"
    },
    "variables": [
      "memo",
      "Time complexity",
      "O(n log n)"
    ]
  },
  "problems.1235-maximum-profit-in-job-scheduling.top_down:maximum_profit_in_job_scheduling.O(n log n)": {
    "kind": "variable",
    "name": "O(n log n)",
    "summary": ""
  },
  "problems.1235-maximum-profit-in-job-scheduling.top_down:maximum_profit_in_job_scheduling.Time complexity": {
    "kind": "variable",
    "name": "Time complexity",
    "summary": ""
  },
  "problems.1235-maximum-profit-in-job-scheduling.top_down:maximum_profit_in_job_scheduling.bisect_left(jobs, e, key=lambda x: x[0]))": {
    "kind": "expression",
    "name": "bisect_left(jobs, e, key=lambda x: x[0]))",
    "summary": "Find the index of the first job whose start time is greater than or equal to the end time `e` of this job"
  },
  "problems.1235-maximum-profit-in-job-scheduling.top_down:maximum_profit_in_job_scheduling.dp(i + 1)": {
    "kind": "expression",
    "name": "dp(i + 1)",
    "summary": "Skip this job and move to the next one"
  },
  "problems.1235-maximum-profit-in-job-scheduling.top_down:maximum_profit_in_job_scheduling.memo": {
    "kind": "variable",
    "name": "memo",
    "summary": "memo[i] = max profit starting from job i"
  },
  "problems.1235-maximum-profit-in-job-scheduling.top_down:maximum_profit_in_job_scheduling.p + dp(": {
    "kind": "expression",
    "name": "p + dp(",
    "summary": "Take this job and move accordingly"
  },
  "problems.1235-maximum-profit-in-job-scheduling.top_down:maximum_profit_in_job_scheduling.sorted(zip(startTime, endTime, profit))": {
    "kind": "expression",
    "name": "sorted(zip(startTime, endTime, profit))",
    "summary": "pack and sort by start so we can jump to the next non-overlapping job"
  },
  "problems.124-binary-tree-maximum-path-sum.solution:binary_tree_maximum_path_sum.dfs": {
    "args": [
      "node"
    ],
    "code": "    def dfs(node):\n        nonlocal best\n        if not node:\n            return 0\n        l = max(dfs(node.left), 0)\n        r = max(dfs(node.right), 0)\n        best = max(best, node.val + l + r)\n        return node.val + max(l, r)",
    "expressions": {
      "best = max(best, node.val + l + r)": "path through node",
      "return node.val + max(l, r)": "best upward gain"
    },
    "file_path": "backend/algorithms/problems/124-binary-tree-maximum-path-sum/solution.py",
    "kind": "function",
    "label": "def dfs(node)",
    "name": "dfs",
    "variables": [
      "l",
      "r"
    ]
  },
  "problems.124-binary-tree-maximum-path-sum.solution:binary_tree_maximum_path_sum.dfs.best = max(best, node.val + l + r)": {
    "kind": "expression",
    "name": "best = max(best, node.val + l + r)",
    "summary": "path through node"
  },
  "problems.124-binary-tree-maximum-path-sum.solution:binary_tree_maximum_path_sum.dfs.l": {
    "kind": "variable",
    "name": "l",
    "summary": "left gain"
  },
  "problems.124-binary-tree-maximum-path-sum.solution:binary_tree_maximum_path_sum.dfs.r": {
    "kind": "variable",
    "name": "r",
    "summary": "right gain"
  },
  "problems.124-binary-tree-maximum-path-sum.solution:binary_tree_maximum_path_sum.dfs.return node.val + max(l, r)": {
    "kind": "expression",
    "name": "return node.val + max(l, r)",
    "summary": "best upward gain"
  },
  "problems.127-word-ladder.solution:word_ladder": {
    "args": [
      "beginWord",
      "endWord",
      "wordList"
    ],
    "code": "def word_ladder(beginWord: str, endWord: str, wordList: list[str]) -> int:\n    if endWord not in wordList:\n        return 0\n\n    L = len(beginWord)\n    combos: dict[str, list[str]] = defaultdict(list)\n    for w in wordList:\n        for i in range(L):\n            combos[w[:i] + \"*\" + w[i+1:]].append(w)\n\n    front, back = {beginWord}, {endWord}\n    dist_front, dist_back = {beginWord: 1}, {endWord: 1}\n\n    while front and back:\n        if len(front) > len(back):\n            front, back = back, front\n            dist_front, dist_back = dist_back, dist_front\n\n        next_front = set()\n        for word in front:\n            for i in range(L):\n                for n in combos[word[:i] + \"*\" + word[i+1:]]:\n                    if n in dist_back:\n                        return dist_front[word] + dist_back[n]\n                    if n not in dist_front:\n                        dist_front[n] = dist_front[word] + 1\n                        next_front.add(n)\n        front = next_front\n\n    return 0",
    "file_path": "backend/algorithms/problems/127-word-ladder/solution.py",
    "intuition": "- Bidirectional BFS Meets in the Middle 🤝:\n    - This solution uses two  optimizations. First, it **pre-computes all possible generic transformations** (e.g., `h*t`) in a dictionary, allowing for instant lookups of neighboring words instead of generating them on the fly. Second, it performs a **bidirectional BFS**, launching one search from the `beginWord` and another from the `endWord`. By always expanding the smaller of the two frontiers, it drastically reduces the search space. The algorithm finishes when the two searches meet, at which point the shortest path is found.",
    "kind": "function",
    "label": "def word_ladder(beginWord: str, endWord: str, wordList: list[str]) -> int",
    "name": "word_ladder",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(N * L)\nwhere N is the number of words and L is the length of each word. The dominant operation is the initial pre-computation step to build the `combos` dictionary. The subsequent bidirectional search is typically much faster than this initial setup."
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.a_star:manhattan_distance": {
    "args": [
      "a",
      "b"
    ],
    "code": "def manhattan_distance(a: tuple[int, int], b: tuple[int, int]) -> int:\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])",
    "file_path": "backend/algorithms/problems/1293-shortest-path-in-a-grid-with-obstacles-elimination/a_star.py",
    "kind": "function",
    "label": "def manhattan_distance(a: tuple[int, int], b: tuple[int, int]) -> int",
    "name": "manhattan_distance",
    "returns": {
      "label": "int"
    },
    "summary": "Calculate Manhattan distance between two points."
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.a_star:shortest_path_in_a_grid_with_obstacles_elimination": {
    "args": [
      "k",
      "grid"
    ],
    "code": "def shortest_path_in_a_grid_with_obstacles_elimination(grid: list[list[int]], k: int) -> int:\n\n    rows, cols = len(grid), len(grid[0])\n\n    def h(r: int, c: int) -> int:\n        return manhattan_distance((r, c), (rows - 1, cols - 1))\n\n    if k >= (md:= h(0, 0)) - 1:\n        return md\n\n    pq = [(md, 0, 0, 0, k)]\n\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n\n    while pq:\n        _, steps, r, c, remaining_k = heapq.heappop(pq)\n\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n\n        if remaining_k < max_k[r][c]:\n            continue\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if 0 <= (nr:= r + dr) < rows and 0 <= (nc:= c + dc) < cols:\n                if (new_remaining_k := remaining_k - grid[nr][nc] ) > max_k[nr][nc]:\n                    max_k[nr][nc] = new_remaining_k\n                    heapq.heappush(pq, ((steps + 1) + h(nr, nc), steps + 1, nr, nc, new_remaining_k))\n\n    return -1",
    "expressions": {
      "if remaining_k < max_k[r][c]": "Handle items that are already outdated by the time they are popped.",
      "new_remaining_k": "= remaining_k - grid[nr][nc], how many obstacle eliminations you will have left **after** moving to the next cell , if the cell is empty grid[nr][nc] is 0, if the cell is an obstacle grid[nr][nc] is 1."
    },
    "file_path": "backend/algorithms/problems/1293-shortest-path-in-a-grid-with-obstacles-elimination/a_star.py",
    "kind": "function",
    "label": "def shortest_path_in_a_grid_with_obstacles_elimination(grid: list[list[int]], k: int) -> int",
    "name": "shortest_path_in_a_grid_with_obstacles_elimination",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(m * n * k * log(m * n * k))",
    "topics": [
      "a-star"
    ],
    "variables": [
      "pq"
    ]
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.a_star:shortest_path_in_a_grid_with_obstacles_elimination.if remaining_k < max_k[r][c]": {
    "kind": "expression",
    "name": "if remaining_k < max_k[r][c]",
    "summary": "Handle items that are already outdated by the time they are popped."
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.a_star:shortest_path_in_a_grid_with_obstacles_elimination.new_remaining_k": {
    "kind": "expression",
    "name": "new_remaining_k",
    "summary": "= remaining_k - grid[nr][nc], how many obstacle eliminations you will have left **after** moving to the next cell , if the cell is empty grid[nr][nc] is 0, if the cell is an obstacle grid[nr][nc] is 1."
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.a_star:shortest_path_in_a_grid_with_obstacles_elimination.pq": {
    "kind": "variable",
    "name": "pq",
    "summary": "(f_cost, steps, r, c, remaining_k)"
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.bfs:shortest_path_in_a_grid_with_obstacles_elimination": {
    "args": [
      "k",
      "grid"
    ],
    "code": "def shortest_path_in_a_grid_with_obstacles_elimination(grid: list[list[int]], k: int) -> int:\n\n    rows, cols = len(grid), len(grid[0])\n    min_steps = rows + cols - 3 \n    if k >= min_steps:\n        return min_steps\n\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n\n    q = deque([(0, 0, 0, k)])\n\n    while q:\n        r, c, steps, remaining_k = q.popleft()\n        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                new_remaining_k = remaining_k - grid[nr][nc]\n                if new_remaining_k > max_k[nr][nc]:\n                    if (nr, nc) == (rows - 1, cols - 1):\n                        return steps + 1\n                    max_k[nr][nc] = new_remaining_k\n                    q.append((nr, nc, steps + 1, new_remaining_k))\n    return -1",
    "file_path": "backend/algorithms/problems/1293-shortest-path-in-a-grid-with-obstacles-elimination/bfs.py",
    "intuition": "- bfs with State-Budget Pruning 🔍:\n    - The core idea is to perform a standard BFS over `(row, col, steps, remaining_k)` states, but only enqueue a move if it arrives at a cell with **strictly more** `remaining_k` than any prior visit. This pruning significantly reduces the number of states explored, making the algorithm much more efficient.\n    - **Trivial shortcut:** If `k ≥ rows+cols–2`, you can go straight in `rows+cols–2` steps without ever touching an obstacle.\n    - **Correctness guarantee:** Because BFS explores in order of increasing `steps`, the first time you dequeue the goal is the fewest-step path. Pruning by `remaining_k` never discards any shorter-step route—it simply avoids re-exploring dominated states.",
    "kind": "function",
    "label": "def shortest_path_in_a_grid_with_obstacles_elimination(grid: list[list[int]], k: int) -> int",
    "name": "shortest_path_in_a_grid_with_obstacles_elimination",
    "returns": {
      "label": "int"
    },
    "space_complexity": "O(m * n):\nfor the `max_k` grid plus up to O(m * n * k) queued states in the pathological worst case.",
    "summary": "Warning:\n    In practice, A* Search O(m * n * k * log(m * n * k)) is faster than this O(m * n * k) .",
    "time_complexity": "O(m * n * k):\nWorst-case O(m * n * k) (every cell × every possible k), but aggressive pruning usually makes it far faster in practice.",
    "variables": [
      "max_k",
      "q",
      "min_steps"
    ]
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.bfs:shortest_path_in_a_grid_with_obstacles_elimination.max_k": {
    "kind": "variable",
    "name": "max_k",
    "summary": "max_k[r][c] = maximum eliminations remaining when visiting (r,c)"
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.bfs:shortest_path_in_a_grid_with_obstacles_elimination.min_steps": {
    "kind": "variable",
    "name": "min_steps",
    "summary": "Manhattan distance lower bound"
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.bfs:shortest_path_in_a_grid_with_obstacles_elimination.q": {
    "kind": "variable",
    "name": "q",
    "summary": "(row, col, steps, remaining_k)"
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.dijkstra:shortest_path_in_a_grid_with_obstacles_elimination": {
    "args": [
      "k",
      "grid"
    ],
    "code": "def shortest_path_in_a_grid_with_obstacles_elimination(grid: list[list[int]], k: int) -> int:\n\n    rows, cols = len(grid), len(grid[0])\n    if k >= rows + cols - 3:\n        return rows + cols - 2\n\n    pq = [(0, 0, 0, k)]\n\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n\n    while pq:\n\n        steps, r, c, k_rem = heapq.heappop(pq)\n\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n\n        if k_rem < max_k[r][c]:\n            continue\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if 0 <= (nr:= r + dr) < rows and 0 <= (nc:= c + dc) < cols:\n                if (new_k:= k_rem - grid[nr][nc]) > max_k[nr][nc]:\n                    max_k[nr][nc] = new_k\n                    heapq.heappush(pq, (steps + 1, nr, nc, new_k))\n\n    return -1",
    "expressions": {
      "heapq.heappop(pq)": "Pop the path with the lowest g_cost (steps) so far",
      "heapq.heappush(pq, (steps + 1, nr, nc, new_k))": "The priority is simply the new step count.No heuristic is added, which is the only difference from the A* implementation.",
      "k_rem < max_k[r][c]": "Prune paths that are suboptimal for a given cell"
    },
    "file_path": "backend/algorithms/problems/1293-shortest-path-in-a-grid-with-obstacles-elimination/dijkstra.py",
    "kind": "function",
    "label": "def shortest_path_in_a_grid_with_obstacles_elimination(grid: list[list[int]], k: int) -> int",
    "name": "shortest_path_in_a_grid_with_obstacles_elimination",
    "returns": {
      "label": "int"
    },
    "summary": "Warning:\n This is less efficient than A* for this problem.",
    "variables": [
      "pq",
      "steps",
      "max_k"
    ]
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.dijkstra:shortest_path_in_a_grid_with_obstacles_elimination.heapq.heappop(pq)": {
    "kind": "expression",
    "name": "heapq.heappop(pq)",
    "summary": "Pop the path with the lowest g_cost (steps) so far"
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.dijkstra:shortest_path_in_a_grid_with_obstacles_elimination.heapq.heappush(pq, (steps + 1, nr, nc, new_k))": {
    "kind": "expression",
    "name": "heapq.heappush(pq, (steps + 1, nr, nc, new_k))",
    "summary": "The priority is simply the new step count.No heuristic is added, which is the only difference from the A* implementation."
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.dijkstra:shortest_path_in_a_grid_with_obstacles_elimination.k_rem < max_k[r][c]": {
    "kind": "expression",
    "name": "k_rem < max_k[r][c]",
    "summary": "Prune paths that are suboptimal for a given cell"
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.dijkstra:shortest_path_in_a_grid_with_obstacles_elimination.max_k": {
    "kind": "variable",
    "name": "max_k",
    "summary": "max_k[r][c] stores the max eliminations we have at cell (r,c)"
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.dijkstra:shortest_path_in_a_grid_with_obstacles_elimination.pq": {
    "kind": "variable",
    "name": "pq",
    "summary": "(g_cost, r, c, k_rem), The priority uses g_cost (steps) itself. No heuristic is used."
  },
  "problems.1293-shortest-path-in-a-grid-with-obstacles-elimination.dijkstra:shortest_path_in_a_grid_with_obstacles_elimination.steps": {
    "kind": "variable",
    "name": "steps",
    "summary": "The number of steps taken so far (g_cost)"
  },
  "problems.133-clone-graph.solution:clone_graph": {
    "args": [
      "node"
    ],
    "code": "def clone_graph(node: Node | None) -> Node | None:\n    if not node:\n        return None\n    cloned = {node: Node(node.val)}\n    queue = deque([node])\n    while queue:\n        cur = queue.popleft()\n        for n in cur.neighbors:\n            if n not in cloned:\n                cloned[n] = Node(n.val)\n                queue.append(n)\n            cloned[cur].neighbors.append(cloned[n])\n    return cloned[node]",
    "expressions": {
      "cloned[cur].neighbors.append(cloned[n])": "Add the neighbor to the current node's neighbors",
      "cloned[n] = Node(n.val)": "Create a new node for the neighbor",
      "if n not in cloned": "Check if the node has not been visited",
      "queue.append(n)": "Add the neighbor to the queue"
    },
    "file_path": "backend/algorithms/problems/133-clone-graph/solution.py",
    "intuition": "- Hash Map as a Visited Set & Node Cache 🗺️\n    - The key to traversing a potentially cyclic graph is a `visited` set. Here, the `cloned` dictionary serves a dual purpose. It acts as both a **`visited` set** (by checking `if n not in cloned`) and a **cache** that maps an original node to its clone. This ensures each node is cloned exactly once and prevents getting stuck in an infinite loop.",
    "kind": "function",
    "label": "def clone_graph(node: Node | None) -> Node | None",
    "name": "clone_graph",
    "returns": {
      "label": "Node | None",
      "summary": "The cloned graph"
    },
    "summary": "Clone a connected undirected graph using BFS traversal.",
    "time_complexity": "O(V + E)\nwhere V is the number of vertices (nodes) and E is the number of edges. This is optimal as we must visit every node and traverse every edge to create the full copy.",
    "variables": [
      "cloned",
      "queue",
      "cur",
      "n"
    ]
  },
  "problems.133-clone-graph.solution:clone_graph.cloned": {
    "kind": "variable",
    "name": "cloned",
    "summary": "A dictionary that maps an original node to its clone"
  },
  "problems.133-clone-graph.solution:clone_graph.cloned[cur].neighbors.append(cloned[n])": {
    "kind": "expression",
    "name": "cloned[cur].neighbors.append(cloned[n])",
    "summary": "Add the neighbor to the current node's neighbors"
  },
  "problems.133-clone-graph.solution:clone_graph.cloned[n] = Node(n.val)": {
    "kind": "expression",
    "name": "cloned[n] = Node(n.val)",
    "summary": "Create a new node for the neighbor"
  },
  "problems.133-clone-graph.solution:clone_graph.cur": {
    "kind": "variable",
    "name": "cur",
    "summary": "The current node being visited"
  },
  "problems.133-clone-graph.solution:clone_graph.if n not in cloned": {
    "kind": "expression",
    "name": "if n not in cloned",
    "summary": "Check if the node has not been visited"
  },
  "problems.133-clone-graph.solution:clone_graph.n": {
    "kind": "variable",
    "name": "n",
    "summary": "The neighbor of the current node"
  },
  "problems.133-clone-graph.solution:clone_graph.node": {
    "kind": "parameter",
    "label": "node: Node | None",
    "name": "node",
    "summary": "The node to clone"
  },
  "problems.133-clone-graph.solution:clone_graph.queue": {
    "kind": "variable",
    "name": "queue",
    "summary": "A queue that stores the nodes to be visited"
  },
  "problems.133-clone-graph.solution:clone_graph.queue.append(n)": {
    "kind": "expression",
    "name": "queue.append(n)",
    "summary": "Add the neighbor to the queue"
  },
  "problems.136-single-number.solution:singleNumber": {
    "args": [
      "nums"
    ],
    "code": "def singleNumber(nums: list[int]) -> int:\n    x = 0\n    for v in nums:\n        x ^= v\n    return x",
    "file_path": "backend/algorithms/problems/136-single-number/solution.py",
    "intuition": "- Using bitwise XOR to cancel out the duplicates:\n    - XOR cancels pairs (a^a=0, a^0=a; associative/commutative), so the lone element remains\n\n    - Deep Dive: XOR Reminder\n    - XOR properties:\n            - a ^ a = 0 (a number XOR itself is zero)\n            - a ^ 0 = a (a number XOR zero is itself)\n            - Commutative: a ^ b = b ^ a\n            - Associative: (a ^ b) ^ c = a ^ (b ^ c)\n        - Meaning:\n        - Because order and grouping don't matter, you can XOR all numbers in any sequence\n        - Cancellation:\n        - Each pair of identical numbers a ^ a becomes 0\n        - XORing by zero doesn't change the result\n        - Result:\n        - After all pairs cancel, only the unpaired (single) element remains\n    - Example:\n        - nums = [**[1!]4**, **[10!]1**, **[14!]2**, **[10!]1**, **[14!]2**]\n        - **[1!]4** ^ **[10!]1** ^ **[14!]2** ^ **[10!]1** ^ **[14!]2**\n        - **[10!](1 ^ 1)** ^ **[14!](2 ^ 2)** ^ **[1!]4**\n        - **[10!]0** ^ **[14!]0** ^ **[1!]4** = **[1!]4**",
    "kind": "function",
    "label": "def singleNumber(nums: list[int]) -> int",
    "name": "singleNumber",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n):\nwhere n is the number of elements in the nums array"
  },
  "problems.1406-stone-game-iii.solution:stone_game_III": {
    "args": [
      "stoneValue"
    ],
    "code": "def stone_game_III(stoneValue: list[int]) -> str:\n    memo, n = {}, len(stoneValue)\n    def dp(i):\n        if i >= n:\n            return 0\n        if i not in memo:\n            memo[i] = max(\n                sum(stoneValue[i : i + k]) - dp(i + k) for k in range(1, 4)\n            )\n        return memo[i]\n    return \"Alice\" if dp(0) > 0 else \"Bob\" if dp(0) < 0 else \"Tie\"",
    "file_path": "backend/algorithms/problems/1406-stone-game-iii/solution.py",
    "intuition": "- Score-difference DP:\n    - Let `dp[i]` = max score difference current player can achieve starting at index `i`.\n    - Transition: `dp[i] = max_{k∈{1,2,3}} (sum(i..i+k-1) − dp[i+k])`. Answer from `dp[0]`.",
    "kind": "function",
    "label": "def stone_game_III(stoneValue: list[int]) -> str",
    "name": "stone_game_III",
    "returns": {
      "label": "str"
    },
    "time_complexity": "O(n)\nconstant 3 choices per `i`"
  },
  "problems.146-lru-cache.solution:LRUCache": {
    "code": "class LRUCache:\n    def __init__(self, capacity: int):\n        self.cache: OrderedDict[int, int] = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if (val := self.cache.get(key)) is None:\n            return -1\n        self.cache.move_to_end(key)\n        return val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
    "file_path": "backend/algorithms/problems/146-lru-cache/solution.py",
    "intuition": "The LRU system is simple. It tracks *when* a book was last used.",
    "kind": "class",
    "name": "LRUCache"
  },
  "problems.146-lru-cache.solution:LRUCache.get": {
    "args": [
      "key"
    ],
    "code": "    def get(self, key: int) -> int:\n        if (val := self.cache.get(key)) is None:\n            return -1\n        self.cache.move_to_end(key)\n        return val",
    "file_path": "backend/algorithms/problems/146-lru-cache/solution.py",
    "kind": "method",
    "label": "def get(self, key: int) -> int",
    "name": "get",
    "returns": {
      "label": "int"
    },
    "summary": "When an item is accessed, it becomes the most recently used. We fetch the item and move it to the end of the `OrderedDict`."
  },
  "problems.146-lru-cache.solution:LRUCache.put": {
    "args": [
      "value",
      "key"
    ],
    "code": "    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
    "file_path": "backend/algorithms/problems/146-lru-cache/solution.py",
    "kind": "method",
    "label": "def put(self, key: int, value: int) -> None",
    "name": "put",
    "returns": {
      "label": "None"
    },
    "summary": "When an item is added or updated, it's also considered the most recently used and is moved to the end. If the cache exceeds its capacity, the item at the front of the OrderedDict (the least recently used) is removed."
  },
  "problems.15-3sum.solution:three_sum": {
    "args": [
      "a"
    ],
    "code": "def three_sum(a: list[int]) -> list[list[int]]:\n\n    a.sort()\n    out: list[list[int]] = []\n\n    for i, x in enumerate(a):\n        if i and x == a[i - 1]: continue\n        l, r = i + 1, len(a) - 1\n        while l < r:\n            s = x + a[l] + a[r]\n            if s < 0: l += 1\n            elif s > 0: r -= 1\n            else:\n                out.append([x, a[l], a[r]])\n                l += 1 ; r -= 1\n                while l < r and a[l] == a[l - 1]:\n                    l += 1\n    return out",
    "file_path": "backend/algorithms/problems/15-3sum/solution.py",
    "intuition": "- Sort the array and use two pointers to find the triplets:\n        - After sorting, each value `a[i]` becomes a fixed anchor\n        - We then need a pair `(l, r)` such that:\n            - `a[i] + a[l] + a[r] == 0`\n        - Because the array is sorted\n            - increasing `l` raises the sum\n            - decreasing `r` lowers it\n        - This turns the inner search into a classic two-pointer sweep\n\n    - Duplicate handling:\n        - Skip repeated anchors `i`.\n        - After finding one valid triplet, advance `l` past duplicates, because those pairs cannot form new distinct triplets.",
    "kind": "function",
    "label": "def three_sum(a: list[int]) -> list[list[int]]",
    "name": "three_sum",
    "returns": {
      "label": "list[list[int]]",
      "summary": "All unique triplets `[x, y, z]` with `x + y + z = 0`."
    },
    "time_complexity": "O(n ^ 2):\n    The outer loop runs `n` times, and for each anchor `i` the `(l, r)` pointers move at most `n` total steps, because each pointer only moves forward/backward and never resets → O(n²) overall."
  },
  "problems.1510-stone-game-iv.solution:stone_game_IV": {
    "args": [
      "n"
    ],
    "code": "def stone_game_IV(n: int) -> bool:\n\n    memo = {0: False}\n\n    def dp(n):\n        if n not in memo:\n            memo[n] = any(not dp(n - i**2) for i in range(int(n**0.5), 0, -1))\n        return memo[n]\n\n    return dp(n)",
    "file_path": "backend/algorithms/problems/1510-stone-game-iv/solution.py",
    "intuition": "- Minimax:\n    - *Paradigm*: This is a classic *impartial game* solved using the *Minimax* principle on game states.\n    - *Insight*: A position is defined as *winning* if you can make *any* move to a position that you know is *losing* for your opponent. The DP builds this win/loss classification for every number of stones up to `n`, starting from the base case that 0 stones is a losing position.",
    "kind": "function",
    "label": "def stone_game_IV(n: int) -> bool",
    "name": "stone_game_IV",
    "returns": {
      "label": "bool"
    },
    "time_complexity": "O(n * sqrt(n))\ntry all squares for each `x`"
  },
  "problems.1514-path-with-maximum-probability.bellman-ford:Solution.maxProbability": {
    "args": [
      "n",
      "succProb",
      "end",
      "edges",
      "start"
    ],
    "code": "    def maxProbability(self, n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float:\n        prob = [0.0] * n\n        prob[start] = 1.0\n\n        for _ in range(n - 1):\n            updated = False\n            for (u, v), p in zip(edges, succProb):\n                if prob[u] * p > prob[v]:\n                    prob[v] = prob[u] * p\n                    updated = True\n                if prob[v] * p > prob[u]:\n                    prob[u] = prob[v] * p\n                    updated = True\n            if not updated:\n                break\n\n        return prob[end]",
    "file_path": "backend/algorithms/problems/1514-path-with-maximum-probability/bellman-ford.py",
    "intuition": "- Bellman-Ford variant to maximize product of probabilities.\n    - Each node tracks the maximum probability to reach it from `start`.",
    "kind": "method",
    "label": "def maxProbability(self, n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float",
    "name": "maxProbability",
    "returns": {
      "label": "float"
    }
  },
  "problems.1514-path-with-maximum-probability.bellman-ford:Solution.maxProbability.edges": {
    "kind": "parameter",
    "label": "edges: list[list[int]]",
    "name": "edges",
    "summary": "edges[i] = [u, v] is an undirected edge connecting the nodes u and v with a probability of success of traversing that edge succProb[i]."
  },
  "problems.1514-path-with-maximum-probability.bellman-ford:Solution.maxProbability.n": {
    "kind": "parameter",
    "label": "n: int",
    "name": "n",
    "summary": "number of nodes"
  },
  "problems.1514-path-with-maximum-probability.bellman-ford:Solution.maxProbability.succProb": {
    "kind": "parameter",
    "label": "succProb: list[float]",
    "name": "succProb",
    "summary": "list of probabilities, e.g. [0.5,0.5,0.2],"
  },
  "problems.1514-path-with-maximum-probability.dijkstra:Solution.maxProbability": {
    "args": [
      "succProb",
      "start",
      "edges",
      "n",
      "end"
    ],
    "code": "    def maxProbability(self, n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float:\n\n        adj = defaultdict(list)\n        for (u, v), p in zip(edges, succProb):\n            adj[u].append((v, p))\n            adj[v].append((u, p))\n\n        pq, best = [(-1.0, start)], [0.0] * n\n        best[start] = 1.0\n\n        while pq:\n            p, u = heappop(pq)\n            p = -p\n            if u == end:\n                return p\n            if p < best[u]:\n                continue\n            for v, w in adj[u]:\n                new_p = p * w\n                if new_p > best[v]:\n                    best[v] = new_p\n                    heappush(pq, (-new_p, v))\n        return 0.0",
    "file_path": "backend/algorithms/problems/1514-path-with-maximum-probability/dijkstra.py",
    "intuition": "- We want the path from `start` to `end` with the largest product of edge probabilities:\n    - This is equivalent to Dijkstra’s algorithm, replacing *sum of distances* with             *product of probabilities* and switching from a *[2!]min-heap* to a *[2!]max-heap*.\n\n    - Deep Dive: Correctness:\n        - Each edge weight (probability) *$\\in [0, 1]$*.\n        - Multiplying by a value *$\\leq 1$* never increases the product, so the total probability                   along any path is monotonically non-increasing as the path length grows.\n        - This monotonicity guarantees that *once we extract a node with the current                   maximum probability from the heap, no later path can improve it.*\n            - same invariant that makes Dijkstra correct for nonnegative edge weights.\n            - By contrast, *longest path* problems fail this property because edge weights                 can be positive and cumulative, allowing cycles to increase total weight                 indefinitely (no monotonic bound), making them *NP-hard*.",
    "kind": "method",
    "label": "def maxProbability(self, n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float",
    "name": "maxProbability",
    "returns": {
      "label": "float",
      "summary": "Maximum probability to reach `end` from `start`, or 0.0 if unreachable."
    }
  },
  "problems.153-find-minimum-in-rotated-sorted-array.solution:find_minimum_in_rotated_sorted_array": {
    "args": [
      "nums"
    ],
    "code": "def find_minimum_in_rotated_sorted_array(nums: list[int]) -> int:\n\n    l, r = 0, len(nums) - 1\n    while l < r:\n        mid = (l + r) // 2\n        if nums[mid] < nums[r]:\n            r = mid\n        else:\n            l = mid + 1 \n    return nums[l]",
    "expressions": {
      "l = mid + 1": "the smallest is on the right",
      "r = mid": "If nums[mid] is less than nums[r], the minimum is in the left half (inclusive of mid)."
    },
    "file_path": "backend/algorithms/problems/153-find-minimum-in-rotated-sorted-array/solution.py",
    "intuition": "- The goal is to find the *inflection point* in the rotated list (where the numbers switch from high to low) — this point is the minimum element.\n    - We use a modified binary search to home in on this point.\n    - The key is comparing the middle element `nums[mid]` with the rightmost element `nums[r]`. This comparison tells us which part of the array is currently sorted and can be discarded.\n        - **Case 1: `nums[mid] < nums[r]`**\n            - **Example:** In `[4, 5, 1, 2, 3]`, if `mid` points to `1`, `nums[mid]` (`1`) is less than `nums[r]` (`3`).\n            - **Logic:** This indicates that the entire right portion of the array from `mid` to `r` (i.e., `[1, 2, 3]`) is sorted. The minimum element could be `nums[mid]` itself, or it could be to its left. We can safely search the left half (including `mid`) by setting `r = mid`.\n        - **Case 2: `nums[mid] >= nums[r]`**\n            - **Example:** In `[4, 5, 1, 2, 3]`, if `mid` points to `5` in an earlier step, `nums[mid]` (`5`) is greater than `nums[r]` (`3`).\n            - **Logic:** This indicates that the inflection point (the minimum value) must lie to the right of `mid`. The left portion `[4, 5]` is sorted but contains values larger than the true minimum. We discard this left portion by setting `l = mid + 1`.\n    - The loop terminates when `l` and `r` converge, at which point `nums[l]` is the smallest element.",
    "kind": "function",
    "label": "def find_minimum_in_rotated_sorted_array(nums: list[int]) -> int",
    "name": "find_minimum_in_rotated_sorted_array",
    "returns": {
      "label": "int"
    }
  },
  "problems.153-find-minimum-in-rotated-sorted-array.solution:find_minimum_in_rotated_sorted_array.l = mid + 1": {
    "kind": "expression",
    "name": "l = mid + 1",
    "summary": "the smallest is on the right"
  },
  "problems.153-find-minimum-in-rotated-sorted-array.solution:find_minimum_in_rotated_sorted_array.r = mid": {
    "kind": "expression",
    "name": "r = mid",
    "summary": "If nums[mid] is less than nums[r], the minimum is in the left half (inclusive of mid)."
  },
  "problems.1563-stone-game-v._solution:stone_game_v": {
    "args": [
      "stoneValue"
    ],
    "code": "def stone_game_v(stoneValue: list[int]) -> int:\n\n    pre = [s := 0] + [(s := s + v) for v in stoneValue]\n\n    memo = {}\n\n    def dp(i, j):\n\n        if (i, j) not in memo:\n\n            memo[(i, j)] = max(\n                (\n                    (\n                        l + dp(i, k)\n                        if (l := pre[k] - pre[i]) < (r := pre[j] - pre[k])\n                        else r + dp(k, j) if l > r else l + max(dp(i, k), dp(k, j))\n                    )\n                    for k in range(i + 1, j)\n                ),\n                default=0,\n            )\n\n        return memo[(i, j)]\n\n    return dp(0, len(stoneValue))",
    "file_path": "backend/algorithms/problems/1563-stone-game-v/_solution.py",
    "kind": "function",
    "label": "def stone_game_v(stoneValue: list[int]) -> int",
    "name": "stone_game_v",
    "returns": {
      "label": "int"
    },
    "summary": "Time Comlexity:\n    O(n^3)"
  },
  "problems.1563-stone-game-v.bottom-up:stone_game_v": {
    "args": [
      "a"
    ],
    "code": "def stone_game_v(a: list[int]) -> int:\n    n = len(a)\n    dp = [[0] * n for _ in range(n)]\n    mx = [[0] * n for _ in range(n)]\n    for i, v in enumerate(a):\n        mx[i][i] = v\n\n    for j in range(1, n):\n        mid = j\n        left = a[j]\n        right = 0\n        for i in range(j - 1, -1, -1):\n            left += a[i]\n\n            while (right + a[mid]) * 2 <= left:\n                right += a[mid]\n                mid -= 1\n\n            best = 0\n            if right * 2 == left:\n                best = mx[i][mid]\n            if mid != i:\n                best = max(best, mx[i][mid - 1])\n            if mid != j:\n                best = max(best, mx[j][mid + 1])\n\n            dp[i][j] = best\n            mx[i][j] = max(mx[i][j - 1], best + left)\n            mx[j][i] = max(mx[j][i + 1], best + left)\n\n    return dp[0][n - 1]",
    "file_path": "backend/algorithms/problems/1563-stone-game-v/bottom-up.py",
    "intuition": "- Split i..j into two parts; you can only keep the smaller-sum side,\n    - or either if equal. dp[i][j] = best score in a[i..j].\n    - mx[i][j] = best score + sum for a[i..j], to reuse quickly.\n\n    - Deep Dive:\n    - Each move divides the array into left and right parts. You can only continue with the side whose total sum is smaller; if equal, you may choose either. The goal is to maximize the total score gained from chosen parts.\n    - We iterate over all subarrays i..j, expanding outward and adjusting a pointer mid so that the right part stays as large as possible without exceeding half of the total. This ensures we check only balanced splits instead of every possible index.\n    - dp[i][j] stores the best score for i..j, while mx[i][j] caches the best “score + sum” prefix or suffix to quickly reuse.",
    "kind": "function",
    "label": "def stone_game_v(a: list[int]) -> int",
    "name": "stone_game_v",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n^2):\nBecause each subarray `i..j` is processed once and the middle pointer `mid` moves **monotonically** (never resets for a fixed `j`), every index is advanced at most O(1) times per outer loop.\nThus the total work is roughly proportional to the number of `(i, j)` pairs, giving **O(n²)** time and **O(n²)** space (for `dp` and `mx`)."
  },
  "problems.1590-make-sum-divisible-by-p.solution:minSubarrayToMakeSumDivisibleByP": {
    "args": [
      "p",
      "segments"
    ],
    "code": "def minSubarrayToMakeSumDivisibleByP(segments: list[int], p: int) -> int:\n\n    total_remainder = sum(segments) % p\n    if total_remainder == 0:\n        return 0\n\n    remainder_idx = {0: -1}\n    prefix_remainder, min_length = 0, len(segments)\n\n    for i, segment in enumerate(segments):\n        prefix_remainder = (prefix_remainder + segment) % p\n        need = (prefix_remainder - total_remainder + p) % p\n        if need in remainder_idx:\n            min_length = min(min_length, i - remainder_idx[need])\n        remainder_idx[prefix_remainder] = i\n\n    return min_length if min_length < len(segments) else -1",
    "file_path": "backend/algorithms/problems/1590-make-sum-divisible-by-p/solution.py",
    "kind": "function",
    "label": "def minSubarrayToMakeSumDivisibleByP(segments: list[int], p: int) -> int",
    "name": "minSubarrayToMakeSumDivisibleByP",
    "returns": {
      "label": "int",
      "summary": "The length of the shortest subarray to remove, or -1 if not possible."
    }
  },
  "problems.1590-make-sum-divisible-by-p.solution:minSubarrayToMakeSumDivisibleByP.p": {
    "kind": "parameter",
    "label": "p: int",
    "name": "p",
    "summary": "The divisor."
  },
  "problems.1590-make-sum-divisible-by-p.solution:minSubarrayToMakeSumDivisibleByP.segments": {
    "kind": "parameter",
    "label": "segments: list[int]",
    "name": "segments",
    "summary": "List of integers representing trip segments."
  },
  "problems.1631-path-with-minimum-effort.solution:path_with_minimum_effort": {
    "args": [
      "heights"
    ],
    "code": "def path_with_minimum_effort(heights: list[list[int]]) -> int:\n\n    R, C = len(heights), len(heights[0])\n    pq, resolved = [(0, 0, 0)], set()\n\n    while pq:\n        effort, r, c = heapq.heappop(pq)\n        if (r, c) in resolved: continue\n        if (r, c) == (R - 1, C - 1): return effort\n        resolved.add((r, c))\n\n        for nr, nc in [(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)]:\n            if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in resolved:\n                neighbor_effort = max(effort, abs(heights[nr][nc] - heights[r][c]))\n                heapq.heappush(pq, (neighbor_effort, nr, nc))",
    "file_path": "backend/algorithms/problems/1631-path-with-minimum-effort/solution.py",
    "kind": "function",
    "label": "def path_with_minimum_effort(heights: list[list[int]]) -> int",
    "name": "path_with_minimum_effort",
    "returns": {
      "label": "int",
      "summary": "minimum effort to reach the bottom-right cell"
    },
    "variables": [
      "pq",
      "resolved"
    ]
  },
  "problems.1631-path-with-minimum-effort.solution:path_with_minimum_effort.heights": {
    "kind": "parameter",
    "label": "heights: list[list[int]]",
    "name": "heights",
    "summary": "2D list of integers representing the heights of the cells"
  },
  "problems.1631-path-with-minimum-effort.solution:path_with_minimum_effort.pq": {
    "kind": "variable",
    "name": "pq",
    "summary": "Priority queue stores (max_effort_on_path, r, c)"
  },
  "problems.1631-path-with-minimum-effort.solution:path_with_minimum_effort.resolved": {
    "kind": "variable",
    "name": "resolved",
    "summary": "set to store the positions that have been resolved"
  },
  "problems.191-number-of-1-bits.bit_count:hammingWeight": {
    "args": [
      "n"
    ],
    "code": "def hammingWeight( n: int) -> int:\n    return n.bit_count()",
    "file_path": "backend/algorithms/problems/191-number-of-1-bits/bit_count.py",
    "kind": "function",
    "label": "def hammingWeight(n: int) -> int",
    "name": "hammingWeight",
    "returns": {
      "label": "int"
    },
    "summary": "Using built-in bit_count metho"
  },
  "problems.191-number-of-1-bits.brian-kernighan:hammingWeight": {
    "args": [
      "n"
    ],
    "code": "def hammingWeight(n: int) -> int:\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count",
    "file_path": "backend/algorithms/problems/191-number-of-1-bits/brian-kernighan.py",
    "intuition": "- Brian Kernighan's algorithm:\n    - counts the number of set bits (1s) in an integer efficiently by             repeatedly clearing the lowest set bit until the number becomes 0.\n\n    - Deep Dive: Why this always works\n    - When you subtract 1 from a binary number:\n            - You flip the lowest set bit (1) to 0\n            - And everything to the right of it flips to 1\n\n    - Example:\n    - Start\n        - ```python\n            - n = 13 (1101)\n            - count = 0\n        - ```\n    - Iteration 1\n        - ```python\n            - n   = 1101 (13)\n            - n-1 = 1100 (12)\n            - ---------------- &\n                  - 1100 (12)\n            - count = 1\n        - ```\n    - Iteration 2\n        - ```python\n            - n   = 1100 (12)\n            - n-1 = 1011 (11)\n            - ---------------- &\n                  - 1000 (8)\n            - count = 2\n        - ```\n    - Iteration 3\n        - ```python\n            - n   = 1000 (8)\n            - n-1 = 0111 (7)\n            - ---------------- &\n                  - 0000 (0)\n            - count = 3\n        - ```",
    "kind": "function",
    "label": "def hammingWeight(n: int) -> int",
    "name": "hammingWeight",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(k):\nwhere k = number of 1s (faster than looping 32 times)"
  },
  "problems.198-house-robber.bottom-up-prefix:rob": {
    "args": [
      "houses"
    ],
    "code": "def rob(houses: list[int]) -> int:\n    h1, h2 = 0, 0\n    for h in houses:\n        h2, h1 = h1, max(h1, h2 + h)\n    return h1",
    "expressions": {
      "h2, h1 = h1, max(h1, h2 + h)": "choose best between:\n        - skipping this house → keep h1 (dp(i-1))\n        - robbing this house → add h to h2 (dp(i-2) + h)"
    },
    "file_path": "backend/algorithms/problems/198-house-robber/bottom-up-prefix.py",
    "intuition": "- Deep Dive: Subproblems: dp(i) = maximum money obtainable robbing prefix `houses[0..i]\n    - for 0 ≤ i < n.  (*[14!]prefix ≙ starting from 0 until i*)\n\n    - Deep Dive: Relation: dp(i) = max(dp(i-1), houses[i] + dp(i-2))\n        - Either skip house `i` (best stays `dp(i-1)`)\n        - or rob it and skip `i-1` (best is `houses[i] + dp(i-2)`)\n\n    - Deep Dive: Topo. order: Increasing i\n        - Increasing i  (i = 0, 1, ..., n-1)\n\n    - Deep Dive: Base: dp(0)\n        - max money obtainable robbing the empty prefix `houses[0..0]`\n\n    - Deep Dive: Original: dp(n)\n        - maximum money obtainable robbing prefix `houses[0..n-1]` (the whole array)",
    "kind": "function",
    "label": "def rob(houses: list[int]) -> int",
    "name": "rob",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n):\n*Θ(n)* subproblems, *Θ(1)* work each → *Θ(n)* total",
    "variables": [
      "h1",
      "h2"
    ]
  },
  "problems.198-house-robber.bottom-up-prefix:rob.h1": {
    "kind": "variable",
    "name": "h1",
    "summary": "the best total so far (that is, dp(i-1), the best up to the previous house)."
  },
  "problems.198-house-robber.bottom-up-prefix:rob.h2": {
    "kind": "variable",
    "name": "h2",
    "summary": "the best total up to two houses ago (dp(i-2))."
  },
  "problems.198-house-robber.bottom-up-prefix:rob.h2, h1 = h1, max(h1, h2 + h)": {
    "kind": "expression",
    "name": "h2, h1 = h1, max(h1, h2 + h)",
    "summary": "choose best between:\n        - skipping this house → keep h1 (dp(i-1))\n        - robbing this house → add h to h2 (dp(i-2) + h)"
  },
  "problems.198-house-robber.bottom-up-suffix:rob": {
    "args": [
      "houses"
    ],
    "code": "def rob(houses: list[int]) -> int:\n    h1 = h2 = 0\n    for i in reversed(range(len(houses))):\n        h1, h2 = max(h1, houses[i] + h2), h1\n    return h1",
    "expressions": {
      "reversed(range(len(houses)))": "for i in range(len(houses) - 1, -1, -1)"
    },
    "file_path": "backend/algorithms/problems/198-house-robber/bottom-up-suffix.py",
    "kind": "function",
    "label": "def rob(houses: list[int]) -> int",
    "name": "rob",
    "returns": {
      "label": "int"
    }
  },
  "problems.198-house-robber.bottom-up-suffix:rob.reversed(range(len(houses)))": {
    "kind": "expression",
    "name": "reversed(range(len(houses)))",
    "summary": "for i in range(len(houses) - 1, -1, -1)"
  },
  "problems.198-house-robber.top-down-suffix:rob": {
    "args": [
      "houses"
    ],
    "code": "def rob(houses: list[int]) -> int:\n\n    memo = {}\n    def dp(i: int) -> int:\n        if i >= len(houses):\n            return 0\n        if i not in memo:\n            memo[i] = max(dp(i + 1), houses[i] + dp(i + 2))\n        return memo[i]\n\n    return dp(0)",
    "expressions": {
      "max(dp(i + 1), houses[i] + dp(i + 2))": "Either skip house `i` *[1!](best stays `dp(i+1)`)*\n        or rob it and skip `i+1` *[2!](best is `houses[i] + dp(i+2)`)*"
    },
    "file_path": "backend/algorithms/problems/198-house-robber/top-down-suffix.py",
    "intuition": "- Deep Dive: Subproblems: dp(i) = maximum money obtainable robbing **suffix** `houses[i..n-1]`,             for 0 ≤ i ≤ n.  (*[4!]suffix ≙ starting from i until the end*)\n\n    - Deep Dive: Relation: dp(i) = max(dp(i+1), houses[i] + dp(i+2))\n        - Either skip house `i` (best stays `dp(i+1)`)\n        - or rob it and skip `i+1` (best is `houses[i] + dp(i+2)`)\n\n    - Deep Dive: Topo. order: Decreasing i\n        - Subproblems `dp(i)` depend solely on strictly larger `i` so acyclic\n\n    - Deep Dive: Base: dp(n)\n        - max money obtainable robbing the empty suffix `houses[n..n]`\n\n    - Deep Dive: Original: dp(0)\n        - maximum money obtainable robbing suffix `houses[0..n-1]` (the whole array)",
    "kind": "function",
    "label": "def rob(houses: list[int]) -> int",
    "name": "rob",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n):\n*Θ(n)* subproblems, *Θ(1)* work each → *Θ(n)* total (with memoization)"
  },
  "problems.198-house-robber.top-down-suffix:rob.max(dp(i + 1), houses[i] + dp(i + 2))": {
    "kind": "expression",
    "name": "max(dp(i + 1), houses[i] + dp(i + 2))",
    "summary": "Either skip house `i` *[1!](best stays `dp(i+1)`)*\n        or rob it and skip `i+1` *[2!](best is `houses[i] + dp(i+2)`)*"
  },
  "problems.20-valid-parentheses.solution:isValid": {
    "args": [
      "s"
    ],
    "code": "def isValid(s: str) -> bool:\n    m, stack = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}, []\n    for b in s:\n        if b in m:\n            if not stack or m[b] != stack.pop():\n                return False\n        else:\n            stack.append(b)\n    return not stack",
    "file_path": "backend/algorithms/problems/20-valid-parentheses/solution.py",
    "kind": "function",
    "label": "def isValid(s: str) -> bool",
    "name": "isValid",
    "returns": {
      "label": "bool"
    },
    "time_complexity": "O(n)"
  },
  "problems.200-number-of-islands.bfs:Solution.numIslands": {
    "args": [
      "grid"
    ],
    "code": "    def numIslands(self, grid: list[list[str]]) -> int:\n        R, C = len(grid), len(grid[0])\n        islands, directions = 0, [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == \"1\":\n                    islands += 1\n                    grid[r][c] = \"0\"\n\n                    q = deque([(r, c)])\n                    while q:\n                        y, x = q.popleft()\n                        for dy, dx in directions:\n                            if 0 <= (i := y + dy) < R and 0 <= (j := x + dx) < C and grid[i][j] == \"1\":\n                                grid[i][j] = \"0\"\n                                q.append((i, j))\n\n        return islands",
    "file_path": "backend/algorithms/problems/200-number-of-islands/bfs.py",
    "intuition": "- Find, Count, and Sink 🏝️\n    - The strategy is to scan every cell of the grid. If an unvisited piece of land (`1`) is found, you've discovered a new island, so you increment the `islands` counter. Then, immediately launch a BFS from that cell to find and \"sink\" all connected parts of that same island by changing their value to `0`. This modification of the grid ensures each island group is counted exactly once.",
    "kind": "method",
    "label": "def numIslands(self, grid: list[list[str]]) -> int",
    "name": "numIslands",
    "returns": {
      "label": "int",
      "summary": "Number of islands in the grid"
    },
    "time_complexity": "O(R * C)\nwhere R and C are the dimensions of the grid. This is optimal as each cell is visited a constant number of times."
  },
  "problems.200-number-of-islands.bfs:Solution.numIslands.grid": {
    "kind": "parameter",
    "label": "grid: list[list[str]]",
    "name": "grid",
    "summary": "2D grid with '1' representing land and '0' representing water"
  },
  "problems.207-course-schedule.solution:Solution.canFinish": {
    "args": [
      "n",
      "prerequisites"
    ],
    "code": "    def canFinish(self, n: int, prerequisites: list[list[int]]) -> bool:\n        g = [[] for _ in range(n)]     \n        indeg = [0] * n                \n        for a, b in prerequisites:\n            g[b].append(a)             \n            indeg[a] += 1              \n\n        q = deque(i for i, d in enumerate(indeg) if d == 0)\n        taken = 0                      \n\n        while q:\n            u = q.popleft()             \n            taken += 1\n            for v in g[u]:              \n                indeg[v] -= 1           \n                if indeg[v] == 0:       \n                    q.append(v)         \n\n        return taken == n",
    "expressions": {
      "deque(i for i, d in enumerate(indeg) if d == 0)": "Initialize queue with all courses having no prerequisites",
      "for v in g[u]": "for each course unlocked by u",
      "g[b].append(a)": "add edge `b → a`",
      "if indeg[v] == 0": "if no prereqs left",
      "indeg[a] += 1": "a has one more incoming edge",
      "indeg[v] -= 1": "one prerequisite is now satisfied",
      "q.append(v)": "course is now ready to take",
      "taken += 1": "increment the counter for how many courses we've \"completed\"",
      "taken == n": "If we managed to take all n courses, there was no cycle",
      "u = q.popleft()": "take a course with no remaining prereqs",
      "while q": "Process courses in BFS order"
    },
    "file_path": "backend/algorithms/problems/207-course-schedule/solution.py",
    "intuition": "1. **Model**\n    - Each course = a node.\n    - Each prerequisite `[a, b]` = a directed edge `b → a` (“b before a”).\n\n    2. **Goal**\n    - Can we take all courses = does the graph have **no cycle**?\n    - If a cycle exists, you’ll never get a course with indegree 0 again.\n\n    3. **Idea (Kahn’s algorithm)**\n    - Compute **indegree** for each node (how many prereqs it has)\n    - Put all nodes with indegree 0 into a queue (they’re ready)\n    - While queue not empty:\n        - Pop one → mark as taken\n        - For each neighbor (course unlocked by it), decrement indegree\n        - If indegree becomes 0 → enqueue it\n    - If you’ve taken all courses → no cycle → return True\n    - Otherwise → cycle → return False",
    "kind": "method",
    "label": "def canFinish(self, n: int, prerequisites: list[list[int]]) -> bool",
    "name": "canFinish",
    "returns": {
      "label": "bool"
    },
    "summary": "Determine if all courses can be completed using Kahn’s algorithm (BFS topological sort).",
    "variables": [
      "taken",
      "g",
      "indeg"
    ]
  },
  "problems.207-course-schedule.solution:Solution.canFinish.deque(i for i, d in enumerate(indeg) if d == 0)": {
    "kind": "expression",
    "name": "deque(i for i, d in enumerate(indeg) if d == 0)",
    "summary": "Initialize queue with all courses having no prerequisites"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.for v in g[u]": {
    "kind": "expression",
    "name": "for v in g[u]",
    "summary": "for each course unlocked by u"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.g": {
    "kind": "variable",
    "name": "g",
    "summary": "`g[b]` = list of courses unlocked by taking `b`"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.g[b].append(a)": {
    "kind": "expression",
    "name": "g[b].append(a)",
    "summary": "add edge `b → a`"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.if indeg[v] == 0": {
    "kind": "expression",
    "name": "if indeg[v] == 0",
    "summary": "if no prereqs left"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.indeg": {
    "kind": "variable",
    "name": "indeg",
    "summary": "`indeg[a]` =  number of prerequisites left for course `a`"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.indeg[a] += 1": {
    "kind": "expression",
    "name": "indeg[a] += 1",
    "summary": "a has one more incoming edge"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.indeg[v] -= 1": {
    "kind": "expression",
    "name": "indeg[v] -= 1",
    "summary": "one prerequisite is now satisfied"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.prerequisites": {
    "kind": "parameter",
    "label": "prerequisites: list[list[int]]",
    "name": "prerequisites",
    "summary": "$prerequisites[i]=[a_i, b_i]$ indicates that you *must* take course *$b_i$* first before taking course $a_i$ *(b → a)*"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.q.append(v)": {
    "kind": "expression",
    "name": "q.append(v)",
    "summary": "course is now ready to take"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.taken": {
    "kind": "variable",
    "name": "taken",
    "summary": "counter for how many courses we've \"completed\""
  },
  "problems.207-course-schedule.solution:Solution.canFinish.taken += 1": {
    "kind": "expression",
    "name": "taken += 1",
    "summary": "increment the counter for how many courses we've \"completed\""
  },
  "problems.207-course-schedule.solution:Solution.canFinish.taken == n": {
    "kind": "expression",
    "name": "taken == n",
    "summary": "If we managed to take all n courses, there was no cycle"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.u = q.popleft()": {
    "kind": "expression",
    "name": "u = q.popleft()",
    "summary": "take a course with no remaining prereqs"
  },
  "problems.207-course-schedule.solution:Solution.canFinish.while q": {
    "kind": "expression",
    "name": "while q",
    "summary": "Process courses in BFS order"
  },
  "problems.208-implement-trie-prefix-tree.solution:Trie": {
    "code": "class Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children[ch]\n        node.end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if (node := node.children.get(ch)) is None:\n                return False\n        return node.end\n\n    def starts_with(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if (node := node.children.get(ch)) is None:\n                return False\n        return True",
    "file_path": "backend/algorithms/problems/208-implement-trie-prefix-tree/solution.py",
    "kind": "class",
    "name": "Trie",
    "summary": "Example:\n```markdown\n        [\"apple\", \"app\", \"apt\", \"bat\"]\n                                   (root)\n                                      |\n                         --------------------------\n                         |                        |\n                         a                        b\n                         |                        |\n                  -----------------                a\n                  |               |                |\n                  p               t(end)           t(end)\n                  |\n              ---------\n              |       |\n              p(end)  l\n                      |\n                      e(end)\n        ```"
  },
  "problems.208-implement-trie-prefix-tree.solution:Trie.__init__": {
    "args": [
      "self"
    ],
    "code": "    def __init__(self):\n        self.root = TrieNode()",
    "file_path": "backend/algorithms/problems/208-implement-trie-prefix-tree/solution.py",
    "kind": "method",
    "label": "def __init__(self)",
    "name": "__init__",
    "summary": "Initializes the Trie with an empty root node.",
    "variables": [
      "root"
    ]
  },
  "problems.208-implement-trie-prefix-tree.solution:Trie.__init__.root": {
    "kind": "variable",
    "name": "root",
    "summary": "the root `TrieNode`, representing the empty prefix"
  },
  "problems.208-implement-trie-prefix-tree.solution:Trie.insert": {
    "args": [
      "word"
    ],
    "code": "    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children[ch]\n        node.end = True",
    "expressions": {
      "node = node.children[ch]": "Traverse to the child node for `ch`, creating it if missing",
      "node.end = True": "Mark this node as terminating a valid word"
    },
    "file_path": "backend/algorithms/problems/208-implement-trie-prefix-tree/solution.py",
    "kind": "method",
    "label": "def insert(self, word: str) -> None",
    "name": "insert",
    "returns": {
      "label": "None"
    },
    "summary": "Inserts a word into the Trie.",
    "time_complexity": "O(m):\nwhere m is the length of the key.\nEach operation involves examining or creating a node until the end of the key.",
    "variables": [
      "node"
    ]
  },
  "problems.208-implement-trie-prefix-tree.solution:Trie.insert.node": {
    "kind": "variable",
    "name": "node",
    "summary": "current `TrieNode` during traversal"
  },
  "problems.208-implement-trie-prefix-tree.solution:Trie.insert.node = node.children[ch]": {
    "kind": "expression",
    "name": "node = node.children[ch]",
    "summary": "Traverse to the child node for `ch`, creating it if missing"
  },
  "problems.208-implement-trie-prefix-tree.solution:Trie.insert.node.end = True": {
    "kind": "expression",
    "name": "node.end = True",
    "summary": "Mark this node as terminating a valid word"
  },
  "problems.208-implement-trie-prefix-tree.solution:Trie.insert.word": {
    "kind": "parameter",
    "label": "word: str",
    "name": "word",
    "summary": "string to insert into the Trie"
  },
  "problems.208-implement-trie-prefix-tree.solution:TrieNode": {
    "class_attributes": [
      "__slots__"
    ],
    "code": "class TrieNode:\n    __slots__ = (\"children\", \"end\")\n\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.end = False",
    "file_path": "backend/algorithms/problems/208-implement-trie-prefix-tree/solution.py",
    "kind": "class",
    "name": "TrieNode",
    "summary": "A node in the Trie."
  },
  "problems.208-implement-trie-prefix-tree.solution:TrieNode.__init__": {
    "args": [
      "self"
    ],
    "code": "    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.end = False",
    "file_path": "backend/algorithms/problems/208-implement-trie-prefix-tree/solution.py",
    "kind": "method",
    "label": "def __init__(self)",
    "name": "__init__",
    "variables": [
      "children",
      "end"
    ]
  },
  "problems.208-implement-trie-prefix-tree.solution:TrieNode.__init__.children": {
    "kind": "variable",
    "name": "children",
    "summary": "`defaultdict[str, TrieNode]` maps characters to child TrieNodes, auto-created on first access"
  },
  "problems.208-implement-trie-prefix-tree.solution:TrieNode.__init__.end": {
    "kind": "variable",
    "name": "end",
    "summary": "bool flag indicating this node marks the end of a valid word"
  },
  "problems.208-implement-trie-prefix-tree.solution:TrieNode.__slots__": {
    "kind": "class_attribute",
    "name": "__slots__",
    "summary": "restrict instances to only these attributes (no __dict__) to save memory and speed up attribute access"
  },
  "problems.211-design-add-and-search-words-data-structure.solution:WordDictionary.search.dfs": {
    "args": [
      "i",
      "node"
    ],
    "code": "        def dfs(node: dict, i: int) -> bool:\n\n            if i == len(word):\n                return self.END_MARKER in node\n\n            if (c := word[i]) == \".\":\n\n                return any(\n                    dfs(child, i + 1)\n                    for k, child in node.items()\n                    if k != self.END_MARKER\n                )\n            child = node.get(c)\n            return bool(child) and dfs(child, i + 1)",
    "expressions": {
      "if k != self.END_MARKER": "try every branch except the END_MARKER"
    },
    "file_path": "backend/algorithms/problems/211-design-add-and-search-words-data-structure/solution.py",
    "kind": "method",
    "label": "def dfs(node: dict, i: int) -> bool",
    "name": "dfs",
    "returns": {
      "label": "bool"
    }
  },
  "problems.211-design-add-and-search-words-data-structure.solution:WordDictionary.search.dfs.if k != self.END_MARKER": {
    "kind": "expression",
    "name": "if k != self.END_MARKER",
    "summary": "try every branch except the END_MARKER"
  },
  "problems.212-word-search-ii.solution:word_search_II": {
    "args": [
      "board",
      "words"
    ],
    "code": "def word_search_II(board: list[list[str]], words: list[str]) -> list[str]:\n    trie = {}  \n    for word in words:\n        node = trie\n        for c in word:\n            node = node.setdefault(c, {})\n        node[\"$\"] = word\n\n    def dfs(i, j, parent):\n        if not (0 <= i < m and 0 <= j < n) or (c := board[i][j]) not in parent:\n            return\n        node = parent[c]\n        if \"$\" in node:\n            res.append(node.pop(\"$\"))\n        board[i][j] = \"#\"\n        for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n            dfs(x, y, node)\n        board[i][j] = c\n        if not node:\n            parent.pop(c)\n\n    m, n, res = len(board), len(board[0]), []\n    [dfs(i, j, trie) for i in range(m) for j in range(n) if board[i][j] in trie]\n\n    return res",
    "expressions": {
      "[dfs": ".. Launch DFS from every cell that matches any trie root key",
      "board[i][j] = \"#": "Mark as visited",
      "board[i][j] = c": "Restore cell",
      "if \"$\" in node": "if the current node is the end of a word",
      "if not node": "prune the trie to remove dead branches.",
      "node = node.setdefault(c, {})": "create a new node for the character if it doesn't exist",
      "res.append(node.pop(\"$\"))": "add the word to the result list and remove the \"$\" key to prevent duplicates"
    },
    "file_path": "backend/algorithms/problems/212-word-search-ii/solution.py",
    "intuition": "- Prefix rails\n    - The trie lays down \"prefix rails\" across the grid: you only move where a rail continues; off‑rail steps end instantly.\n    - A terminal is a station: record the word once, close that spur, and drop empty rails as you pass. In one walk, a cell is used at most once.",
    "kind": "function",
    "label": "def word_search_II(board: list[list[str]], words: list[str]) -> list[str]",
    "name": "word_search_II",
    "returns": {
      "label": "list[str]"
    },
    "time_complexity": "O(m n * 4^L)\n**Symbols:** m×n board, W=∑(w∈dict)|w|, L=max|w|.\n**Build trie:** O(W).\n**DFS (worst case):** first step ≤ 4 choices, then ≤ 3 per step ⇒ O(m n * 4 * 3^(L-1)). Coarse bound: O(m n * 4^L).\n**Space:** trie O(W); recursion/visited path O(L).",
    "topics": [
      "Trie"
    ],
    "variables": [
      "trie",
      "m",
      "n",
      "res"
    ]
  },
  "problems.212-word-search-ii.solution:word_search_II.[dfs": {
    "kind": "expression",
    "name": "[dfs",
    "summary": ".. Launch DFS from every cell that matches any trie root key"
  },
  "problems.212-word-search-ii.solution:word_search_II.board[i][j] = \"#": {
    "kind": "expression",
    "name": "board[i][j] = \"#",
    "summary": "Mark as visited"
  },
  "problems.212-word-search-ii.solution:word_search_II.board[i][j] = c": {
    "kind": "expression",
    "name": "board[i][j] = c",
    "summary": "Restore cell"
  },
  "problems.212-word-search-ii.solution:word_search_II.dfs": {
    "args": [
      "i",
      "j",
      "parent"
    ],
    "code": "    def dfs(i, j, parent):\n        if not (0 <= i < m and 0 <= j < n) or (c := board[i][j]) not in parent:\n            return\n        node = parent[c]\n        if \"$\" in node:\n            res.append(node.pop(\"$\"))\n        board[i][j] = \"\n        for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n            dfs(x, y, node)\n        board[i][j] = c\n        if not node:\n            parent.pop(c)",
    "file_path": "backend/algorithms/problems/212-word-search-ii/solution.py",
    "kind": "function",
    "label": "def dfs(i, j, parent)",
    "name": "dfs",
    "summary": "DFS from board[i][j], following *parent* trie node.\nCollects words, marks visited, prunes used-up trie branches."
  },
  "problems.212-word-search-ii.solution:word_search_II.if \"$\" in node": {
    "kind": "expression",
    "name": "if \"$\" in node",
    "summary": "if the current node is the end of a word"
  },
  "problems.212-word-search-ii.solution:word_search_II.if not node": {
    "kind": "expression",
    "name": "if not node",
    "summary": "prune the trie to remove dead branches."
  },
  "problems.212-word-search-ii.solution:word_search_II.m": {
    "kind": "variable",
    "name": "m",
    "summary": "number of rows"
  },
  "problems.212-word-search-ii.solution:word_search_II.n": {
    "kind": "variable",
    "name": "n",
    "summary": "number of columns"
  },
  "problems.212-word-search-ii.solution:word_search_II.node = node.setdefault(c, {})": {
    "kind": "expression",
    "name": "node = node.setdefault(c, {})",
    "summary": "create a new node for the character if it doesn't exist"
  },
  "problems.212-word-search-ii.solution:word_search_II.res": {
    "kind": "variable",
    "name": "res",
    "summary": "the list of found words"
  },
  "problems.212-word-search-ii.solution:word_search_II.res.append(node.pop(\"$\"))": {
    "kind": "expression",
    "name": "res.append(node.pop(\"$\"))",
    "summary": "add the word to the result list and remove the \"$\" key to prevent duplicates"
  },
  "problems.212-word-search-ii.solution:word_search_II.trie": {
    "kind": "variable",
    "name": "trie",
    "summary": "Build trie from **words** list. Each end node gets a `$` key holding the word"
  },
  "problems.213-house-robber-ii.solution:circularRob": {
    "args": [
      "houses"
    ],
    "code": "def circularRob(houses: list[int]) -> int:\n    if len(houses) == 1:\n        return houses[0]\n    return max(rob(houses[:-1]), rob(houses[1:]))",
    "file_path": "backend/algorithms/problems/213-house-robber-ii/solution.py",
    "intuition": "- In a circle, first and last houses are adjacent — we cannot rob both\n    - ⇒ Split into two linear cases:\n        - exclude last house → `rob(houses[:-1])`\n        - exclude first house → `rob(houses[1:])`\n    - Take the better of the two.\n\n    - Base case:\n        - if only one house, rob it directly.",
    "kind": "function",
    "label": "def circularRob(houses: list[int]) -> int",
    "name": "circularRob",
    "returns": {
      "label": "int"
    }
  },
  "problems.2140-solving-questions-with-brainpower.solution:most_points_solving_questions_with_brainpower": {
    "args": [
      "questions"
    ],
    "code": "def most_points_solving_questions_with_brainpower(questions: list[list[int]]) -> int:\n\n    memo, n = {}, len(questions)\n\n    def dp(i):\n        if i >= n:\n            return 0\n\n        if i not in memo:\n            memo[i] = max(dp(i + 1), (q:=questions[i])[0] + dp(i + 1 + q[1]))\n        return memo[i]\n\n    return dp(0)",
    "file_path": "backend/algorithms/problems/2140-solving-questions-with-brainpower/solution.py",
    "intuition": "- Paradigm: This is a classic **Longest Path** problem on a Directed Acyclic Graph (DAG).\n    - Insight: The maximum score obtainable *from* any question `i` is a fixed value, regardless of past choices. This allows a backward pass from the end of the exam (where the future score is 0), calculating the optimal future score for each question by simply choosing the `max()` of two pre-computed paths: the one from \"solving\" vs. the one from \"skipping\".",
    "kind": "function",
    "label": "def most_points_solving_questions_with_brainpower(questions: list[list[int]]) -> int",
    "name": "most_points_solving_questions_with_brainpower",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n)\nwhere `n` is the number of questions."
  },
  "problems.2145-count-the-hidden-sequences.solution:numberOfArrays": {
    "args": [
      "lower",
      "upper",
      "differences"
    ],
    "code": "def numberOfArrays(differences: list[int], lower: int, upper: int) -> int:\n\n    prefix_sum = min_marker = max_marker = 0\n\n    for diff in differences:\n        prefix_sum += diff\n        min_marker = min(min_marker, prefix_sum)\n        max_marker = max(max_marker, prefix_sum)\n\n    return max(0, (upper - max_marker) - (lower - min_marker) + 1)",
    "file_path": "backend/algorithms/problems/2145-count-the-hidden-sequences/solution.py",
    "kind": "function",
    "label": "def numberOfArrays(differences: list[int], lower: int, upper: int) -> int",
    "name": "numberOfArrays",
    "returns": {
      "label": "int",
      "summary": "The number of valid starting values."
    }
  },
  "problems.2145-count-the-hidden-sequences.solution:numberOfArrays.differences": {
    "kind": "parameter",
    "label": "differences: list[int]",
    "name": "differences",
    "summary": "List of daily changes (trip segments)."
  },
  "problems.2145-count-the-hidden-sequences.solution:numberOfArrays.lower": {
    "kind": "parameter",
    "label": "lower: int",
    "name": "lower",
    "summary": "Lower bound for any marker on the highway."
  },
  "problems.2145-count-the-hidden-sequences.solution:numberOfArrays.upper": {
    "kind": "parameter",
    "label": "upper: int",
    "name": "upper",
    "summary": "Upper bound for any marker on the highway."
  },
  "problems.215-kth-largest-element-in-an-array.solution:findKthLargest": {
    "args": [
      "k",
      "nums"
    ],
    "code": "def findKthLargest(nums: list[int], k: int) -> int:\n    h = nums[:k]; heapq.heapify(h)\n    for x in nums[k:]:\n        if x > h[0]:\n            heapq.heapreplace(h, x) \n    return h[0]",
    "expressions": {
      "heapreplace(h, x)": "replaces root with x, performs one sift-down          → O(log k) with ~½ the operations of heappush(sift-up)+heappop(sift-down) (≈ 2 × O(log k))"
    },
    "file_path": "backend/algorithms/problems/215-kth-largest-element-in-an-array/solution.py",
    "kind": "function",
    "label": "def findKthLargest(nums: list[int], k: int) -> int",
    "name": "findKthLargest",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n log k):\nDeep Dive: one sift (faster constant) vs push+pop\n    heappush does a sift-up → O(log k)\n    heappop does a sift-down → O(log k)\n    total ≈ 2 x O(log k) operations\n    heapreplace does one sift operation, not two\n    removes root, places new element, and does only one sift-down → O(log k)\n    So same asymptotic complexity, but half the work, fewer comparisons and function calls → faster constant factor."
  },
  "problems.215-kth-largest-element-in-an-array.solution:findKthLargest.heapreplace(h, x)": {
    "kind": "expression",
    "name": "heapreplace(h, x)",
    "summary": "replaces root with x, performs one sift-down          → O(log k) with ~½ the operations of heappush(sift-up)+heappop(sift-down) (≈ 2 × O(log k))"
  },
  "problems.238-product-of-array-except-self.solution:product_of_array_except_self": {
    "args": [
      "nums"
    ],
    "code": "def product_of_array_except_self(nums: list[int]) -> list[int]:\n\n    pre, res = 1, [1] * (n := len(nums))\n    for i, x in enumerate(nums):\n        res[i], pre = pre, pre * x\n    suf = 1\n    for i in range(n - 1, -1, -1):\n        res[i], suf = res[i] * suf, suf * nums[i]\n    return res",
    "file_path": "backend/algorithms/problems/238-product-of-array-except-self/solution.py",
    "intuition": "- Two passes:\n        1.  *[orange!]Prefix* pass → `res[i]` = product of all elements *[orange!]before* `i`.\n        2.  *[purple!]Suffix* pass → multiply each `res[i]` by product of all elements *[purple!]after* `i`.",
    "kind": "function",
    "label": "def product_of_array_except_self(nums: list[int]) -> list[int]",
    "name": "product_of_array_except_self",
    "returns": {
      "label": "list[int]"
    },
    "time_complexity": "O(n)\nwhere n is the length of the nums array. We iterate through the array twice."
  },
  "problems.2402-meeting-rooms-iii.solution:mostBooked": {
    "args": [
      "n",
      "meetings"
    ],
    "code": "def mostBooked(n: int, meetings: list[list[int]]) -> int:\n\n    busy = []\n    heapify((free := [*range(n)]))\n    count = [0] * n\n\n    for s, e in sorted(meetings):\n        while busy and busy[0][0] <= s:\n            _, r = heappop(busy)\n            heappush(free, r)\n        if free:\n            r = heappop(free)\n            heappush(busy, (e, r))\n        else:\n            next_end, r = heappop(busy)\n            heappush(busy, (next_end + (e - s), r))\n        count[r] += 1\n\n    return max(range(n), key=count.__getitem__)",
    "expressions": {
      "max(range(n), key=count.__getitem__)": "`range(n)` :creates `indices 0…n-1`, then for each `index i`, calls `count.__getitem__(i)` (same as `count[i]`) to fetch the value; after comparing all, returns the `index i` whose `count[i]` is largest."
    },
    "file_path": "backend/algorithms/problems/2402-meeting-rooms-iii/solution.py",
    "kind": "function",
    "label": "def mostBooked(n: int, meetings: list[list[int]]) -> int",
    "name": "mostBooked",
    "returns": {
      "label": "int"
    }
  },
  "problems.2402-meeting-rooms-iii.solution:mostBooked.max(range(n), key=count.__getitem__)": {
    "kind": "expression",
    "name": "max(range(n), key=count.__getitem__)",
    "summary": "`range(n)` :creates `indices 0…n-1`, then for each `index i`, calls `count.__getitem__(i)` (same as `count[i]`) to fetch the value; after comparing all, returns the `index i` whose `count[i]` is largest."
  },
  "problems.253-meeting-rooms-ii.sweep-line:minMeetingRooms": {
    "args": [
      "intervals"
    ],
    "code": "def minMeetingRooms(intervals):\n\n    time = defaultdict(int)\n    for s, e in intervals:\n        time[s] += 1\n        time[e] -= 1\n\n    active = rooms = 0\n    for _, d in sorted(time.items()):\n        active += d\n        rooms = max(active, rooms)\n    return rooms",
    "file_path": "backend/algorithms/problems/253-meeting-rooms-ii/sweep-line.py",
    "intuition": "- Each start adds a room (+1), each end frees one (-1).\n    - Sweeping sorted times, track active meetings; the peak is the answer.",
    "kind": "function",
    "label": "def minMeetingRooms(intervals)",
    "name": "minMeetingRooms",
    "time_complexity": "O(n log n)"
  },
  "problems.253-meeting-rooms-ii.two-pointer-interval-sort-and-scan:minMeetingRooms": {
    "args": [
      "intervals"
    ],
    "code": "def minMeetingRooms(intervals: list[list[int]]) -> int:\n    starts = sorted(s for s, _ in intervals)\n    ends = sorted(e for _, e in intervals)\n    rooms = e = 0\n    for s in starts:\n        if s < ends[e]:\n            rooms += 1\n        else:\n            e += 1\n    return rooms",
    "file_path": "backend/algorithms/problems/253-meeting-rooms-ii/two-pointer-interval-sort-and-scan.py",
    "intuition": "1. Sort all *start times* and all *end times*\n\n    2. For each start time:\n        - if it is earlier than the earliest end time we haven't used yet,                no room has freed -> take a new room.\n        - otherwise, advance the end pointer -> reuse that freed room\n\n    - `rooms` becomes the maximum number of simultaneous meetings",
    "kind": "function",
    "label": "def minMeetingRooms(intervals: list[list[int]]) -> int",
    "name": "minMeetingRooms",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n log n) for sorting"
  },
  "problems.256-paint-house.scalar:Solution.minCost": {
    "args": [
      "costs"
    ],
    "code": "    def minCost(self, costs: list[list[int]]) -> int:\n        n, memo = len(costs), {}\n\n        def dp(i: int, c: int) -> int:\n            if i == n:\n                return \n            if (i, c) not in memo:\n\n                memo[i, c] = costs[i][c] + min(\n                    dp(i + 1, (c + 1) % 3), dp(i + 1, (c + 2) % 3)\n                )\n            return memo[i, c]\n\n        return min(dp(0, 0), dp(0, 1), dp(0, 2))",
    "file_path": "backend/algorithms/problems/256-paint-house/scalar.py",
    "intuition": "- Deep Dive:Paint House (k=3) — Top-down DP with explicit memoization:\n    - **Subproblems:** dp(i, c) = min total cost to paint houses *[2!]suffix [i:]* given house i is painted color c.\n    - **Relate:** `[language=\"python\"]dp(i, c) = costs[i][c] + min(dp(i+1, other_color_1), dp(i+1, other_color_2))`                 *[19!]Choose the cheaper of the two other colors for the next house.*\n    - **Topological order:** *[2!]decreasing i*, subproblem `dp(i, c)` depends only on strictly larger i, `dp(i+1, other_color_1)` and `dp(i+1, other_color_2)`, so acyclic\n    - **Base case:**`dp(n, c) = 0` → no houses left to paint.\n    - **Original problem:** return `min(dp(0, 0), dp(0, 1), dp(0, 2))` — start with any first color.\n    - **Time complexity:** *O(n)*: each `(i, c)` computed once, constant work per state.\n    - **Space:** *O(n)* for memo and recursion depth.\n    - **Returns:** Minimum total cost to paint all houses so that no two adjacent share a color",
    "kind": "method",
    "label": "def minCost(self, costs: list[list[int]]) -> int",
    "name": "minCost",
    "returns": {
      "label": "int"
    }
  },
  "problems.256-paint-house.scalar:Solution.minCost.dp": {
    "args": [
      "i",
      "c"
    ],
    "code": "        def dp(i: int, c: int) -> int:\n            if i == n:\n                return \n            if (i, c) not in memo:\n\n                memo[i, c] = costs[i][c] + min(\n                    dp(i + 1, (c + 1) % 3), dp(i + 1, (c + 2) % 3)\n                )\n            return memo[i, c]",
    "expressions": {
      "dp(i + 1, (c + 1) % 3), dp(i + 1, (c + 2) % 3)": "pick the cheapest of the two other color options for the next house"
    },
    "file_path": "backend/algorithms/problems/256-paint-house/scalar.py",
    "kind": "method",
    "label": "def dp(i: int, c: int) -> int",
    "name": "dp",
    "returns": {
      "label": "int"
    }
  },
  "problems.256-paint-house.scalar:Solution.minCost.dp.dp(i + 1, (c + 1) % 3), dp(i + 1, (c + 2) % 3)": {
    "kind": "expression",
    "name": "dp(i + 1, (c + 1) % 3), dp(i + 1, (c + 2) % 3)",
    "summary": "pick the cheapest of the two other color options for the next house"
  },
  "problems.256-paint-house.vector:Solution.minCost": {
    "args": [
      "costs"
    ],
    "code": "    def minCost(self, costs: list[list[int]]) -> int:\n        n, memo = len(costs), {}\n\n        def dp(i: int) -> list[int]:\n            if i == n:\n                return [0, 0, 0]  \n\n            if i not in memo:\n                nxt = dp(i + 1)  \n\n                m1 = m2 = float(\"inf\"); c1 = -1\n                for c, v in enumerate(nxt):\n                    if v < m1:\n                        m2, m1, c1 = m1, v, c\n                    elif v < m2:\n                        m2 = v\n                memo[i] = [costs[i][c] + (m2 if c == c1 else m1) for c in range(3)]\n            return memo[i]\n\n        return min(dp(0))",
    "file_path": "backend/algorithms/problems/256-paint-house/vector.py",
    "intuition": "- Deep Dive:Paint House (k=3) — Top-down DP with explicit memoization:\n        - **Subproblems:** dp(i, c) = min total cost to paint houses *[2!]suffix [i:]* given house i is painted color c\n        - **Relate:** *$dp(i, c) = costs[i][c] + \\min_{c'!=c} dp(i+1, c')$*\n        - **Topological order:** *[2!]decreasing i*, subproblem `dp(i)` depends only on strictly larger i, `dp(i+1)`, so acyclic\n        - **Base case:** `dp(n) = [0, 0, 0]` (no houses left)\n        - **Original problem:** `answer = min(dp(0))`\n\n    - Time complexity:\n        - O(n):\n        - number of subproblems is n (We compute dp(i) once for each i)\n        - time per subproblem is O(1) (k=3).\n        - → *Θ(n)* total",
    "kind": "method",
    "label": "def minCost(self, costs: list[list[int]]) -> int",
    "name": "minCost",
    "returns": {
      "label": "int",
      "summary": "Minimum total cost to paint all houses with no adjacent equal colors."
    }
  },
  "problems.256-paint-house.vector:Solution.minCost.dp": {
    "args": [
      "i"
    ],
    "code": "        def dp(i: int) -> list[int]:\n            if i == n:\n                return [0, 0, 0]  \n\n            if i not in memo:\n                nxt = dp(i + 1)  \n\n                m1 = m2 = float(\"inf\"); c1 = -1\n                for c, v in enumerate(nxt):\n                    if v < m1:\n                        m2, m1, c1 = m1, v, c\n                    elif v < m2:\n                        m2 = v\n                memo[i] = [costs[i][c] + (m2 if c == c1 else m1) for c in range(3)]\n            return memo[i]",
    "expressions": {
      "nxt = dp(i + 1)": "dp(i+1) = costs from the suffix [i+1:]"
    },
    "file_path": "backend/algorithms/problems/256-paint-house/vector.py",
    "kind": "method",
    "label": "def dp(i: int) -> list[int]",
    "name": "dp",
    "returns": {
      "label": "list[int]"
    },
    "variables": [
      "m1",
      "m2",
      "c1",
      "nxt = costs for suffix [i+1"
    ]
  },
  "problems.256-paint-house.vector:Solution.minCost.dp.c1": {
    "kind": "variable",
    "name": "c1",
    "summary": "color of smallest cost in nxt (m1's color)"
  },
  "problems.256-paint-house.vector:Solution.minCost.dp.m1": {
    "kind": "variable",
    "name": "m1",
    "summary": "smallest cost in nxt"
  },
  "problems.256-paint-house.vector:Solution.minCost.dp.m2": {
    "kind": "variable",
    "name": "m2",
    "summary": "second smallest cost in nxt"
  },
  "problems.256-paint-house.vector:Solution.minCost.dp.nxt = costs for suffix [i+1": {
    "kind": "variable",
    "name": "nxt = costs for suffix [i+1",
    "summary": "]"
  },
  "problems.256-paint-house.vector:Solution.minCost.dp.nxt = dp(i + 1)": {
    "kind": "expression",
    "name": "nxt = dp(i + 1)",
    "summary": "dp(i+1) = costs from the suffix [i+1:]"
  },
  "problems.265-paint-house-ii.top-down:Solution.minCostII": {
    "args": [
      "costs"
    ],
    "code": "    def minCostII(self, costs: list[list[int]]) -> int:\n        n, k, memo = len(costs), len(costs[0]) , {}\n\n        def dp(i: int) -> list[int]:\n            if i == n:\n                return [0] * k\n\n            if i not in memo:\n                nxt = dp(i + 1)\n\n                m1 = m2 = float(\"inf\"); c1 = -1\n                for c, v in enumerate(nxt):\n                    if v < m1:\n                        m2, m1, c1 = m1, v, c\n                    elif v < m2:\n                        m2 = v\n                memo[i] = [costs[i][c] + (m2 if c == c1 else m1) for c in range(k)]\n            return memo[i]\n\n        return min(dp(0))",
    "file_path": "backend/algorithms/problems/265-paint-house-ii/top-down.py",
    "intuition": "- Deep Dive: Paint House (k colors) — Top-down DP with explicit memoization\n        - Subproblems: dp(i, c) = min total cost to paint suffix houses [i:] given house i is color c\n        - Relate: *$dp(i,c) = {costs}[i][c] + \\min_{c \\!= c} dp(i+1,c')$*\n        - Topological order: decreasing i (each dp(i,·) depends only on dp(i+1,·)) ⇒ acyclic\n        - Base case: dp(n, c) = 0 for all c (no houses left)\n        - Original problem: answer = min(dp(0, c)) over all colors c\n\n    - Time complexity:\n        - O(n * k):\n        - *n* rows x *O(k)* per row using *(m1, m2, c1)* trick\n\n    - Space:\n        - Θ(n·k) for memo (stores a length-k row per i)",
    "kind": "method",
    "label": "def minCostII(self, costs: list[list[int]]) -> int",
    "name": "minCostII",
    "returns": {
      "label": "int"
    }
  },
  "problems.265-paint-house-ii.top-down:Solution.minCostII.dp": {
    "args": [
      "i"
    ],
    "code": "        def dp(i: int) -> list[int]:\n            if i == n:\n                return [0] * k\n\n            if i not in memo:\n                nxt = dp(i + 1)\n\n                m1 = m2 = float(\"inf\"); c1 = -1\n                for c, v in enumerate(nxt):\n                    if v < m1:\n                        m2, m1, c1 = m1, v, c\n                    elif v < m2:\n                        m2 = v\n                memo[i] = [costs[i][c] + (m2 if c == c1 else m1) for c in range(k)]\n            return memo[i]",
    "expressions": {
      "costs[i][c] + (m2 if c == c1 else m1)": "If current color equals c1, we must take m2; otherwise take m1",
      "for c, v in enumerate(nxt)": "Scan once to find the two best colors for the next row"
    },
    "file_path": "backend/algorithms/problems/265-paint-house-ii/top-down.py",
    "kind": "method",
    "label": "def dp(i: int) -> list[int]",
    "name": "dp",
    "returns": {
      "label": "list[int]"
    },
    "variables": [
      "m1",
      "m2",
      "c1",
      "nxt = costs for suffix [i+1"
    ]
  },
  "problems.265-paint-house-ii.top-down:Solution.minCostII.dp.c1": {
    "kind": "variable",
    "name": "c1",
    "summary": "color of smallest cost in nxt (m1's color)"
  },
  "problems.265-paint-house-ii.top-down:Solution.minCostII.dp.costs[i][c] + (m2 if c == c1 else m1)": {
    "kind": "expression",
    "name": "costs[i][c] + (m2 if c == c1 else m1)",
    "summary": "If current color equals c1, we must take m2; otherwise take m1"
  },
  "problems.265-paint-house-ii.top-down:Solution.minCostII.dp.for c, v in enumerate(nxt)": {
    "kind": "expression",
    "name": "for c, v in enumerate(nxt)",
    "summary": "Scan once to find the two best colors for the next row"
  },
  "problems.265-paint-house-ii.top-down:Solution.minCostII.dp.m1": {
    "kind": "variable",
    "name": "m1",
    "summary": "smallest value in nxt"
  },
  "problems.265-paint-house-ii.top-down:Solution.minCostII.dp.m2": {
    "kind": "variable",
    "name": "m2",
    "summary": "second smallest value in nxt"
  },
  "problems.265-paint-house-ii.top-down:Solution.minCostII.dp.nxt = costs for suffix [i+1": {
    "kind": "variable",
    "name": "nxt = costs for suffix [i+1",
    "summary": "]"
  },
  "problems.3-longest-substring-without-repeating-characters.solution:longest_substring_without_repeating_characters": {
    "args": [
      "s"
    ],
    "code": "def longest_substring_without_repeating_characters(s: str) -> int:\n    c_idx, l, max_length = {}, 0, 0\n    for r, c in enumerate(s):\n        if c in c_idx:\n            l = max(c_idx[c] + 1, l)\n        c_idx[c] = r\n        max_length = max(max_length, r - l + 1)\n    return max_length",
    "expressions": {
      "l = max(c_idx[c] + 1, l)": "ensures that l does not move backward in cases where the last occurrence of s[r] was before l."
    },
    "file_path": "backend/algorithms/problems/3-longest-substring-without-repeating-characters/solution.py",
    "kind": "function",
    "label": "def longest_substring_without_repeating_characters(s: str) -> int",
    "name": "longest_substring_without_repeating_characters",
    "returns": {
      "label": "int",
      "summary": "Length of the longest substring without repeating characters"
    },
    "time_complexity": "O(n)"
  },
  "problems.3-longest-substring-without-repeating-characters.solution:longest_substring_without_repeating_characters.l = max(c_idx[c] + 1, l)": {
    "kind": "expression",
    "name": "l = max(c_idx[c] + 1, l)",
    "summary": "ensures that l does not move backward in cases where the last occurrence of s[r] was before l."
  },
  "problems.3-longest-substring-without-repeating-characters.solution:longest_substring_without_repeating_characters.s": {
    "kind": "parameter",
    "label": "s: str",
    "name": "s",
    "summary": "Input string to analyze"
  },
  "problems.325-maximum-size-subarray-sum-equals-k.solution:maxSizeSubarraySumEqualsK": {
    "args": [
      "k",
      "segments"
    ],
    "code": "def maxSizeSubarraySumEqualsK(segments: list[int], k: int) -> int:\n\n    marker_idx = {0: -1}\n    prefix_sum = max_length = 0\n\n    for i, segment in enumerate(segments):\n\n        prefix_sum += segment\n\n        if (target_marker := prefix_sum - k) in marker_idx:\n            max_length = max(max_length, i - marker_idx[target_marker])\n\n        if prefix_sum not in marker_idx:\n            marker_idx[prefix_sum] = i\n\n    return max_length",
    "file_path": "backend/algorithms/problems/325-maximum-size-subarray-sum-equals-k/solution.py",
    "kind": "function",
    "label": "def maxSizeSubarraySumEqualsK(segments: list[int], k: int) -> int",
    "name": "maxSizeSubarraySumEqualsK",
    "returns": {
      "label": "int",
      "summary": "The length of the longest subarray with sum == k."
    }
  },
  "problems.325-maximum-size-subarray-sum-equals-k.solution:maxSizeSubarraySumEqualsK.k": {
    "kind": "parameter",
    "label": "k: int",
    "name": "k",
    "summary": "Target sum."
  },
  "problems.325-maximum-size-subarray-sum-equals-k.solution:maxSizeSubarraySumEqualsK.segments": {
    "kind": "parameter",
    "label": "segments: list[int]",
    "name": "segments",
    "summary": "List of integers representing trip segments."
  },
  "problems.347-top-k-frequent-elements.heap-nlargets:topKFrequent": {
    "args": [
      "k",
      "nums"
    ],
    "code": "def topKFrequent(nums: list[int], k: int) -> list[int]:\n    freq = Counter(nums)\n    return heapq.nlargest(k, freq.keys(), key=freq.get)",
    "expressions": {
      "freq.keys()": "iterable → here freq.keys(), i.e. all unique numbers.",
      "key=freq.get": "key → function that gives a value to rank by. freq.get(x) = frequency of x."
    },
    "file_path": "backend/algorithms/problems/347-top-k-frequent-elements/heap-nlargets.py",
    "kind": "function",
    "label": "def topKFrequent(nums: list[int], k: int) -> list[int]",
    "name": "topKFrequent",
    "returns": {
      "label": "list[int]"
    },
    "summary": "using built-in function heapq.nlargest",
    "time_complexity": "O(n log k)"
  },
  "problems.347-top-k-frequent-elements.heap-nlargets:topKFrequent.freq.keys()": {
    "kind": "expression",
    "name": "freq.keys()",
    "summary": "iterable → here freq.keys(), i.e. all unique numbers."
  },
  "problems.347-top-k-frequent-elements.heap-nlargets:topKFrequent.key=freq.get": {
    "kind": "expression",
    "name": "key=freq.get",
    "summary": "key → function that gives a value to rank by. freq.get(x) = frequency of x."
  },
  "problems.347-top-k-frequent-elements.heap:topKFrequent": {
    "args": [
      "k",
      "nums"
    ],
    "code": "def topKFrequent(nums: list[int], k: int) -> list[int]:\n    freq ,h= Counter(nums), []\n    for num, f in freq.items():\n        heapq.heappush(h, (f, num))\n        if len(h) > k:\n            heapq.heappop(h)\n\n    return [num for _, num in h]",
    "file_path": "backend/algorithms/problems/347-top-k-frequent-elements/heap.py",
    "kind": "function",
    "label": "def topKFrequent(nums: list[int], k: int) -> list[int]",
    "name": "topKFrequent",
    "returns": {
      "label": "list[int]"
    },
    "time_complexity": "O(n log k)"
  },
  "problems.347-top-k-frequent-elements.sort-frequency-bucketing:topKFrequent": {
    "args": [
      "k",
      "nums"
    ],
    "code": "def topKFrequent(nums: list[int], k: int) -> list[int]:\n\n    bucket=[[] for _ in range(len(nums)+1)]\n    for n,f in Counter(nums).items():\n        bucket[f].append(n)\n\n    return [num for f_bucket in reversed(bucket) for num in f_bucket][:k]",
    "file_path": "backend/algorithms/problems/347-top-k-frequent-elements/sort-frequency-bucketing.py",
    "kind": "function",
    "label": "def topKFrequent(nums: list[int], k: int) -> list[int]",
    "name": "topKFrequent",
    "returns": {
      "label": "list[int]"
    },
    "time_complexity": "O(n):\nCounter(nums) → O(n)\nBuild buckets → O(n) (each element placed once)\nFlatten in reverse until k → O(n)"
  },
  "problems.36-valid-sudoku.solution:is_valid_sudoku": {
    "args": [
      "board"
    ],
    "code": "def is_valid_sudoku(board: list[list[str]]) -> bool:\n\n    row = [set() for _ in range(9)]\n    col = [set() for _ in range(9)]\n    cube = [set() for _ in range(9)]\n\n    for r in range(9):\n        for c in range(9):\n            if (num := board[r][c]) != \".\": \n\n                if (\n                    num in col[c]\n                    or num in row[r]\n                    or num in cube[(cube_index := (r // 3) * 3 + (c // 3))]\n                ):\n                    return False\n\n                col[c].add(num)\n                row[r].add(num)\n                cube[cube_index].add(num)\n    return True",
    "expressions": {
      "cube_index := (r // 3) * 3 + (c // 3)": "The formula works by treating the *9×9* board as a *3×3* grid of *3×3* boxes:\n         - **[pink!]r//3** gives which *[pink!]box-row* (0,1,2) you're in;\n         - **[purple!]c//3** gives which *[purple!]box-column* (0,1,2).\n         - Multiplying the *[pink!]box-row* by *[pink!]3* and adding the *[purple!]box-column* yields a unique index 0–8 for each *3×3* cube.",
      "if (": "Check for duplicates",
      "if (num := board[r][c]) != \".": "Skip empty cells"
    },
    "file_path": "backend/algorithms/problems/36-valid-sudoku/solution.py",
    "intuition": "- Cube index and think locally\n    - **cube_index := **[pink!](r // 3) * 3** + **[purple!](c // 3)**** treats the 9×9 board as a 3×3 grid of 3×3 boxes:\n        - `[pink!]r//3` gives which *[pink!]box-row* (0,1,2) you're in\n        - `[purple!]c//3` gives which *[purple!]box-column* (0,1,2)\n         - multiplying the *[pink!]box-row* by *[pink!]3* and adding the *[purple!]box-column* yields a unique index 0–8 for each 3×3 cube.",
    "kind": "function",
    "label": "def is_valid_sudoku(board: list[list[str]]) -> bool",
    "name": "is_valid_sudoku",
    "returns": {
      "label": "bool",
      "summary": "True if the board is valid, False otherwise"
    },
    "time_complexity": "O(81)\ni.e., O(n^2). Fixed 9×9 boards scan at most 81 cells. Generalized n×n Sudoku validation runs in O(n^2) time."
  },
  "problems.36-valid-sudoku.solution:is_valid_sudoku.board": {
    "kind": "parameter",
    "label": "board: list[list[str]]",
    "name": "board",
    "summary": "9x9 Sudoku board with digits 1-9 and '.' for empty cells"
  },
  "problems.36-valid-sudoku.solution:is_valid_sudoku.cube_index := (r // 3) * 3 + (c // 3)": {
    "kind": "expression",
    "name": "cube_index := (r // 3) * 3 + (c // 3)",
    "summary": "The formula works by treating the *9×9* board as a *3×3* grid of *3×3* boxes:\n         - **[pink!]r//3** gives which *[pink!]box-row* (0,1,2) you're in;\n         - **[purple!]c//3** gives which *[purple!]box-column* (0,1,2).\n         - Multiplying the *[pink!]box-row* by *[pink!]3* and adding the *[purple!]box-column* yields a unique index 0–8 for each *3×3* cube."
  },
  "problems.36-valid-sudoku.solution:is_valid_sudoku.if (": {
    "kind": "expression",
    "name": "if (",
    "summary": "Check for duplicates"
  },
  "problems.36-valid-sudoku.solution:is_valid_sudoku.if (num := board[r][c]) != \".": {
    "kind": "expression",
    "name": "if (num := board[r][c]) != \".",
    "summary": "Skip empty cells"
  },
  "problems.37-sudoku-solver.solution:solve_sudoku": {
    "args": [
      "board"
    ],
    "code": "def solve_sudoku(board: list[list[str]]) -> None:\n\n    D = set(\"123456789\")\n    rows = [set() for _ in range(9)]; cols = [set() for _ in range(9)]; boxes = [set() for _ in range(9)]\n    empties: list[tuple[int,int]] = []\n    for i in range(9):\n        for j in range(9):\n            v = board[i][j]\n            if v == '.': empties.append((i, j))\n            else: \n                rows[i].add(v); cols[j].add(v); boxes[i//3*3 + j//3].add(v)\n\n    def dfs() -> bool:\n        if not empties: return True\n        k, (i, j), cand = min(\n            ((t, (i, j), D - (rows[i] | cols[j] | boxes[i//3*3 + j//3])) for t, (i, j) in enumerate(empties)),\n            key=lambda x: len(x[2])\n        )\n\n        empties.pop(k)\n        for d in cand:\n            board[i][j] = d; rows[i].add(d); cols[j].add(d); boxes[(b:=i//3*3 + j//3)].add(d)\n            if dfs(): return True\n            rows[i].remove(d); cols[j].remove(d); boxes[b].remove(d)\n        board[i][j] = '.'; empties.insert(k, (i, j))\n        return False\n\n    dfs()",
    "file_path": "backend/algorithms/problems/37-sudoku-solver/solution.py",
    "intuition": "- MRV (Minimum Remaining Values):\n    - Candidates per cell: `{'1'..'9'} − (row ∪ col ∪ box)`.\n    - MRV: pick the empty cell with the fewest candidates to prune hardest.\n    - Place a digit tentatively, update sets, recurse; undo on failure (backtrack).\n    - If any cell has 0 candidates, the branch is impossible → backtrack immediately.",
    "kind": "function",
    "label": "def solve_sudoku(board: list[list[str]]) -> None",
    "name": "solve_sudoku",
    "returns": {
      "label": "None"
    },
    "time_complexity": "O(9^k):\nLet k be the number of empty cells (≤ 81).\npractically Θ(∏(t=1 to k) m_t) where m_t = MRV-picked cell's candidate count at step t (usually ≪ 9)\nMRV selection adds O(k) per level (≤ O(k^2) per path), dominated by the search"
  },
  "problems.370-range-addition.solution:getModifiedArray": {
    "args": [
      "updates",
      "length"
    ],
    "code": "def getModifiedArray(length: int, updates: list[list[int]]) -> list[int]:\n\n    delta = [0] * (length + 1)\n\n    for start_day, end_day, change_in_km in updates:\n        delta[start_day] += change_in_km\n        delta[end_day + 1] -= change_in_km\n\n    prefix_sum = 0\n    return [prefix_sum := prefix_sum + change for change in delta[:-1]]",
    "file_path": "backend/algorithms/problems/370-range-addition/solution.py",
    "kind": "function",
    "label": "def getModifiedArray(length: int, updates: list[list[int]]) -> list[int]",
    "name": "getModifiedArray",
    "returns": {
      "label": "list[int]",
      "summary": "The final daily travel plan after all updates."
    }
  },
  "problems.370-range-addition.solution:getModifiedArray.length": {
    "kind": "parameter",
    "label": "length: int",
    "name": "length",
    "summary": "The number of days in the itinerary."
  },
  "problems.370-range-addition.solution:getModifiedArray.updates": {
    "kind": "parameter",
    "label": "updates: list[list[int]]",
    "name": "updates",
    "summary": "List of [start_day, end_day, change_in_km] updates."
  },
  "problems.39-combination-sum.solution:combination_sum": {
    "args": [
      "candidates",
      "target"
    ],
    "code": "def combination_sum(candidates: list[int], target: int) -> list[list[int]]:\n\n    candidates.sort()\n    res, path = [], []\n\n    def dfs(i: int, rem: int) -> None:\n        if rem == 0:\n            res.append(path.copy())\n            return\n        for j in range(i, len(candidates)):\n            if (c := candidates[j]) > rem:\n                break\n            path.append(c)\n            dfs(j, rem - c)\n            path.pop()\n\n    dfs(0, target)\n    return res",
    "file_path": "backend/algorithms/problems/39-combination-sum/solution.py",
    "intuition": "- DFS with backtracking\n    - Sort candidates, try each starting from current index (to allow reuse), prune if number exceeds remaining target, and record the path when rem == 0.",
    "kind": "function",
    "label": "def combination_sum(candidates: list[int], target: int) -> list[list[int]]",
    "name": "combination_sum",
    "returns": {
      "label": "list[list[int]]",
      "summary": "List of all unique combinations that sum to target"
    },
    "time_complexity": "O(2^n)\nWorst-case exponential in number of combinations explored, but pruning (if c > rem: break) reduces branches significantly."
  },
  "problems.39-combination-sum.solution:combination_sum.candidates": {
    "kind": "parameter",
    "label": "candidates: list[int]",
    "name": "candidates",
    "summary": "List of candidate numbers"
  },
  "problems.39-combination-sum.solution:combination_sum.target": {
    "kind": "parameter",
    "label": "target: int",
    "name": "target",
    "summary": "Target sum to achieve"
  },
  "problems.416-partition-equal-subset-sum.solution:canPartition": {
    "args": [
      "nums"
    ],
    "code": "def canPartition(nums: list[int]) -> bool:\n\n    if (total := sum(nums)) & 1:\n        return False\n\n    nums.sort(reverse=True)\n    if nums[0] > (target := total // 2):\n        return False\n\n    memo = {}\n\n    def dp(i: int, r: int) -> bool:\n        if r == 0:\n            return True\n        if r < 0 or i == len(nums):\n            return False\n        if (k := (i, r)) not in memo:\n            memo[k] = dp(i + 1, r - nums[i]) or dp(i + 1, r)\n        return memo[k]\n\n    return dp(0, target)",
    "expressions": {
      "(total := sum(nums)) & 1": "odd sum"
    },
    "file_path": "backend/algorithms/problems/416-partition-equal-subset-sum/solution.py",
    "intuition": "- This is the **0/1 Knapsack** decision problem in disguise:\n    - The problem transforms from partitioning an array into a simpler question:             can a subset of \"items\" (`nums`) perfectly fill a \"knapsack\" with capacity `total_sum // 2`?             Each item's weight is equal to its value.",
    "kind": "function",
    "label": "def canPartition(nums: list[int]) -> bool",
    "name": "canPartition",
    "returns": {
      "label": "bool"
    },
    "time_complexity": "O(n * target)"
  },
  "problems.416-partition-equal-subset-sum.solution:canPartition.(total := sum(nums)) & 1": {
    "kind": "expression",
    "name": "(total := sum(nums)) & 1",
    "summary": "odd sum"
  },
  "problems.42-trapping-rain-water.forward-fill-with-tail-closure:trapping_rain_water": {
    "args": [
      "height"
    ],
    "code": "def trapping_rain_water(height: list[int]) -> int:\n    l = trapped = 0\n\n    for r, h in enumerate(height):\n        if h >= (wall := height[l]):\n            for v in height[l:r]:\n                trapped += wall - v\n            l = r\n\n    maxr = height[-1]\n    for v in reversed(height[l:]):\n        maxr = max(maxr, v)\n        trapped += max(0, maxr - v)\n\n    return trapped",
    "file_path": "backend/algorithms/problems/42-trapping-rain-water/forward-fill-with-tail-closure.py",
    "kind": "function",
    "label": "def trapping_rain_water(height: list[int]) -> int",
    "name": "trapping_rain_water",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n)"
  },
  "problems.42-trapping-rain-water.two-pointer:trap": {
    "args": [
      "height"
    ],
    "code": "def trap(height: list[int]) -> int:\n    l, r = 0, len(height) - 1\n    lmax = rmax = water = 0\n\n    while l < r:\n        if (hl:=height[l]) < (hr:=height[r]):\n            lmax = max(lmax, hl)\n            water += lmax - hl\n            l += 1\n        else:\n            rmax = max(rmax, hr)\n            water += rmax - hr\n            r -= 1\n    return water",
    "file_path": "backend/algorithms/problems/42-trapping-rain-water/two-pointer.py",
    "intuition": "- Water trapped above each bar depends on the smaller of the tallest walls to its left and right:\n    - By keeping two pointers—one at each end—and always moving the smaller side inward, we ensure that the limiting wall for that side is already known.\n        - When the left bar is shorter, we can safely compute water at left using lmax (its tallest left wall), because a taller or equal wall must exist on the right.\n        - Symmetrically, when the right bar is shorter, we compute water using rmax.\n    - This invariant guarantees every position’s water level is computed exactly once in O(n) time and O(1) space",
    "kind": "function",
    "label": "def trap(height: list[int]) -> int",
    "name": "trap",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n)"
  },
  "problems.435-non-overlapping-intervals.solution:eraseOverlapIntervals": {
    "args": [
      "intervals"
    ],
    "code": "def eraseOverlapIntervals(intervals: list[list[int]]) -> int:\n\n    intervals.sort(key=lambda x: x[1])\n    end, count = intervals[0][1], 0\n\n    for s, e in intervals[1:]:\n        if s < end:\n            count += 1\n        else:\n            end = e\n    return count",
    "file_path": "backend/algorithms/problems/435-non-overlapping-intervals/solution.py",
    "intuition": "- This greedy solution is correct because sorting by *[1!]end* time ensures each interval chosen leaves the most room for future ones\n    - Reasoning:\n            - After sorting by *end* time, *end* tracks the boundary of the last non-overlapping interval.\n                - If the next start `s < end`, it *[1!]overlaps* → must remove one *[1!](increment count)*.\n                - Otherwise, update `end = e` *[3!](keep this interval).*\n    - This guarantees the maximum number of non-overlapping intervals remain — equivalently, minimum removals.",
    "kind": "function",
    "label": "def eraseOverlapIntervals(intervals: list[list[int]]) -> int",
    "name": "eraseOverlapIntervals",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n log n):\n    for the sorting"
  },
  "problems.46-permutations.solution:permutations": {
    "args": [
      "nums"
    ],
    "code": "def permutations(nums: list[int]) -> list[list[int]]:\n\n    result, n = [], len(nums)\n\n    def dfs(i):\n\n        if i == n:\n            result.append(nums[:])\n        else:\n            for j in range(i, n):\n                nums[i], nums[j] = nums[j], nums[i]\n                dfs(i + 1)\n                nums[j], nums[i] = nums[i], nums[j]\n\n    dfs(0)\n    return result",
    "file_path": "backend/algorithms/problems/46-permutations/solution.py",
    "intuition": "- Recursive Tree of Choices\n    - Build permutations by choosing unused elements: At each level, try each remaining number, recurse with updated path, and backtrack to un-choose. Use used list or boolean flags to track chosen elements.",
    "kind": "function",
    "label": "def permutations(nums: list[int]) -> list[list[int]]",
    "name": "permutations",
    "returns": {
      "label": "list[list[int]]",
      "summary": "List of all possible permutations"
    },
    "space_complexity": "O(N)\nRecursion depth is N, and we store the current permutation path.",
    "time_complexity": "O(N!)\nN levels of recursion, each level explores N - depth options, total N! permutations."
  },
  "problems.46-permutations.solution:permutations.nums": {
    "kind": "parameter",
    "label": "nums: list[int]",
    "name": "nums",
    "summary": "List of integers to permute"
  },
  "problems.460-lfu-cache.solution:LFUCache": {
    "code": "class LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity    = capacity\n        self.cache       = {}\n        self.freq        = {}\n        self.buckets     = defaultdict(OrderedDict)\n        self.minfreq     = 0\n\n    def _bump(self, key: int):\n        f = self.freq[key]\n        del self.buckets[f][key]\n        if not self.buckets[f]:\n            del self.buckets[f]\n            if self.minfreq == f:\n                self.minfreq += 1\n\n        self.freq[key] +=1\n        self.buckets[f + 1][key] = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self._bump(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity <= 0:\n            return\n\n        if key in self.cache:\n            self.cache[key] = value\n            self._bump(key)\n            return\n\n        if len(self.cache) >= self.capacity:\n            old_key, _ = self.buckets[self.minfreq].popitem(last=False)\n            del self.cache[old_key]\n            del self.freq[old_key]\n\n        self.cache[key] = value\n        self.freq[key] = 1\n        self.buckets[1][key] = None\n        self.minfreq = 1",
    "file_path": "backend/algorithms/problems/460-lfu-cache/solution.py",
    "intuition": "The LFU system is more sophisticated. It tracks not just *when* a book was last used, but also *how often* it has been used.",
    "kind": "class",
    "name": "LFUCache"
  },
  "problems.460-lfu-cache.solution:LFUCache._bump": {
    "args": [
      "key"
    ],
    "code": "    def _bump(self, key: int):",
    "file_path": "backend/algorithms/problems/460-lfu-cache/solution.py",
    "kind": "method",
    "label": "def _bump(self, key: int)",
    "name": "_bump",
    "summary": "Move key from freq f to f+1."
  },
  "problems.460-lfu-cache.solution:LFUCache.get": {
    "args": [
      "key"
    ],
    "code": "    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self._bump(key)\n        return self.cache[key]",
    "file_path": "backend/algorithms/problems/460-lfu-cache/solution.py",
    "kind": "method",
    "label": "def get(self, key: int) -> int",
    "name": "get",
    "returns": {
      "label": "int"
    },
    "summary": "When an item is accessed (get or put), its frequency count is incremented, and it moves from its current frequency bucket to the next, becoming the most recent item in that new bucket. For eviction, we remove the least recently used item from the lowest frequency bucket."
  },
  "problems.460-lfu-cache.solution:LFUCache.put": {
    "args": [
      "value",
      "key"
    ],
    "code": "    def put(self, key: int, value: int) -> None:\n        if self.capacity <= 0:\n            return\n\n        if key in self.cache:\n            self.cache[key] = value\n            self._bump(key)\n            return\n\n        if len(self.cache) >= self.capacity:\n            old_key, _ = self.buckets[self.minfreq].popitem(last=False)\n            del self.cache[old_key]\n            del self.freq[old_key]\n\n        self.cache[key] = value\n        self.freq[key] = 1\n        self.buckets[1][key] = None\n        self.minfreq = 1",
    "file_path": "backend/algorithms/problems/460-lfu-cache/solution.py",
    "kind": "method",
    "label": "def put(self, key: int, value: int) -> None",
    "name": "put",
    "returns": {
      "label": "None"
    },
    "summary": "When an item is added or updated, its frequency count is set to 1, and it's added to the lowest frequency bucket. If the cache exceeds its capacity, the least recently used item from the lowest frequency bucket is removed."
  },
  "problems.498-diagonal-traverse.solution:diagonal_traverse": {
    "args": [
      "mat"
    ],
    "code": "def diagonal_traverse(mat: list[list[int]]) -> list[int]:\n    m, n = len(mat), len(mat[0])\n    res = []\n    for d in range(m + n - 1):\n        if d % 2 == 0:\n            r = min(d, m - 1)\n            c = d - r\n            while r >= 0 and c < n:\n                res.append(mat[r][c])\n                r -= 1\n                c += 1\n        else:\n            c = min(d, n - 1)\n            r = d - c\n            while c >= 0 and r < m:\n                res.append(mat[r][c])\n                r += 1\n                c -= 1\n    return res",
    "file_path": "backend/algorithms/problems/498-diagonal-traverse/solution.py",
    "intuition": "- Each diagonal is defined by `r + c = d`.\n    - (note: always diagonal `r+c=d` ↗️ ,not anti-diagonal `[red!]r-c=d` ↙️)\n    - Even-indexed diagonals `( d % 2 == 0)` must be read up-right ↗️  ,\n        - so we start from the lowest valid `(r,c)`.\n    - Odd-indexed diagonals go down-left ↙️,\n        - so we start from the rightmost valid `(r,c)`.\n    - Each diagonal is traversed once in its direction, collecting every cell exactly once.",
    "kind": "function",
    "label": "def diagonal_traverse(mat: list[list[int]]) -> list[int]",
    "name": "diagonal_traverse",
    "returns": {
      "label": "list[int]"
    },
    "time_complexity": "O(m x n):\n    Every matrix cell is visited exactly once across all diagonals."
  },
  "problems.50-pow.solution:myPow": {
    "args": [
      "n",
      "x"
    ],
    "code": "def myPow(x: float, n: int) -> float:\n    if n == 0: return 1.0\n    if n < 0: return 1.0 / myPow(x, -n)\n\n    result, base = 1.0, x\n    while n:\n        if n & 1:\n            result *= base\n        base *= base\n        n >>= 1     \n    return result",
    "expressions": {
      "base *= base": "move to next power-of-two (`x` → `x²` → `x⁴` → `x⁸` …)",
      "if n < 0": "return 1 / myPow(x, -n)   (handle negative exponent)",
      "n & 1": "check lowest bit          (1 → use base)",
      "n >>= 1": "bitwise right shift; same effect as `n //= 2` for `n ≥ 0`"
    },
    "file_path": "backend/algorithms/problems/50-pow/solution.py",
    "intuition": "- Compute $(x^n)$ using **binary exponentiation**:\n    - Each iteration inspects the lowest bit of n:\n        - if the bit is 1 → include the current power (base) in the result,\n        - square the base for the next power-of-two,\n        - shift n right to move to the next bit.\n    - For negative n, take the reciprocal and reuse the same logic.\n\n    - Example:\n        - x = 2, n = 13 → 13 (1101₂):\n            - bit 1 → multiply 2¹\n            - bit 0 → skip 2²\n            - bit 1 → multiply 2⁴\n            - bit 1 → multiply 2⁸\n        - Result = 2¹ × 2⁴ × 2⁸ = 8192",
    "kind": "function",
    "label": "def myPow(x: float, n: int) -> float",
    "name": "myPow",
    "returns": {
      "label": "float",
      "summary": "x raised to the power n."
    },
    "time_complexity": "O(log n):\none step per binary digit of n, (The number of bits in n is *$\\lfloor \\log₂ n \\rfloor + 1$* — fixed by the value of n itself.\nIt doesn’t matter whether those bits are 0 or 1; the loop processes one bit per iteration, so the total work is always proportional to the bit-length of n, not the bit pattern.)"
  },
  "problems.50-pow.solution:myPow.base *= base": {
    "kind": "expression",
    "name": "base *= base",
    "summary": "move to next power-of-two (`x` → `x²` → `x⁴` → `x⁸` …)"
  },
  "problems.50-pow.solution:myPow.if n < 0": {
    "kind": "expression",
    "name": "if n < 0",
    "summary": "return 1 / myPow(x, -n)   (handle negative exponent)"
  },
  "problems.50-pow.solution:myPow.n": {
    "kind": "parameter",
    "label": "n: int",
    "name": "n",
    "summary": "exponent (int)"
  },
  "problems.50-pow.solution:myPow.n & 1": {
    "kind": "expression",
    "name": "n & 1",
    "summary": "check lowest bit          (1 → use base)"
  },
  "problems.50-pow.solution:myPow.n >>= 1": {
    "kind": "expression",
    "name": "n >>= 1",
    "summary": "bitwise right shift; same effect as `n //= 2` for `n ≥ 0`"
  },
  "problems.50-pow.solution:myPow.x": {
    "kind": "parameter",
    "label": "x: float",
    "name": "x",
    "summary": "base (float)"
  },
  "problems.51-n-queens.solution:n_queens": {
    "args": [
      "n"
    ],
    "code": "def n_queens(n: int) -> list[list[str]]:\n\n    result, board = [], [[\".\"] * n for _ in range(n)]\n\n    cols, diag1, diag2 = set(), set(), set()\n\n    def dfs(row: int):\n        if row == n:\n            result.append([\"\".join(r) for r in board])\n            return\n\n        for col in range(n):\n            if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                continue\n\n            board[row][col] = \"Q\"\n\n            cols.add(col)\n            diag1.add(row - col)\n            diag2.add(row + col)\n\n            dfs(row + 1)\n\n            board[row][col] = \".\"\n            cols.remove(col)\n            diag1.remove(row - col)\n            diag2.remove(row + col)\n\n    dfs(0)\n    return result",
    "expressions": {
      "`board[row][col] = \".\"`": "Remove the queen (backtrack)",
      "`board[row][col] = \"Q\"`": "Place the queen",
      "`continue`": "Skip invalid positions",
      "`dfs(row + 1)`": "Recurse to the next row"
    },
    "file_path": "backend/algorithms/problems/51-n-queens/solution.py",
    "intuition": "- Backtrack with State Tracking ♛\n    - Place one queen per row. Track blocked columns, diagonals: Valid placement → recurse to next row, Invalid → skip, After recursion, remove queen to try next column. Track state using: `cols` for columns, `diag1` for main diagonal *↘* `row - col`, `diag2` for anti-diagonal *↙* `row + col`.",
    "kind": "function",
    "label": "def n_queens(n: int) -> list[list[str]]",
    "name": "n_queens",
    "returns": {
      "label": "list[list[str]]",
      "summary": "List of all valid queen placements"
    },
    "time_complexity": "O(N!)\nfirst row: N choices, second row: N-1 choices, total permutations = N!, pruning drastically reduces actual recursion tree.",
    "variables": [
      "cols",
      "diag1",
      "diag2"
    ]
  },
  "problems.51-n-queens.solution:n_queens.`board[row][col] = \".\"`": {
    "kind": "expression",
    "name": "`board[row][col] = \".\"`",
    "summary": "Remove the queen (backtrack)"
  },
  "problems.51-n-queens.solution:n_queens.`board[row][col] = \"Q\"`": {
    "kind": "expression",
    "name": "`board[row][col] = \"Q\"`",
    "summary": "Place the queen"
  },
  "problems.51-n-queens.solution:n_queens.`continue`": {
    "kind": "expression",
    "name": "`continue`",
    "summary": "Skip invalid positions"
  },
  "problems.51-n-queens.solution:n_queens.`dfs(row + 1)`": {
    "kind": "expression",
    "name": "`dfs(row + 1)`",
    "summary": "Recurse to the next row"
  },
  "problems.51-n-queens.solution:n_queens.cols": {
    "kind": "variable",
    "name": "cols",
    "summary": "Columns where queens are placed"
  },
  "problems.51-n-queens.solution:n_queens.diag1": {
    "kind": "variable",
    "name": "diag1",
    "summary": "The main diagonal where queens are placed (↘) `r - c`"
  },
  "problems.51-n-queens.solution:n_queens.diag2": {
    "kind": "variable",
    "name": "diag2",
    "summary": "The anti-diagonal where queens are placed (↙) `r + c`"
  },
  "problems.51-n-queens.solution:n_queens.n": {
    "kind": "parameter",
    "label": "n: int",
    "name": "n",
    "summary": "Size of the chessboard (n x n)"
  },
  "problems.518-coin-change-ii.solution:coin_change_II": {
    "args": [
      "amount",
      "coins"
    ],
    "code": "def coin_change_II(amount: int, coins: list[int]) -> int:\n    memo, n = {}, len(coins)\n\n    def dp(c, amount):\n        if amount == 0:\n            return 1\n        if amount < 0 or c == n:\n            return 0\n        if (c, amount) not in memo:\n            memo[c, amount] = dp(c, amount - coins[c]) + dp(c + 1, amount)\n        return memo[c, amount]\n\n    return dp(0, amount)",
    "file_path": "backend/algorithms/problems/518-coin-change-ii/solution.py",
    "intuition": "- Paradigm: This is a classic **Unbounded Knapsack** counting problem.\n\n    - Insight: To count *combinations* without overcounting *permutations* (`1+2` vs `2+1`), the DP imposes a strict processing order on the coins. This ensures that combinations are always built in the same sequence (e.g., using smaller denomination coins before larger ones), elegantly eliminating duplicates.",
    "kind": "function",
    "label": "def coin_change_II(amount: int, coins: list[int]) -> int",
    "name": "coin_change_II",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n * amount)\nwhere n is the number of coins and amount is the target amount."
  },
  "problems.523-continuous-subarray-sum.solution:checkSubarraySumIsMultipleOfK": {
    "args": [
      "k",
      "segments"
    ],
    "code": "def checkSubarraySumIsMultipleOfK(segments: list[int], k: int) -> bool:\n\n    remainder_idx = {0: -1}\n    prefix_remainder = 0\n\n    for i, segment in enumerate(segments):\n        prefix_remainder = (prefix_remainder + segment) % k\n        if prefix_remainder in remainder_idx:\n            if i - remainder_idx[prefix_remainder] > 1:\n                return True\n        else:\n            remainder_idx[prefix_remainder] = i\n    return False",
    "file_path": "backend/algorithms/problems/523-continuous-subarray-sum/solution.py",
    "kind": "function",
    "label": "def checkSubarraySumIsMultipleOfK(segments: list[int], k: int) -> bool",
    "name": "checkSubarraySumIsMultipleOfK",
    "returns": {
      "label": "bool",
      "summary": "True if such a subarray exists, False otherwise."
    }
  },
  "problems.523-continuous-subarray-sum.solution:checkSubarraySumIsMultipleOfK.k": {
    "kind": "parameter",
    "label": "k: int",
    "name": "k",
    "summary": "The divisor."
  },
  "problems.523-continuous-subarray-sum.solution:checkSubarraySumIsMultipleOfK.segments": {
    "kind": "parameter",
    "label": "segments: list[int]",
    "name": "segments",
    "summary": "List of integers representing trip segments."
  },
  "problems.525-contiguous-array.solution:findMaxLengthOfBalancedSubarray": {
    "args": [
      "segments"
    ],
    "code": "def findMaxLengthOfBalancedSubarray(segments: list[int]) -> int:\n\n    normalized_segments = [1 if num > 0 else -1 for num in segments]\n    return maxSizeSubarraySumEqualsK(normalized_segments, 0)",
    "file_path": "backend/algorithms/problems/525-contiguous-array/solution.py",
    "kind": "function",
    "label": "def findMaxLengthOfBalancedSubarray(segments: list[int]) -> int",
    "name": "findMaxLengthOfBalancedSubarray",
    "returns": {
      "label": "int",
      "summary": "The length of the longest balanced subarray."
    }
  },
  "problems.525-contiguous-array.solution:findMaxLengthOfBalancedSubarray.segments": {
    "kind": "parameter",
    "label": "segments: list[int]",
    "name": "segments",
    "summary": "List of integers (positive for forward, negative/zero for backward)."
  },
  "problems.528-random-pick-with-weight.solution:Solution.__init__": {
    "args": [
      "w"
    ],
    "code": "    def __init__(self, w: list[int]):\n        self.prefix, total = [], 0\n        for x in w:\n            total += x\n            self.prefix.append(total)\n        self.total = total",
    "file_path": "backend/algorithms/problems/528-random-pick-with-weight/solution.py",
    "intuition": "- Prefix sums:\n        - Each weight `w[i]` represents how \"wide\" index `i` should be on a number line.\n        - Build prefix sums so that:\n            - `prefix[i] = w[0] + ... + w[i]`\n        - This turns the array of weights into contiguous segments on [1, total].\n        - Example:\n            - w = [2, 5, 3] -> `prefix = [2, 7, 10]`\n            - Segments:\n                - 1-2   → index 0\n                - 3-7   → index 1\n                - 8-10  → index 2\n        - To pick an index with probability proportional to its weight:\n            - Draw a random integer `target ∈ [1, total]`.\n            - Find the first `prefix[i] ≥ target`.\n            - That `i` is the index whose segment contains `target`.\n        - Bigger weight → bigger segment → higher chance of being hit.",
    "kind": "method",
    "label": "def __init__(self, w: list[int])",
    "name": "__init__",
    "time_complexity": "O(n)"
  },
  "problems.528-random-pick-with-weight.solution:Solution.pickIndex": {
    "args": [
      "self"
    ],
    "code": "    def pickIndex(self) -> int:\n        return bisect.bisect_left(self.prefix, random.randint(1, self.total))",
    "expressions": {
      "bisect.bisect_left": "find the first index such that `prefix[index] >= The random drawn integer`",
      "random.randint(1, self.total)": "pick a random integer in [1, total]"
    },
    "file_path": "backend/algorithms/problems/528-random-pick-with-weight/solution.py",
    "kind": "method",
    "label": "def pickIndex(self) -> int",
    "name": "pickIndex",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(log n)"
  },
  "problems.528-random-pick-with-weight.solution:Solution.pickIndex.bisect.bisect_left": {
    "kind": "expression",
    "name": "bisect.bisect_left",
    "summary": "find the first index such that `prefix[index] >= The random drawn integer`"
  },
  "problems.528-random-pick-with-weight.solution:Solution.pickIndex.random.randint(1, self.total)": {
    "kind": "expression",
    "name": "random.randint(1, self.total)",
    "summary": "pick a random integer in [1, total]"
  },
  "problems.53-maximum-subarray.solution:maximum_subarray": {
    "args": [
      "nums"
    ],
    "code": "def maximum_subarray(nums: list[int]) -> int:\n    max_sum = curr_sum = float(\"-inf\")\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum",
    "expressions": {
      "curr_sum = max(num, curr_sum + num)": "If extending the previous subarray lowers the sum (`num > curr_sum + num `), start a new subarray from the current element"
    },
    "file_path": "backend/algorithms/problems/53-maximum-subarray/solution.py",
    "intuition": "- This is essentially *Kadane's Algorithm*:\n        - Kadane’s Algorithm is an $O(n)$ dynamic programming method for finding the maximum subarray sum in a list of integers (contiguous elements).\n        - Core idea:\n            - Keep track of the best sum ending at the current position\n            - If adding the current number hurts the sum, start fresh from the current number\n            - Track the overall maximum as you go\n\n\n    - Deep Dive: SRT BOT:\n        - Subproblem: `dp(i) = max(nums[i], nums[i] + dp(i-1))`\n        - Relate: `dp(i)` depends only on `dp(i-1)`\n        - Topological order: increasing `i`\n        - Base case: `dp(0) = nums[0]`\n        - Original problem: `max(dp(i))` over all i\n        - Time complexity: O(n)\n        - Space complexity: O(1)",
    "kind": "function",
    "label": "def maximum_subarray(nums: list[int]) -> int",
    "name": "maximum_subarray",
    "returns": {
      "label": "int",
      "summary": "int: Maximum subarray sum"
    },
    "variables": [
      "curr_sum",
      "max_sum"
    ]
  },
  "problems.53-maximum-subarray.solution:maximum_subarray.curr_sum": {
    "kind": "variable",
    "name": "curr_sum",
    "summary": "the best subarray sum ending at the current index"
  },
  "problems.53-maximum-subarray.solution:maximum_subarray.curr_sum = max(num, curr_sum + num)": {
    "kind": "expression",
    "name": "curr_sum = max(num, curr_sum + num)",
    "summary": "If extending the previous subarray lowers the sum (`num > curr_sum + num `), start a new subarray from the current element"
  },
  "problems.53-maximum-subarray.solution:maximum_subarray.max_sum": {
    "kind": "variable",
    "name": "max_sum",
    "summary": "the best subarray sum found so far"
  },
  "problems.53-maximum-subarray.solution:maximum_subarray.nums": {
    "kind": "parameter",
    "label": "nums: list[int]",
    "name": "nums",
    "summary": "list of integers (can include negatives)"
  },
  "problems.54-spiral-matrix.solution:spiral_matrix": {
    "args": [
      "matrix"
    ],
    "code": "def spiral_matrix(matrix: list[list[int]]) -> list[int]:\n    res = []\n    top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n\n    while top <= bottom and left <= right:\n\n        res += matrix[top][left : right + 1]\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            res += matrix[bottom][left : right + 1][::-1]\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res",
    "file_path": "backend/algorithms/problems/54-spiral-matrix/solution.py",
    "intuition": "- A spiral is formed by peeling the matrix layer by layer.\n    - Each layer has four edges:\n        - `→` top row  (left → right)\n        - `↓` right col (top → bottom)\n        - `←` bottom row (right → left)\n        - `↑` left col  (bottom → top)\n    - After traversing each edge, the boundaries (top, bottom, left, right) shrink inward. The process repeats until the boundaries cross        (Every cell is visited exactly once).",
    "kind": "function",
    "label": "def spiral_matrix(matrix: list[list[int]]) -> list[int]",
    "name": "spiral_matrix",
    "returns": {
      "label": "list[int]"
    },
    "time_complexity": "O(m x n):\n    Every cell is visited exactly once."
  },
  "problems.542-01-matrix.solution:zero_one_matrix": {
    "args": [
      "mat"
    ],
    "code": "def zero_one_matrix(mat: list[list[int]]) -> list[list[int]]:\n    m, n = len(mat), len(mat[0])\n    dist = [[-1] * n for _ in range(m)]\n    q = deque()\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and dist[ni][nj] < 0:\n                dist[ni][nj] = dist[i][j] + 1\n                q.append((ni, nj))\n    return dist",
    "file_path": "backend/algorithms/problems/542-01-matrix/solution.py",
    "intuition": "- Multi-Source BFS from the Target 🎯:\n    - Instead of starting a separate BFS from every `1` to find the nearest `0` (which would be slow), this approach inverts the problem. It starts a single, **multi-source BFS from all `0`s simultaneously**. The level of the BFS at which a cell is reached is, by definition, its shortest distance to any `0`. This \"start from the answer\" strategy is a powerful technique for shortest path problems.",
    "kind": "function",
    "label": "def zero_one_matrix(mat: list[list[int]]) -> list[list[int]]",
    "name": "zero_one_matrix",
    "returns": {
      "label": "list[list[int]]"
    },
    "time_complexity": "O(m * n):\nwhere m and n are the dimensions of the grid.\nEvery cell is enqueued and processed exactly once, making this the optimal solution."
  },
  "problems.547-number-of-provinces.solution:Solution.findCircleNum": {
    "args": [
      "isConnected"
    ],
    "code": "    def findCircleNum(self, isConnected: list[list[int]]) -> int:\n        p = list(range(n := len(isConnected)))\n\n        def union(a, b):\n            p[find(a)] = find(b)\n\n        def find(x):\n            while x != p[x]:\n                p[x] = p[p[x]]\n                x = p[x]\n            return x\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j]:\n                    union(i, j)\n\n        return sum(i == find(i) for i in range(n))",
    "expressions": {
      "p = list(range(n := len(isConnected)))": "Each node starts as its own parent (each city = its own province)",
      "p[find(i)] = find(j)": "Whenever two cities are connected (`isConnected[i][j]`), we union their groups by linking one root to the other.",
      "p[x] = p[p[x]]": "flattens the chain → next time find is faster",
      "sum(i == find(i) for i in range(n))": "Counts how many nodes are their own root — each root = one province.",
      "while x != p[x]": "This walks up the chain until it reaches the root."
    },
    "file_path": "backend/algorithms/problems/547-number-of-provinces/solution.py",
    "intuition": "- Union-Find:\n    - We treat each city as a node\n    - If two cities are connected (directly or indirectly), they belong to the same set or group\n    - Union-Find (or Disjoint Set Union, DSU) keeps track of which node belongs to which group",
    "kind": "method",
    "label": "def findCircleNum(self, isConnected: list[list[int]]) -> int",
    "name": "findCircleNum",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n^2):\n*Building connections:* *O(n^2)*\n*Each union/find:* amortized *O(α(n))*\n    *α(n) is the inverse Ackermann function (~constant)*"
  },
  "problems.547-number-of-provinces.solution:Solution.findCircleNum.find": {
    "args": [
      "x"
    ],
    "code": "        def find(x):\n            while x != p[x]:\n                p[x] = p[p[x]]\n                x = p[x]\n            return x",
    "file_path": "backend/algorithms/problems/547-number-of-provinces/solution.py",
    "kind": "method",
    "label": "def find(x)",
    "name": "find",
    "summary": "finds the representative (*root*) of the set that *x* belongs to,\n*The representative is just one chosen “leader” of each group*"
  },
  "problems.547-number-of-provinces.solution:Solution.findCircleNum.p = list(range(n := len(isConnected)))": {
    "kind": "expression",
    "name": "p = list(range(n := len(isConnected)))",
    "summary": "Each node starts as its own parent (each city = its own province)"
  },
  "problems.547-number-of-provinces.solution:Solution.findCircleNum.p[find(i)] = find(j)": {
    "kind": "expression",
    "name": "p[find(i)] = find(j)",
    "summary": "Whenever two cities are connected (`isConnected[i][j]`), we union their groups by linking one root to the other."
  },
  "problems.547-number-of-provinces.solution:Solution.findCircleNum.p[x] = p[p[x]]": {
    "kind": "expression",
    "name": "p[x] = p[p[x]]",
    "summary": "flattens the chain → next time find is faster"
  },
  "problems.547-number-of-provinces.solution:Solution.findCircleNum.sum(i == find(i) for i in range(n))": {
    "kind": "expression",
    "name": "sum(i == find(i) for i in range(n))",
    "summary": "Counts how many nodes are their own root — each root = one province."
  },
  "problems.547-number-of-provinces.solution:Solution.findCircleNum.union": {
    "args": [
      "a",
      "b"
    ],
    "code": "        def union(a, b):\n            p[find(a)] = find(b)",
    "file_path": "backend/algorithms/problems/547-number-of-provinces/solution.py",
    "kind": "method",
    "label": "def union(a, b)",
    "name": "union",
    "summary": "merges the sets containing `a` and `b`"
  },
  "problems.547-number-of-provinces.solution:Solution.findCircleNum.while x != p[x]": {
    "kind": "expression",
    "name": "while x != p[x]",
    "summary": "This walks up the chain until it reaches the root."
  },
  "problems.560-subarray-sum-equals-k.solution:subarraySumEqualsK": {
    "args": [
      "k",
      "segments"
    ],
    "code": "def subarraySumEqualsK(segments: list[int], k: int) -> int:\n\n    marker_frequency = defaultdict(int, {0: 1})\n    prefix_sum = count = 0\n\n    for segment in segments:\n        prefix_sum += segment\n        count += marker_frequency[prefix_sum - k]\n        marker_frequency[prefix_sum] += 1\n\n    return count",
    "file_path": "backend/algorithms/problems/560-subarray-sum-equals-k/solution.py",
    "kind": "function",
    "label": "def subarraySumEqualsK(segments: list[int], k: int) -> int",
    "name": "subarraySumEqualsK",
    "returns": {
      "label": "int",
      "summary": "The count of subarrays with sum == k."
    }
  },
  "problems.560-subarray-sum-equals-k.solution:subarraySumEqualsK.k": {
    "kind": "parameter",
    "label": "k: int",
    "name": "k",
    "summary": "Target sum."
  },
  "problems.560-subarray-sum-equals-k.solution:subarraySumEqualsK.segments": {
    "kind": "parameter",
    "label": "segments: list[int]",
    "name": "segments",
    "summary": "List of integers representing trip segments."
  },
  "problems.64-minimum-path-sum.bottom-up:minPathSum": {
    "args": [
      "grid"
    ],
    "code": "def minPathSum(grid: list[list[int]]) -> int:\n    r, c = len(grid), len(grid[0])\n    dp = [float(\"inf\")] * (c + 1); dp[1] = 0\n    for i in range(r):\n        for j in range(1, c + 1):\n            dp[j] = min(dp[j], dp[j - 1]) + grid[i][j - 1]\n    return dp[c]",
    "expressions": {
      "min(dp[j], dp[j - 1]) + grid[i][j - 1]'=  update current cell": "min(top, left) + cell value"
    },
    "file_path": "backend/algorithms/problems/64-minimum-path-sum/bottom-up.py",
    "intuition": "- Deep Dive: 2D to 1D:\n        - In the 2D DP table, each cell depends only on its top and left neighbors:\n        - `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`\n        - That means to compute row i, you only need:\n            - the current row's left value (`dp[i][j-1]`), and\n            - the previous row's value at the same column (`dp[i-1][j]`).\n        - So you can compress the table into one list of length c (number of columns):\n            - `dp[j]` keeps the current min path sum at column j (effectively `dp[i][j]`),\n            - `dp[j-1]` is the left cell,\n            - and as you move row by row, `dp[j]` from the previous iteration serves as the top cell.",
    "kind": "function",
    "label": "def minPathSum(grid: list[list[int]]) -> int",
    "name": "minPathSum",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(r * c)",
    "variables": [
      "dp"
    ]
  },
  "problems.64-minimum-path-sum.bottom-up:minPathSum.dp": {
    "kind": "variable",
    "name": "dp",
    "summary": "dp has one extra slot (index 0) as a sentinel = ∞ to avoid boundary checks . `dp[j]` = min path sum to reach current cell in column `j-1`"
  },
  "problems.64-minimum-path-sum.bottom-up:minPathSum.min(dp[j], dp[j - 1]) + grid[i][j - 1]'=  update current cell": {
    "kind": "expression",
    "name": "min(dp[j], dp[j - 1]) + grid[i][j - 1]'=  update current cell",
    "summary": "min(top, left) + cell value"
  },
  "problems.64-minimum-path-sum.top-down:minPathSum": {
    "args": [
      "grid"
    ],
    "code": "def minPathSum(grid: list[list[int]]) -> int:\n    r, c, memo = len(grid), len(grid[0]), {}\n    def dp(i, j):\n        if i == r - 1 and j == c - 1: return grid[i][j]\n        if i >= r or j >= c: return float(\"inf\")\n        if (k := (i, j)) not in memo:\n            memo[k] = grid[i][j] + min(dp(i + 1, j), dp(i, j + 1))\n        return memo[k]\n    return dp(0, 0)",
    "file_path": "backend/algorithms/problems/64-minimum-path-sum/top-down.py",
    "kind": "function",
    "label": "def minPathSum(grid: list[list[int]]) -> int",
    "name": "minPathSum",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(r * c)"
  },
  "problems.642-design-search-autocomplete-system.solution:AutocompleteSystem.__init__": {
    "args": [
      "times",
      "sentences"
    ],
    "code": "    def __init__(self, sentences: list[str], times: list[int]):\n        self.root = TrieNode()                 \n        self.freq = defaultdict(int)          \n        self.cur: TrieNode | None = self.root  \n        self.buf = \"\"                          \n        for s, t in zip(sentences, times):\n            self._add(s, t)",
    "file_path": "backend/algorithms/problems/642-design-search-autocomplete-system/solution.py",
    "instance_attributes": [
      "root",
      "freq",
      "cur",
      "buf"
    ],
    "kind": "method",
    "label": "def __init__(self, sentences: list[str], times: list[int])",
    "name": "__init__"
  },
  "problems.642-design-search-autocomplete-system.solution:AutocompleteSystem._update_hot": {
    "args": [
      "node",
      "s"
    ],
    "code": "    def _update_hot(self, node: TrieNode, s: str) -> None:\n        if s not in node.hot:\n            node.hot.append(s)\n        node.hot.sort(key=lambda x: (-self.freq[x], x))\n        if len(node.hot) > 3:\n            node.hot.pop()",
    "expressions": {
      "(-self.freq[x], x)": "sorts by:\n            - Higher frequency first (using -freq to invert Python's ascending sort)\n            - Lexicographically smaller sentence on ties"
    },
    "file_path": "backend/algorithms/problems/642-design-search-autocomplete-system/solution.py",
    "kind": "method",
    "label": "def _update_hot(self, node: TrieNode, s: str) -> None",
    "name": "_update_hot",
    "returns": {
      "label": "None"
    }
  },
  "problems.642-design-search-autocomplete-system.solution:AutocompleteSystem._update_hot.(-self.freq[x], x)": {
    "kind": "expression",
    "name": "(-self.freq[x], x)",
    "summary": "sorts by:\n            - Higher frequency first (using -freq to invert Python's ascending sort)\n            - Lexicographically smaller sentence on ties"
  },
  "problems.642-design-search-autocomplete-system.solution:AutocompleteSystem.buf": {
    "kind": "attribute",
    "name": "buf",
    "summary": "current sentence being typed"
  },
  "problems.642-design-search-autocomplete-system.solution:AutocompleteSystem.cur": {
    "kind": "attribute",
    "name": "cur",
    "summary": "current node while typing"
  },
  "problems.642-design-search-autocomplete-system.solution:AutocompleteSystem.freq": {
    "kind": "attribute",
    "name": "freq",
    "summary": "global frequencies of full sentences"
  },
  "problems.642-design-search-autocomplete-system.solution:AutocompleteSystem.root": {
    "kind": "attribute",
    "name": "root",
    "summary": "Trie root"
  },
  "problems.69-sqrt.newtons-method:mySqrt": {
    "args": [
      "x"
    ],
    "code": "def mySqrt(x: int) -> int:\n\n    if x < 2: return x\n    r = x\n    while r * r > x:\n        r = (r + x // r) // 2\n    return r",
    "expressions": {
      "(r + x // r) // 2": "Integer form of Newton’s update — averages the overestimate (r) and the underestimate (x//r)",
      "r * r > x": "Loop continues while r is an overestimate of √x"
    },
    "file_path": "backend/algorithms/problems/69-sqrt/newtons-method.py",
    "intuition": "- We need the integer part of √x:\n        - Start with a guess `r = x`.\n            - If `r` is **too large**, `r²` exceeds `x`.\n            - Dividing `x // r` gives a value **too small**, since dividing by something too big shrinks the result.\n            - The true √x lies **between** these two — `x//r` and `r`.\n            - Averaging them, $r_{\\text{new}} = \\left\\lfloor \\frac{r + \\lfloor x / r \\rfloor}{2} \\right\\rfloor$,\n            - moves the guess to the midpoint, cutting the error sharply.\n        - Each step refines the balance:\n            - if `r² > x`, the average drops lower;\n            - once `r² ≤ x`, we stop.\n        - This “balance-and-refine” loop homes in on √x extremely fast — often in under 6–7 steps.\n\n    - Correctness follows from the invariant:\n        - √x always remains between `x//r` and `r`.\n            - Since `r² > x ⇒ r > √x ⇒ √x > x/r ⇒ x//r ≤ √x < r`.\n            - The update average stays inside that interval: *$x//r ≤ r_{\\text{new}} < r$*,\n            - ensuring `r` decreases but never falls below √x.\n            - Because r strictly drops while staying ≥ 1, the loop must stop when `r² ≤ x`.\n            - At that point, r is the largest integer with `r² ≤ x`, i.e. ⌊√x⌋.",
    "kind": "function",
    "label": "def mySqrt(x: int) -> int",
    "name": "mySqrt",
    "returns": {
      "label": "int",
      "summary": "The floor of √x."
    },
    "time_complexity": "O(log x) iterations in the worst case, typically constant for 32-bit inputs.\nEach update:\n$$r_{\\text{new}} = \\frac{r + x//r}{2}$$\nhalves the relative error — the method shows **quadratic convergence**:\n$$E_{k+1} ≈ c·E_k^2$$\nmeaning the number of correct digits doubles each step.\nSpace is constant, storing only `x` and `r`.",
    "variables": [
      "r"
    ]
  },
  "problems.69-sqrt.newtons-method:mySqrt.(r + x // r) // 2": {
    "kind": "expression",
    "name": "(r + x // r) // 2",
    "summary": "Integer form of Newton’s update — averages the overestimate (r) and the underestimate (x//r)"
  },
  "problems.69-sqrt.newtons-method:mySqrt.r": {
    "kind": "variable",
    "name": "r",
    "summary": "Current approximation of √x, refined each step"
  },
  "problems.69-sqrt.newtons-method:mySqrt.r * r > x": {
    "kind": "expression",
    "name": "r * r > x",
    "summary": "Loop continues while r is an overestimate of √x"
  },
  "problems.69-sqrt.newtons-method:mySqrt.x": {
    "kind": "parameter",
    "label": "x: int",
    "name": "x",
    "summary": "Non-negative integer to take the square root of"
  },
  "problems.713-subarray-product-less-than-k.solution:num_subarray_product_less_than_k": {
    "args": [
      "k",
      "nums"
    ],
    "code": "def num_subarray_product_less_than_k(nums: list[int], k: int) -> int:\n    if k <= 1:\n        return 0\n    product, left, count = 1, 0, 0\n    for right, num in enumerate(nums):\n        product *= num\n        while product >= k:\n            product //= nums[left]\n            left += 1\n        count += right - left + 1\n    return count",
    "file_path": "backend/algorithms/problems/713-subarray-product-less-than-k/solution.py",
    "kind": "function",
    "label": "def num_subarray_product_less_than_k(nums: list[int], k: int) -> int",
    "name": "num_subarray_product_less_than_k",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n)"
  },
  "problems.743-network-delay-time.dijkstra-b:Solution.networkDelayTime": {
    "args": [
      "times",
      "k",
      "n"
    ],
    "code": "    def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int:\n\n        adj = defaultdict(list)\n        for u, v, w in times:\n            adj[u].append((v, w))\n\n        pq, finalized, time = [(0, k)], set(), 0\n\n        while pq:\n            t, node = heappop(pq)\n            if node in finalized:\n                continue\n            finalized.add(node)\n            time = t\n\n            for neighbor, travel_time in adj[node]:\n                if neighbor not in finalized:\n                    heappush(pq, (time + travel_time, neighbor))\n\n        return time if len(finalized) == n else -1",
    "file_path": "backend/algorithms/problems/743-network-delay-time/dijkstra-b.py",
    "intuition": "- The signal starts at node k and spreads through the network.\n    - Each time we pop a node from the heap, we know this is the earliest\n    - possible moment the signal can reach it — its shortest travel time.\n    - We mark it as finalized and push its neighbors with updated times.\n    - When all nodes are finalized, the last recorded time is the total delay.\n    - If not all nodes can be reached, return -1.",
    "kind": "method",
    "label": "def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int",
    "name": "networkDelayTime",
    "returns": {
      "label": "int",
      "summary": "minimum time for a signal starting at node `k` to reach *all* nodes or -1 if impossible"
    },
    "time_complexity": "O(E log V):\nE is the number of edges (the length of the input list `times`)\nV is the number of vertices (the number of nodes `n`)\n\nBy substituting these into the standard Dijkstra complexity formula, O(E log V), you get *O(len(times)logn)*."
  },
  "problems.743-network-delay-time.dijkstra-b:Solution.networkDelayTime.k": {
    "kind": "parameter",
    "label": "k: int",
    "name": "k",
    "summary": "starting node"
  },
  "problems.743-network-delay-time.dijkstra-b:Solution.networkDelayTime.times": {
    "kind": "parameter",
    "label": "times: list[list[int]]",
    "name": "times",
    "summary": "list of lists of integers representing the edges and their weights"
  },
  "problems.743-network-delay-time.dijkstra:Solution.networkDelayTime": {
    "args": [
      "k",
      "times",
      "n"
    ],
    "code": "    def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int:\n\n        g = {i: [] for i in range(1, n + 1)}\n        for u, v, w in times:\n            g[u].append((w, v))\n\n        dist = {i: float(\"inf\") for i in g}\n        dist[k] = 0\n\n        pq = [(0, k)]\n\n        while pq:\n            d, u = heappop(pq)\n            if d > dist[u]: continue\n\n\n            for w, v in g[u]:\n                if (nd := d + w) < dist[v]:\n                    dist[v] = nd\n                    heappush(pq, (nd, v))\n\n        return ans if (ans := max(dist.values())) < float(\"inf\") else -1",
    "file_path": "backend/algorithms/problems/743-network-delay-time/dijkstra.py",
    "intuition": "- We track the shortest known time to reach every node from the source k:\n    - Initially, all distances are infinite except for k (0).\n    - At each step, we pop the node with the smallest known distance from the heap.\n    - If we find a shorter path to one of its neighbors, we update (relax) that distance\n    - and push the new state into the heap.\n\n    - By the end, `dist[v]` holds the minimum time for the signal to reach each node `v`:\n    - The total network delay is the longest of these shortest times\n        - i.e., `max(dist.values())`. If some node remains unreachable, return - 1.",
    "kind": "method",
    "label": "def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int",
    "name": "networkDelayTime",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(E log V)"
  },
  "problems.76-minimum-window-substring.solution:minWindow": {
    "args": [
      "t",
      "s"
    ],
    "code": "def minWindow(s: str, t: str) -> str:\n    t_count, have = Counter(t), defaultdict(int)\n    letters_needed, min_idx, l = len(t_count), None, 0\n    for r, c in enumerate(s):\n        have[c] += 1\n        if have[c] == t_count[c]:\n            letters_needed -= 1\n            while letters_needed == 0:\n                if not min_idx or r - l + 1 < min_idx[1] - min_idx[0]:\n                    min_idx = l, r + 1\n                have[s[l]] -= 1\n                if have[s[l]] < t_count[s[l]]:\n                    letters_needed += 1\n                l += 1\n    return \"\" if min_idx == None else s[min_idx[0] : min_idx[1]]",
    "file_path": "backend/algorithms/problems/76-minimum-window-substring/solution.py",
    "kind": "function",
    "label": "def minWindow(s: str, t: str) -> str",
    "name": "minWindow",
    "returns": {
      "label": "str"
    },
    "time_complexity": "O(m + n)"
  },
  "problems.778-swim-in-rising-water.solution:swim_in_rising_water": {
    "args": [
      "grid"
    ],
    "code": "def swim_in_rising_water(grid: list[list[int]]) -> int:\n\n    n=len(grid)\n    pq, resolved = [(grid[0][0], 0, 0)], set()\n\n    while pq:\n        time, r, c = heapq.heappop(pq)\n        if (r, c) in resolved:continue\n        if (r, c) == (n - 1, n - 1):return time\n        resolved.add((r, c))\n\n        for nr, nc in [(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)]:\n            if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in resolved:\n                bottleneck_time = max(time, grid[nr][nc])\n                heapq.heappush(pq, (bottleneck_time, nr, nc))",
    "file_path": "backend/algorithms/problems/778-swim-in-rising-water/solution.py",
    "kind": "function",
    "label": "def swim_in_rising_water(grid: list[list[int]]) -> int",
    "name": "swim_in_rising_water",
    "returns": {
      "label": "int",
      "summary": "minimum time to travel from `(0, 0)` to `(N-1, N-1)`"
    },
    "variables": [
      "pq",
      "resolved"
    ]
  },
  "problems.778-swim-in-rising-water.solution:swim_in_rising_water.grid": {
    "kind": "parameter",
    "label": "grid: list[list[int]]",
    "name": "grid",
    "summary": "2D list of integers representing the elevations of the cells"
  },
  "problems.778-swim-in-rising-water.solution:swim_in_rising_water.pq": {
    "kind": "variable",
    "name": "pq",
    "summary": "Priority queue stores (max_elevation_on_path, r, c)"
  },
  "problems.778-swim-in-rising-water.solution:swim_in_rising_water.resolved": {
    "kind": "variable",
    "name": "resolved",
    "summary": "set to store the cells for which we have found the minimum time required to reach them"
  },
  "problems.787-cheapest-flights-within-k-stops.bellman_ford:cheapest_flights_with_at_most_k_stops": {
    "args": [
      "n",
      "k",
      "flights",
      "src",
      "dst"
    ],
    "code": "def cheapest_flights_with_at_most_k_stops(\n    n: int, flights: list[list[int]], src: int, dst: int, k: int\n) -> int:\n    d = [float(\"inf\")] * n\n    d[src] = 0\n\n    for _ in range(k + 1):\n        tmp = d[:]\n        for u, v, w in flights:\n            if d[u] + w < tmp[v]:\n                tmp[v] = d[u] + w\n        d = tmp\n\n    return d[dst] if d[dst] < float(\"inf\") else -1",
    "file_path": "backend/algorithms/problems/787-cheapest-flights-within-k-stops/bellman_ford.py",
    "kind": "function",
    "label": "def cheapest_flights_with_at_most_k_stops(n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int",
    "name": "cheapest_flights_with_at_most_k_stops",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(kE)\nwhere `k` is the number of stops and `E` is the number of flights."
  },
  "problems.787-cheapest-flights-within-k-stops.dijkstra:cheapest_flights_with_at_most_k_stops": {
    "args": [
      "k",
      "flights",
      "src",
      "dst"
    ],
    "code": "def cheapest_flights_with_at_most_k_stops( flights: list[list[int]], src: int, dst: int, k: int) -> int:\n\n    graph = defaultdict(list)\n    for u, v, price in flights:\n        graph[u].append((v, price))\n\n    pq, min_stops = [(0, src, 0)], {}\n\n    while pq:\n        cost, city, stops = heapq.heappop(pq)\n\n        if stops > min_stops.get(city, float(\"inf\")): continue\n        if city == dst: return cost\n\n        min_stops[city] = stops\n        if stops <= k:\n            for neighbor, price in graph[city]:\n                heapq.heappush(pq, (cost + price, neighbor, stops + 1))\n    return -1",
    "file_path": "backend/algorithms/problems/787-cheapest-flights-within-k-stops/dijkstra.py",
    "kind": "function",
    "label": "def cheapest_flights_with_at_most_k_stops(flights: list[list[int]], src: int, dst: int, k: int) -> int",
    "name": "cheapest_flights_with_at_most_k_stops",
    "returns": {
      "label": "int"
    },
    "variables": [
      "pq",
      "min_stops"
    ]
  },
  "problems.787-cheapest-flights-within-k-stops.dijkstra:cheapest_flights_with_at_most_k_stops.min_stops": {
    "kind": "variable",
    "name": "min_stops",
    "summary": "Tracks the minimum stops to reach each city"
  },
  "problems.787-cheapest-flights-within-k-stops.dijkstra:cheapest_flights_with_at_most_k_stops.pq": {
    "kind": "variable",
    "name": "pq",
    "summary": "Priority queue to store the state (cost, city, stops_taken)"
  },
  "problems.79-word-search.solution:word_search": {
    "args": [
      "board",
      "word"
    ],
    "code": "def word_search(board: list[list[str]], word: str) -> bool:\n    rows, cols, n = len(board), len(board[0]), len(word)\n    def dfs(r: int, c: int, i: int) -> bool:\n        if i == n:\n            return True\n        if not (0 <= r < rows and 0 <= c < cols and board[r][c] == word[i]):\n            return False\n        tmp, board[r][c] = board[r][c], \"#\"\n        for x, y in ((r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)):\n            if dfs(x, y, i + 1):\n                board[r][c] = tmp\n                return True\n        board[r][c] = tmp\n        return False\n    return any(\n        dfs(r, c, 0)\n        for r in range(rows)\n        for c in range(cols)\n        if board[r][c] == word[0]\n    )",
    "file_path": "backend/algorithms/problems/79-word-search/solution.py",
    "intuition": "- Dfs with early exit on mismatch\n    - Start dfs from each cell\n    - At each step:\n        - Check bounds and character match\n        - Mark visited cell with a temp symbol (e.g. #)\n        - Try 4 directions (no revisiting)\n        - Restore cell after backtracking\n        - Stop early if the full word is matched.",
    "kind": "function",
    "label": "def word_search(board: list[list[str]], word: str) -> bool",
    "name": "word_search",
    "returns": {
      "label": "bool"
    },
    "time_complexity": "O(M * N * 3^L)\nM, N = board size\nL = word length\nEach step explores at most 3 directions (excluding the one it came from)\nRuntime improves with early mismatches and pruning"
  },
  "problems.837-new-21-game.solution:new21Game": {
    "args": [
      "k",
      "maxPts",
      "n"
    ],
    "code": "def new21Game(n: int, k: int, maxPts: int) -> float:\n\n    if k == 0 or n >= k + maxPts:\n        return 1.0\n\n    dp = [0] * (n + 1)\n    dp[0] = s = 1\n\n    for i in range(1, n + 1):\n        dp[i] = s / maxPts\n        if i < k:\n            s += dp[i]\n        if i - maxPts >= 0 and i - maxPts < k:\n            s -= dp[i - maxPts]\n    return sum(dp[k:])",
    "file_path": "backend/algorithms/problems/837-new-21-game/solution.py",
    "intuition": "- `dp[i]` is the probability that the game **ends** with total score `i`:\n    - To end at score `i` in one draw, you must have been at some score `j` that:\n        - was **still active** (`j < k`, so drawing is allowed), and\n        - was **close enough to reach i** in a single draw (`i - maxPts ≤ j ≤ i - 1`).\n    - All such `j` values form a sliding window behind `i`.\n    - The variable `s` keeps the **sum of dp[j] over exactly those valid j**.\n    - Since every draw 1..maxPts is equally likely, the transition is: *$dp[i] = \\frac{s}{\\text{maxPts}}$*\n    - And the answer is the total probability of all **terminal scores** *$i \\ge k$* that are also ≤ n.",
    "kind": "function",
    "label": "def new21Game(n: int, k: int, maxPts: int) -> float",
    "name": "new21Game",
    "returns": {
      "label": "float",
      "summary": "The total probability that the final stopped score is ≤ n (i.e., sum over i ≥ k)."
    },
    "time_complexity": "O(n + maxPts):\nEach index enters and leaves the sliding window once",
    "variables": [
      "dp",
      "s"
    ]
  },
  "problems.837-new-21-game.solution:new21Game.dp": {
    "kind": "variable",
    "name": "dp",
    "summary": "dp[i] = probability the game ended with total score = i"
  },
  "problems.837-new-21-game.solution:new21Game.k": {
    "kind": "parameter",
    "label": "k: int",
    "name": "k",
    "summary": "Drawing stops the moment the running total reaches ≥ k."
  },
  "problems.837-new-21-game.solution:new21Game.maxPts": {
    "kind": "parameter",
    "label": "maxPts: int",
    "name": "maxPts",
    "summary": "Each draw is an integer from 1..maxPts, uniformly random."
  },
  "problems.837-new-21-game.solution:new21Game.n": {
    "kind": "parameter",
    "label": "n: int",
    "name": "n",
    "summary": "Final score must be ≤ n to count as a win."
  },
  "problems.837-new-21-game.solution:new21Game.s": {
    "kind": "variable",
    "name": "s",
    "summary": "sliding window sum of dp[j] for j < k and i-maxPts ≤ j ≤ i-1."
  },
  "problems.84-largest-rectangle-in-histogram.solution:largestRectangleArea": {
    "args": [
      "heights"
    ],
    "code": "def largestRectangleArea(heights: list[int]) -> int:\n    heights.append(0)\n    stack = [-1]; best = 0\n    for r, h in enumerate(heights):\n        while stack[-1] != -1 and heights[stack[-1]] > h:\n            l = stack.pop()\n            best = max(best, heights[l] * (r - stack[-1] - 1))\n        stack.append(r)\n    heights.pop()\n    return best",
    "expressions": {
      "heights.append(0)": "adds a **right sentinel** bar smaller than all others, forcing the stack to empty and compute all remaining areas at the end (no leftover bars).",
      "heights.pop()": "restore original list",
      "heights[stack[-1]] > h": "pop while current bar is lower than stack's top",
      "stack = [-1]": "adds a **left sentinel** index before the array start, so width computation `r - stack[-1] - 1` always works (never empty stack).",
      "width = r - stack[-1] - 1": "We subtract 1 because the bar at stack[-1] is strictly smaller and marks the left boundary, which is excluded from the rectangle"
    },
    "file_path": "backend/algorithms/problems/84-largest-rectangle-in-histogram/solution.py",
    "intuition": "- Each bar can form a rectangle where its height is the limiting factor:\n    - That rectangle extends until a strictly shorter bar appears on either side.\n    - Instead of searching both directions explicitly, we discover these bounds on the fly:\n        - when a shorter bar appears at `r`, every taller bar popped from the stack\n        - now knows its right boundary (`r`) and its left boundary (`l = stack.pop()`).\n\n    - Deep Dive: Walkthrough:\n    - Append `0` so every bar eventually meets a shorter right neighbor\n    - Keep *[3!]indices* in strictly increasing heights (stack starts *[3!][-1]*)\n    - For each `r, h`: while top is taller, pop `l` and compute area = `heights[l] * (r - stack[-1] - 1)`\n    - Push `r`; remove the sentinel; return best",
    "kind": "function",
    "label": "def largestRectangleArea(heights: list[int]) -> int",
    "name": "largestRectangleArea",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n):\nEach index is pushed once and popped once, so the total operations across the loop are linear\n*[19!]It remains linear despite the inner while, because every pop is matched to one push*",
    "variables": [
      "stack"
    ]
  },
  "problems.84-largest-rectangle-in-histogram.solution:largestRectangleArea.heights.append(0)": {
    "kind": "expression",
    "name": "heights.append(0)",
    "summary": "adds a **right sentinel** bar smaller than all others, forcing the stack to empty and compute all remaining areas at the end (no leftover bars)."
  },
  "problems.84-largest-rectangle-in-histogram.solution:largestRectangleArea.heights.pop()": {
    "kind": "expression",
    "name": "heights.pop()",
    "summary": "restore original list"
  },
  "problems.84-largest-rectangle-in-histogram.solution:largestRectangleArea.heights[stack[-1]] > h": {
    "kind": "expression",
    "name": "heights[stack[-1]] > h",
    "summary": "pop while current bar is lower than stack's top"
  },
  "problems.84-largest-rectangle-in-histogram.solution:largestRectangleArea.stack": {
    "kind": "variable",
    "name": "stack",
    "summary": "indices with strictly increasing heights"
  },
  "problems.84-largest-rectangle-in-histogram.solution:largestRectangleArea.stack = [-1]": {
    "kind": "expression",
    "name": "stack = [-1]",
    "summary": "adds a **left sentinel** index before the array start, so width computation `r - stack[-1] - 1` always works (never empty stack)."
  },
  "problems.84-largest-rectangle-in-histogram.solution:largestRectangleArea.width = r - stack[-1] - 1": {
    "kind": "expression",
    "name": "width = r - stack[-1] - 1",
    "summary": "We subtract 1 because the bar at stack[-1] is strictly smaller and marks the left boundary, which is excluded from the rectangle"
  },
  "problems.841-keys-and-rooms.solution:Solution.canVisitAllRooms": {
    "args": [
      "rooms"
    ],
    "code": "    def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\n        stack = [0]\n        seen = [True] + [False] * (len(rooms) - 1)\n        while stack:\n            for key in rooms[stack.pop()]:\n                if not seen[key]:\n                    seen[key] = True\n                    stack.append(key)\n        return all(seen)",
    "expressions": {
      "[True]": "Room 0 is unlocked by default",
      "for key in rooms[room]": "For each key found in this room",
      "if not seen[key]": "If the room it unlocks isn't visited yet",
      "room = stack.pop()": "Take the last added room (DFS = LIFO)",
      "stack = [0]": "Start DFS from room 0",
      "stack.append(key)": "Push it onto the stack to explore later",
      "while stack": "While there are rooms to explore"
    },
    "file_path": "backend/algorithms/problems/841-keys-and-rooms/solution.py",
    "intuition": "- Deep Dive:DFS reachability from room 0:\n        - Goal: start from room 0 and reach every other room using the keys you find\n        - Idea: DFS = “go as deep as possible before backtracking”\n            - Each room is a node\n            - Each key in that room is an edge to another node\n        - Stack: we use a stack to track rooms we can explore next\n            - Start with [0] (room 0 is unlocked)\n        - Visited: mark rooms we’ve already opened so we don’t revisit them\n        - Process:\n            - Pop a room from the stack\n            - For each key inside, if that room isn’t visited, mark it and push it on the stack\n        - Finish: when the stack is empty, we’ve explored every reachable room\n        - Check: if all rooms are visited → return True, else False",
    "kind": "method",
    "label": "def canVisitAllRooms(self, rooms: list[list[int]]) -> bool",
    "name": "canVisitAllRooms",
    "returns": {
      "label": "bool"
    },
    "time_complexity": "O(N+E)",
    "variables": [
      "seen"
    ]
  },
  "problems.841-keys-and-rooms.solution:Solution.canVisitAllRooms.[True]": {
    "kind": "expression",
    "name": "[True]",
    "summary": "Room 0 is unlocked by default"
  },
  "problems.841-keys-and-rooms.solution:Solution.canVisitAllRooms.for key in rooms[room]": {
    "kind": "expression",
    "name": "for key in rooms[room]",
    "summary": "For each key found in this room"
  },
  "problems.841-keys-and-rooms.solution:Solution.canVisitAllRooms.if not seen[key]": {
    "kind": "expression",
    "name": "if not seen[key]",
    "summary": "If the room it unlocks isn't visited yet"
  },
  "problems.841-keys-and-rooms.solution:Solution.canVisitAllRooms.room = stack.pop()": {
    "kind": "expression",
    "name": "room = stack.pop()",
    "summary": "Take the last added room (DFS = LIFO)"
  },
  "problems.841-keys-and-rooms.solution:Solution.canVisitAllRooms.seen": {
    "kind": "variable",
    "name": "seen",
    "summary": "Track which rooms have been visited"
  },
  "problems.841-keys-and-rooms.solution:Solution.canVisitAllRooms.stack = [0]": {
    "kind": "expression",
    "name": "stack = [0]",
    "summary": "Start DFS from room 0"
  },
  "problems.841-keys-and-rooms.solution:Solution.canVisitAllRooms.stack.append(key)": {
    "kind": "expression",
    "name": "stack.append(key)",
    "summary": "Push it onto the stack to explore later"
  },
  "problems.841-keys-and-rooms.solution:Solution.canVisitAllRooms.while stack": {
    "kind": "expression",
    "name": "while stack",
    "summary": "While there are rooms to explore"
  },
  "problems.875-koko-eating-bananas.solution:koko_eating_bananas": {
    "args": [
      "h",
      "piles"
    ],
    "code": "def koko_eating_bananas(piles: list[int], h: int) -> int:\n\n    def hours(k:int) -> int:\n        return sum((p + k - 1) // k for p in piles)\n\n    l, r = 1, max(piles)\n    while l < r:\n        k = (l + r) // 2\n        if hours(k) <= h:\n            r = k\n        else:\n            l = k + 1\n    return l",
    "file_path": "backend/algorithms/problems/875-koko-eating-bananas/solution.py",
    "intuition": "- Binary searching the answer space, (eating speed `k`):\n    - The range of possible speeds is from `1` to `max(piles)`\n    - The key property is that the problem is **monotonic** (if a speed `k` is fast enough, any speed greater than `k` will also be fast enough)\n    - This allows us to binary search for the *minimum* valid speed\n    - We test a mid speed (`k = (l + r) // 2`)\n        - If it's valid (`hours(k) <= h`), we try to find a smaller valid speed by searching the lower half (`r = k`)\n        - If it's too slow, we must increase the speed by searching the upper half (`l = k + 1`)\n    - The loop converges on the smallest `k` that works 🍌",
    "kind": "function",
    "label": "def koko_eating_bananas(piles: list[int], h: int) -> int",
    "name": "koko_eating_bananas",
    "returns": {
      "label": "int",
      "summary": "The minimum eating speed"
    },
    "time_complexity": "O(n log m):\nn is the number of piles\nm is the maximum pile size",
    "variables": [
      "l",
      "r",
      "k"
    ]
  },
  "problems.875-koko-eating-bananas.solution:koko_eating_bananas.h": {
    "kind": "parameter",
    "label": "h: int",
    "name": "h",
    "summary": "The hour limit"
  },
  "problems.875-koko-eating-bananas.solution:koko_eating_bananas.hours": {
    "args": [
      "k"
    ],
    "code": "    def hours(k:int) -> int:\n        return sum((p + k - 1) // k for p in piles)",
    "file_path": "backend/algorithms/problems/875-koko-eating-bananas/solution.py",
    "kind": "function",
    "label": "def hours(k: int) -> int",
    "name": "hours",
    "returns": {
      "label": "int"
    },
    "summary": "computes total hours needed at speed k"
  },
  "problems.875-koko-eating-bananas.solution:koko_eating_bananas.k": {
    "kind": "variable",
    "name": "k",
    "summary": "The mid pointer of the binary search"
  },
  "problems.875-koko-eating-bananas.solution:koko_eating_bananas.l": {
    "kind": "variable",
    "name": "l",
    "summary": "The left pointer of the binary search"
  },
  "problems.875-koko-eating-bananas.solution:koko_eating_bananas.piles": {
    "kind": "parameter",
    "label": "piles: list[int]",
    "name": "piles",
    "summary": "The banana piles"
  },
  "problems.875-koko-eating-bananas.solution:koko_eating_bananas.r": {
    "kind": "variable",
    "name": "r",
    "summary": "The right pointer of the binary search"
  },
  "problems.909-snakes-and-ladders.solution:snakes_and_ladders": {
    "args": [
      "board"
    ],
    "code": "def snakes_and_ladders(board: list[list[int]]) -> int:\n\n    flat_board =  [0]\n    for r, row in enumerate(reversed(board)):\n        flat_board.extend(row[::1 if r % 2 == 0 else -1])\n\n    target =(n:= len(board)) * n \n    moves, queue =  {1: 0}, deque([1])\n\n    while queue:\n        current = queue.popleft()\n        for roll in range(1, 7):\n            nxt = current + roll\n            if nxt > target:\n                break\n            landing = flat_board[nxt] if flat_board[nxt] != -1 else nxt\n            if landing not in moves:\n                moves[landing] = moves[current] + 1\n                if landing == target:\n                    return moves[landing]\n                queue.append(landing)\n    return -1",
    "file_path": "backend/algorithms/problems/909-snakes-and-ladders/solution.py",
    "intuition": "- Flatten the Board First 🎲\n    - The key insight here is to **pre-process the 2D `board` into a 1D `flat_board` list**. This powerful first step handles all the complex Boustrophedonical logic upfront. By doing this, the BFS loop becomes exceptionally clean and avoids the need for a coordinate conversion function. The search can then operate on a simple 1D array, treating the board as the simple, linear graph it truly represents.",
    "kind": "function",
    "label": "def snakes_and_ladders(board: list[list[int]]) -> int",
    "name": "snakes_and_ladders",
    "returns": {
      "label": "int"
    },
    "time_complexity": "O(n^2)\nwhere n is the dimension of the board. The initial flattening of the board takes O(n^2) time. The subsequent BFS visits each of the n^2 squares at most once."
  },
  "problems.974-subarray-sums-divisible-by-k.solution:subarraysSumIsDivisibleByK": {
    "args": [
      "k",
      "segments"
    ],
    "code": "def subarraysSumIsDivisibleByK(segments: list[int], k: int) -> int:\n    remainder_frequency = defaultdict(int, {0: 1})\n    prefix_remainder = count = 0\n\n    for segment in segments:\n        prefix_remainder = (prefix_remainder + segment) % k\n        count += remainder_frequency[prefix_remainder]\n        remainder_frequency[prefix_remainder] += 1\n    return count",
    "file_path": "backend/algorithms/problems/974-subarray-sums-divisible-by-k/solution.py",
    "kind": "function",
    "label": "def subarraysSumIsDivisibleByK(segments: list[int], k: int) -> int",
    "name": "subarraysSumIsDivisibleByK",
    "returns": {
      "label": "int",
      "summary": "The count of subarrays with sum divisible by k."
    }
  },
  "problems.974-subarray-sums-divisible-by-k.solution:subarraysSumIsDivisibleByK.k": {
    "kind": "parameter",
    "label": "k: int",
    "name": "k",
    "summary": "The divisor."
  },
  "problems.974-subarray-sums-divisible-by-k.solution:subarraysSumIsDivisibleByK.segments": {
    "kind": "parameter",
    "label": "segments: list[int]",
    "name": "segments",
    "summary": "List of integers representing trip segments."
  }
}