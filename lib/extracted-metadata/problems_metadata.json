{
  "problems": {
    "37-sudoku-solver": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:16.850049",
        "updated_at": "2025-09-30T19:05:08.950126"
      },
      "solutions": {
        "solution.py": {
          "intuition": "MRV (Minimum Remaining Values):\n    Candidates per cell: `{'1'..'9'} âˆ’ (row âˆª col âˆª box)`.\n    MRV: pick the empty cell with the fewest candidates to prune hardest.\n    Place a digit tentatively, update sets, recurse; undo on failure (backtrack).\n    If any cell has 0 candidates, the branch is impossible â†’ backtrack immediately.",
          "time_complexity": "O(9^k):\n    Let k be the number of empty cells (â‰¤ 81).\n    practically Î˜(âˆ(t=1 to k) m_t) where m_t = MRV-picked cell's candidate count at step t (usually â‰ª 9)\n    MRV selection adds O(k) per level (â‰¤ O(k^2) per path), dominated by the search",
          "code": "def solve_sudoku(board: list[list[str]]) -> None:\n\n    D = set(\"123456789\")\n    rows = [set() for _ in range(9)]; cols = [set() for _ in range(9)]; boxes = [set() for _ in range(9)]\n    empties: list[tuple[int,int]] = []\n    for i in range(9):\n        for j in range(9):\n            v = board[i][j]\n            if v == '.': empties.append((i, j))\n            else: \n                rows[i].add(v); cols[j].add(v); boxes[i//3*3 + j//3].add(v)\n\n    def dfs() -> bool:\n        if not empties: return True\n        k, (i, j), cand = min(\n            ((t, (i, j), D - (rows[i] | cols[j] | boxes[i//3*3 + j//3])) for t, (i, j) in enumerate(empties)),\n            key=lambda x: len(x[2])\n        )\n\n        empties.pop(k)\n        for d in cand:\n            board[i][j] = d; rows[i].add(d); cols[j].add(d); boxes[(b:=i//3*3 + j//3)].add(d)\n            if dfs(): return True\n            rows[i].remove(d); cols[j].remove(d); boxes[b].remove(d)\n        board[i][j] = '.'; empties.insert(k, (i, j))\n        return False\n\n    dfs()"
        }
      },
      "title": "Sudoku Solver",
      "definition": "Given a partially filled *9Ã—9* board with digits *1â€“9* and *.* for empty cells, solve it. *[19!]It is guaranteed that the input board has only one solution*",
      "leetcode": "https://leetcode.com/problems/sudoku-solver",
      "difficulty": "hard",
      "topics": ["game"]
    },
    "1275-find-winner-on-a-tic-tac-toe-game": {
      "time_stamps": {
        "created_at": "2025-11-02T17:59:14.523145",
        "updated_at": "2025-11-02T18:30:13.468722"
      },
      "solutions": {
        "solution.py": {
          "code": "def find_winner_on_a_tic_tac_toe_game(moves: list[list[int]]) -> str:\n\n    n, p = 3, 1\n    rows, cols = [0] * n, [0] * n\n    diag = anti_diag = 0\n\n    for r, c in moves:\n\n        rows[r] += p\n        cols[c] += p\n        diag += (r == c) * p\n        anti_diag += (r + c == n - 1) * p\n\n        if any(line == n * p for line in (rows[r], cols[c], diag, anti_diag)):\n            return \"A\" if p == 1 else \"B\"\n\n        p *= -1\n\n    return \"Draw\" if len(moves) == n * n else \"Pending\""
        }
      },
      "title": "Find Winner on a Tic Tac Toe Game",
      "definition": "Given 3Ã—3 Tic Tac Toe moves (A then B), determine the result: \"A\", \"B\", \"Draw\", or \"Pending\"",
      "leetcode": "https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game",
      "difficulty": "easy",
      "topics": ["game", "matrix", "simulation"]
    },
    "1631-path-with-minimum-effort": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:10.762743",
        "updated_at": "2025-09-15T18:58:00.237842"
      },
      "solutions": {
        "solution.py": {
          "args": {
            "heights: list[list[int]]": "2D list of integers representing the heights of the cells"
          },
          "returns": "`int`: minimum effort to reach the bottom-right cell",
          "variables": {
            "pq": "Priority queue stores (max_effort_on_path, r, c)",
            "resolved": "set to store the positions that have been resolved"
          },
          "code": "import heapq\n\ndef path_with_minimum_effort(heights: list[list[int]]) -> int:\n\n    R, C = len(heights), len(heights[0])\n    pq, resolved = [(0, 0, 0)], set()\n\n    while pq:\n        effort, r, c = heapq.heappop(pq)\n        if (r, c) in resolved: continue\n        if (r, c) == (R - 1, C - 1): return effort\n        resolved.add((r, c))\n\n        for nr, nc in [(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)]:\n            if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in resolved:\n                neighbor_effort = max(effort, abs(heights[nr][nc] - heights[r][c]))\n                heapq.heappush(pq, (neighbor_effort, nr, nc))"
        }
      },
      "title": "Path With Minimum Effort",
      "definition": "Find a path from the top-left to the bottom-right of a height grid that minimizes the \"effort\". - Effort is the single largest height difference between any two adjacent cells on the path.",
      "leetcode": "https://leetcode.com/problems/path-with-minimum-effort",
      "difficulty": "medium",
      "topics": ["dijkstra"]
    },
    "909-snakes-and-ladders": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:03.946097",
        "updated_at": "2025-09-30T19:05:08.952509"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Flatten the Board First ðŸŽ²\n    The key insight here is to **pre-process the 2D `board` into a 1D `flat_board` list**. This powerful first step handles all the complex Boustrophedonical logic upfront. By doing this, the BFS loop becomes exceptionally clean and avoids the need for a coordinate conversion function. The search can then operate on a simple 1D array, treating the board as the simple, linear graph it truly represents.",
          "time_complexity": "O(n^2)\n    where n is the dimension of the board. The initial flattening of the board takes O(n^2) time. The subsequent BFS visits each of the n^2 squares at most once.",
          "code": "from collections import deque\n\ndef snakes_and_ladders(board: list[list[int]]) -> int:\n\n    flat_board =  [0]\n    for r, row in enumerate(reversed(board)):\n        flat_board.extend(row[::1 if r % 2 == 0 else -1])\n\n    target =(n:= len(board)) * n \n    moves, queue =  {1: 0}, deque([1])\n\n    while queue:\n        current = queue.popleft()\n        for roll in range(1, 7):\n            nxt = current + roll\n            if nxt > target:\n                break\n            landing = flat_board[nxt] if flat_board[nxt] != -1 else nxt\n            if landing not in moves:\n                moves[landing] = moves[current] + 1\n                if landing == target:\n                    return moves[landing]\n                queue.append(landing)\n    return -1"
        }
      },
      "title": "Snakes and Ladders",
      "definition": "Given an `n Ã— n` integer board where cells are numbered from `1` to `nÂ²` in a Boustrophedonical style. Each cell's value is either **[3!]-1** for a *[3!]normal* square or a **[16!]destination** number for a *[16!]snake/ladder*. Starting from square `1`, return the least number of moves to reach square `nÂ²`. You must take any snake or ladder you land on.",
      "leetcode": "https://leetcode.com/problems/snakes-and-ladders",
      "difficulty": "medium",
      "topics": ["bfs"]
    },
    "265-paint-house-ii": {
      "time_stamps": {
        "created_at": "2025-10-24T16:39:16.579858",
        "updated_at": "2025-10-29T17:13:18.107723"
      },
      "solutions": {
        "bottom-up.py": {
          "code": "def minCostII(costs: list[list[int]]) -> int:\n    n, k = len(costs), len(costs[0]); row = [0]*k\n    for i in range(n-1, -1, -1):\n        m1 = m2 = float('inf'); c1 = -1\n        for c, v in enumerate(row):\n            if v < m1: m2, m1, c1 = m1, v, c\n            elif v < m2: m2 = v\n        row = [costs[i][c] + (m2 if c == c1 else m1) for c in range(k)]\n    return min(row)"
        },
        "top-down.py": {
          "intuition": "Deep Dive: Paint House (k colors) â€” Top-down DP with explicit memoization\n        Subproblems: dp(i, c) = min total cost to paint suffix houses [i:] given house i is color c\n        Relate: *$dp(i,c) = {costs}[i][c] + \\min_{c \\!= c} dp(i+1,c')$*\n        Topological order: decreasing i (each dp(i,Â·) depends only on dp(i+1,Â·)) â‡’ acyclic\n        Base case: dp(n, c) = 0 for all c (no houses left)\n        Original problem: answer = min(dp(0, c)) over all colors c",
          "time_complexity": "O(n * k):\n        *n* rows x *O(k)* per row using *(m1, m2, c1)* trick\n\n    Space:\n        Î˜(nÂ·k) for memo (stores a length-k row per i)",
          "code": "class Solution:\n    def minCostII(self, costs: list[list[int]]) -> int:\n        n, k, memo = len(costs), len(costs[0]) , {}\n\n        def dp(i: int) -> list[int]:\n            if i == n:\n                return [0] * k\n\n            if i not in memo:\n                nxt = dp(i + 1)\n\n                m1 = m2 = float(\"inf\"); c1 = -1\n                for c, v in enumerate(nxt):\n                    if v < m1:\n                        m2, m1, c1 = m1, v, c\n                    elif v < m2:\n                        m2 = v\n                memo[i] = [costs[i][c] + (m2 if c == c1 else m1) for c in range(k)]\n            return memo[i]\n\n        return min(dp(0))"
        }
      },
      "title": "Paint House II",
      "definition": "Return the minimum cost to paint all houses such that no two adjacent houses have the same color.",
      "leetcode": "https://leetcode.com/problems/paint-house-ii/description/",
      "difficulty": "hard",
      "topics": ["dynamic-programming"]
    },
    "1-two-sum": {
      "time_stamps": {
        "created_at": "2025-09-29T09:50:47.660266",
        "updated_at": "2025-10-10T11:47:30.513898"
      },
      "solutions": {
        "solution.py": {
          "time_complexity": "O(n)\n    where n is the length of the nums array. We iterate through the array once.",
          "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n\n    seen = {}\n\n    for i, num in enumerate(nums):\n        if (x := target - num) in seen:\n            return seen[x], i\n        seen[num] = i"
        }
      },
      "title": "Two Sum",
      "definition": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.",
      "leetcode": "https://leetcode.com/problems/two-sum",
      "difficulty": "easy",
      "topics": ["hash-table", "k-sum"]
    },
    "152-maximum-product-subarray": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:33.324160",
        "updated_at": "2025-09-29T12:41:30.343864"
      },
      "solutions": {
        "solution.py": {
          "code": "def maximum_product_subarray(nums: list[int]) -> int:\n\n    hi = lo = max_prod = nums[0]\n    for x in nums[1:]:\n        if x < 0:\n            hi, lo = lo, hi\n        hi = max(x, hi * x)\n        lo = min(x, lo * x)\n        max_prod = max(max_prod, hi)\n    return max_prod"
        }
      },
      "title": "Maximum Product Subarray",
      "definition": "Given an array of integers, return the maximum product of any contiguous subarray.",
      "leetcode": "https://leetcode.com/problems/maximum-product-subarray",
      "difficulty": "medium",
      "topics": ["dynamic-programming"]
    },
    "1293-shortest-path-in-a-grid-with-obstacles-elimination": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:03.946398",
        "updated_at": "2025-11-12T15:49:15.798082"
      },
      "solutions": {
        "dijkstra.py": {
          "variables": {
            "pq": "(g_cost, r, c, k_rem), The priority uses g_cost (steps) itself. No heuristic is used.",
            "steps": "The number of steps taken so far (g_cost)",
            "max_k": "max_k[r][c] stores the max eliminations we have at cell (r,c)"
          },
          "expressions": {
            "heapq.heappush(pq, (steps + 1, nr, nc, new_k))": "The priority is simply the new step count.No heuristic is added, which is the only difference from the A* implementation.\n    'heapq.heappop(pq)': Pop the path with the lowest g_cost (steps) so far\n    'k_rem < max_k[r][c]': Prune paths that are suboptimal for a given cell"
          },
          "code": "def shortest_path_in_a_grid_with_obstacles_elimination(grid: list[list[int]], k: int) -> int:\n\n    rows, cols = len(grid), len(grid[0])\n    if k >= rows + cols - 3:\n        return rows + cols - 2\n\n    pq = [(0, 0, 0, k)]\n\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n\n    while pq:\n\n        steps, r, c, k_rem = heapq.heappop(pq)\n\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n\n        if k_rem < max_k[r][c]:\n            continue\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if 0 <= (nr:= r + dr) < rows and 0 <= (nc:= c + dc) < cols:\n                if (new_k:= k_rem - grid[nr][nc]) > max_k[nr][nc]:\n                    max_k[nr][nc] = new_k\n                    heapq.heappush(pq, (steps + 1, nr, nc, new_k))\n\n    return -1"
        },
        "a_star.py": {
          "time_complexity": "O(m * n * k * log(m * n * k))",
          "variables": {
            "pq": "(f_cost, steps, r, c, remaining_k)"
          },
          "expressions": {
            "new_remaining_k": "= remaining_k - grid[nr][nc], how many obstacle eliminations you will have left **after** moving to the next cell , if the cell is empty grid[nr][nc] is 0, if the cell is an obstacle grid[nr][nc] is 1.\n    'if remaining_k < max_k[r][c]': Handle items that are already outdated by the time they are popped.",
            "Topics": ""
          },
          "code": "import heapq\n\ndef shortest_path_in_a_grid_with_obstacles_elimination(grid: list[list[int]], k: int) -> int:\n\n    rows, cols = len(grid), len(grid[0])\n\n    def h(r: int, c: int) -> int:\n        return manhattan_distance((r, c), (rows - 1, cols - 1))\n\n    if k >= (md:= h(0, 0)) - 1:\n        return md\n\n    pq = [(md, 0, 0, 0, k)]\n\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n\n    while pq:\n        _, steps, r, c, remaining_k = heapq.heappop(pq)\n\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n\n        if remaining_k < max_k[r][c]:\n            continue\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if 0 <= (nr:= r + dr) < rows and 0 <= (nc:= c + dc) < cols:\n                if (new_remaining_k := remaining_k - grid[nr][nc] ) > max_k[nr][nc]:\n                    max_k[nr][nc] = new_remaining_k\n                    heapq.heappush(pq, ((steps + 1) + h(nr, nc), steps + 1, nr, nc, new_remaining_k))\n\n    return -1\n\ndef manhattan_distance(a: tuple[int, int], b: tuple[int, int]) -> int:\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])"
        },
        "bfs.py": {
          "intuition": "bfs with State-Budget Pruning ðŸ”:\n    The core idea is to perform a standard BFS over `(row, col, steps, remaining_k)` states, but only enqueue a move if it arrives at a cell with **strictly more** `remaining_k` than any prior visit. This pruning significantly reduces the number of states explored, making the algorithm much more efficient.\n    **Trivial shortcut:** If `k â‰¥ rows+colsâ€“2`, you can go straight in `rows+colsâ€“2` steps without ever touching an obstacle.\n    **Correctness guarantee:** Because BFS explores in order of increasing `steps`, the first time you dequeue the goal is the fewest-step path. Pruning by `remaining_k` never discards any shorter-step routeâ€”it simply avoids re-exploring dominated states.",
          "time_complexity": "O(m * n * k):\n    Worst-case O(m * n * k) (every cell Ã— every possible k), but aggressive pruning usually makes it far faster in practice.",
          "space_complexity": "O(m * n):\n    for the `max_k` grid plus up to O(m * n * k) queued states in the pathological worst case.",
          "variables": {
            "max_k": "max_k[r][c] = maximum eliminations remaining when visiting (r,c)",
            "q": "(row, col, steps, remaining_k)",
            "min_steps": "Manhattan distance lower bound"
          },
          "code": "from collections import deque\n\ndef shortest_path_in_a_grid_with_obstacles_elimination(grid: list[list[int]], k: int) -> int:\n\n    rows, cols = len(grid), len(grid[0])\n    min_steps = rows + cols - 3 \n    if k >= min_steps:\n        return min_steps\n\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n\n    q = deque([(0, 0, 0, k)])\n\n    while q:\n        r, c, steps, remaining_k = q.popleft()\n        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                new_remaining_k = remaining_k - grid[nr][nc]\n                if new_remaining_k > max_k[nr][nc]:\n                    if (nr, nc) == (rows - 1, cols - 1):\n                        return steps + 1\n                    max_k[nr][nc] = new_remaining_k\n                    q.append((nr, nc, steps + 1, new_remaining_k))\n    return -1"
        }
      },
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "definition": "Given an `m x n` grid where cells are either empty (`0`) or an obstacle (`1`), and an integer `k` representing the maximum number of obstacles you can eliminate, find the minimum number of steps to travel from the top-left corner `(0, 0)` to the bottom-right `(m-1, n-1)`. Each move (up, down, left, right) costs one step. If no such path exists, return `-1`.",
      "leetcode": "https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination",
      "difficulty": "hard",
      "topics": ["bfs"],
      "group": [["a_star.py"], ["dijkstra.py"], ["bfs.py"]]
    },
    "648-replace-words": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:57.931295",
        "updated_at": "2025-09-15T18:58:00.237736"
      },
      "solutions": {
        "solution.py": {
          "code": "def replace_words(dictionary: list[str], sentence: str) -> str:\n    trie = {}\n\n    for word in dictionary:\n        node = trie\n        for c in word:\n            if \"$\" in node:\n                break\n            node = node.setdefault(c, {})\n        node[\"$\"] = True\n\n    def search(word: str) -> str:\n        node = trie\n        for i, c in enumerate(word):\n            if \"$\" in node:\n                return word[:i]\n            if c not in node:\n                return word\n            node = node[c]\n        return word\n\n    return \" \".join(search(word) for word in sentence.split())"
        }
      },
      "title": "Replace Words",
      "definition": "Given a list of words and a sentence, replace all words in the sentence with the shortest root that is a prefix of the word.",
      "leetcode": "https://leetcode.com/problems/replace-words",
      "difficulty": "medium",
      "topics": ["trie"]
    },
    "394-decode-string": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:43.509425",
        "updated_at": "2025-09-15T18:58:00.237437"
      },
      "solutions": {
        "solution.py": {
          "code": "def decode_string(s: str) -> str:\n    stack, s = [], \"1[\" + s + \"]\"\n    for c in s:\n        if c == \"]\":\n            curr = []\n            while stack[-1] != \"[\":\n                curr.append(stack.pop())\n            stack.pop()\n            num = []\n            while stack and stack[-1].isdigit():\n                num.append(stack.pop())\n            stack.append(\"\".join(reversed(curr)) * int(\"\".join(reversed(num))))\n        else:\n            stack.append(c)\n    return stack[0]"
        }
      },
      "title": "Decode String",
      "definition": "Given a string `s` that contains digits, letters, and brackets, decode the string.",
      "leetcode": "https://leetcode.com/problems/decode-string",
      "difficulty": "medium",
      "topics": ["stack"]
    },
    "211-design-add-and-search-words-data-structure": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:43.508854",
        "updated_at": "2025-09-17T16:21:50.341185"
      },
      "solutions": {
        "solution.py": {
          "code": "class WordDictionary:\n\n    def __init__(self):\n        self.trie: dict[str, dict] = {}\n        self.END_MARKER = \"$\"\n\n    def add_word(self, word: str) -> None:\n        node = self.trie\n        for c in word:\n            node = node.setdefault(c, {})\n        node[self.END_MARKER] = True\n\n    def search(self, word: str) -> bool:\n\n        def dfs(node: dict, i: int) -> bool:\n\n            if i == len(word):\n                return self.END_MARKER in node\n\n            if (c := word[i]) == \".\":\n\n                return any(\n                    dfs(child, i + 1)\n                    for k, child in node.items()\n                    if k != self.END_MARKER\n                )\n            child = node.get(c)\n            return bool(child) and dfs(child, i + 1)\n\n        return dfs(self.trie, 0)"
        }
      },
      "title": "Design Add and Search Words Data Structure",
      "definition": "Design a data structure that supports adding new words and finding if a string matches any previously added string. Supports '.' as a wildcard character.",
      "leetcode": "https://leetcode.com/problems/design-add-and-search-words-data-structure",
      "difficulty": "medium",
      "topics": ["trie"]
    },
    "1406-stone-game-iii": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:03.946455",
        "updated_at": "2025-11-03T12:08:47.427447"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Score-difference DP:\n    Let `dp[i]` = max score difference current player can achieve starting at index `i`.\n    Transition: `dp[i] = max_{kâˆˆ{1,2,3}} (sum(i..i+k-1) âˆ’ dp[i+k])`. Answer from `dp[0]`.",
          "time_complexity": "O(n)\n    constant 3 choices per `i`",
          "code": "def stone_game_III(stoneValue: list[int]) -> str:\n    memo, n = {}, len(stoneValue)\n    def dp(i):\n        if i >= n:\n            return 0\n        if i not in memo:\n            memo[i] = max(\n                sum(stoneValue[i : i + k]) - dp(i + k) for k in range(1, 4)\n            )\n        return memo[i]\n    return \"Alice\" if dp(0) > 0 else \"Bob\" if dp(0) < 0 else \"Tie\""
        }
      },
      "title": "Stone Game III",
      "definition": "Array stoneValue; players alternately take 1â€“3 stones from the left maximizing score difference. Return \"Alice\", \"Bob\", or \"Tie\" under optimal play.",
      "leetcode": "https://leetcode.com/problems/stone-game-iii",
      "difficulty": "hard",
      "topics": ["game", "dp", "minimax"]
    },
    "213-house-robber-ii": {
      "time_stamps": {
        "created_at": "2025-10-24T09:05:51.240258",
        "updated_at": "2025-10-24T12:13:44.601228"
      },
      "solutions": {
        "solution.py": {
          "intuition": "In a circle, first and last houses are adjacent â€” we cannot rob both\n    â‡’ Split into two linear cases:\n        exclude last house â†’ `rob(houses[:-1])`\n        exclude first house â†’ `rob(houses[1:])`\n    Take the better of the two.\n\n    Base case:\n        if only one house, rob it directly.",
          "code": "def circularRob(houses: list[int]) -> int:\n    if len(houses) == 1:\n        return houses[0]\n    return max(rob(houses[:-1]), rob(houses[1:]))\n\ndef rob(houses: list[int]) -> int:\n    h1, h2 = 0, 0\n    for h in houses:\n        h2, h1 = h1, max(h1, h2 + h)\n    return h1"
        }
      },
      "title": "House Robber II",
      "definition": "Given houses[i] = money in the i-th house arranged in a circle, return the maximum amount you can rob without robbing two adjacent houses",
      "leetcode": "https://leetcode.com/problems/house-robber-ii",
      "difficulty": "Medium",
      "topics": ["dynamic_programming", "dynamic_programming-1D"]
    },
    "710-random-pick-with-blacklist": {
      "time_stamps": {
        "created_at": "2026-01-29T12:17:02.474337",
        "updated_at": "2026-01-29T12:51:52.087173"
      },
      "solutions": {
        "solution.py": {
          "code": "import random\n\nclass Solution:\n\n    def __init__(self, n: int, blacklist: list[int]):\n        self.m = n - len(blacklist)\n        black = set(blacklist)\n        self.map: dict[int, int] = {}\n\n        t = self.m\n        for b in blacklist:\n            if b < self.m:\n                while t in black:\n                    t += 1\n                self.map[b] = t\n                t += 1\n\n    def pick(self) -> int:\n        return self.map.get(x := random.randrange(self.m), x)"
        }
      },
      "title": "Random Pick with Blacklist",
      "definition": "Given an integer `n` and a blacklist array, implement a class that picks a random integer from `[0, n-1]` uniformly that is not in the blacklist. Optimize to minimize calls to the random function.",
      "leetcode": "https://leetcode.com/problems/random-pick-with-blacklist/",
      "difficulty": "hard",
      "topics": ["hash-table", "randomized"]
    },
    "528-random-pick-with-weight": {
      "time_stamps": {
        "created_at": "2025-11-18T20:08:56.962818",
        "updated_at": "2026-01-28T12:43:18.784955"
      },
      "solutions": {
        "prefix sums + binary search.py": {
          "intuition": "Prefix sums:\n        Each weight `weights[i]` represents how \"wide\" index `i` should be on a number line.\n        Build prefix sums so that:\n            `prefix[i] = weights[0] + ... + weights[i]`\n        This turns the array of weights into contiguous segments on [0, total).\n        Example:\n            weights = [2, 5, 3] -> `prefix = [2, 7, 10]`\n            Segments:\n                [0, 2)   â†’ index 0\n                [2, 7)   â†’ index 1\n                [7, 10)  â†’ index 2\n        To pick an index with probability proportional to its weight:\n            Draw a random integer `target âˆˆ [0, total)`.\n            Find the first `prefix[i] > target`.\n            That `i` is the index whose segment contains `target`.\n        Bigger weight â†’ bigger segment â†’ higher chance of being hit.",
          "time_complexity": "O(n)",
          "space_complexity": "O(n)\n    Store only the prefix sum array of length n",
          "code": "import bisect\nimport random\n\nclass Solution:\n\n    def __init__(self, weights: list[int]):\n        self.prefix, total = [], 0\n        for w in weights:\n            total += w\n            self.prefix.append(total)\n        self.total = total\n\n    def pickIndex(self) -> int:\n        return bisect.bisect_right(self.prefix, random.randrange(self.total))"
        },
        "naive.py": {
          "time_complexity": "O(sum(weights))",
          "space_complexity": "O(sum(weights)):\n    which may be inefficient for large weights.\n    A more efficient solution uses prefix sums + binary search (O(n) space)",
          "code": "import random\n\nclass Solution:\n    def __init__(self, w: list[int]):\n        self.p = []\n        for i, weight in enumerate(w):\n            self.p.extend([i] * (weight))\n\n    def pickIndex(self) -> int:\n        index = random.randint(1, len(self.p) - 1)\n        return self.p[index]"
        }
      },
      "title": "Random Pick with Weight",
      "definition": "Given an array `weights` of positive weights, build a class that returns an index `i` with probability `P(i) = weights[i] / sum(weights)`",
      "leetcode": "https://leetcode.com/problems/random-pick-with-weight/",
      "difficulty": "medium",
      "topics": ["probability", "prefix-sum"],
      "group": [["prefix sums + binary search.py"], ["naive.py"]]
    },
    "300-longest-increasing-subsequence": {
      "time_stamps": {
        "created_at": "2026-01-21T20:37:26.454580",
        "updated_at": "2026-01-22T12:15:07.561948"
      },
      "solutions": {
        "bottom-up.py": {
          "time_complexity": "O(n^2)",
          "code": "def longest_increasing_subsequence(nums: list[int]) -> int:\n    dp = [1] * (n:=len(nums))\n\n    for i in reversed(range(n)):\n        dp[i] = 1 + max(\n                (dp[j] for j in range(i + 1, n) if nums[j] > nums[i]),\n                default=0\n            )\n\n    return max(dp)"
        },
        "binary_search.py": {
          "intuition": "`tails[k]` = smallest tail of any increasing subsequence of length `k+1`:\n    We track the **best possible ending value** for each subsequence length(We donâ€™t build the LIS itself).\n\n    Example:\n        ```text\n        nums = [4, 10, 4, 3, 8, 9]\n        4  â†’ [4]\n        10 â†’ [4, 10]\n        4  â†’ [4, 10]   (replace, no growth)\n        3  â†’ [3, 10]   (better tail for length 1)\n        8  â†’ [3, 8]    (better tail for length 2)\n        9  â†’ [3, 8, 9] (extend)\n        ```\n        `[3, 8, 9]` is **not** a real subsequence, but its **length (3)** is the LIS length.\n\n        **Why this works:**\n        smaller tails give more room to extend later, and binary search keeps updates fast (**O(n log n)**).",
          "time_complexity": "O(nlogn)",
          "code": "from bisect import bisect_left\n\ndef longest_increasing_subsequence(nums: list[int]) -> int:\n    tails: list[int] = []\n    for x in nums:\n        i = bisect_left(tails, x)\n        if i == len(tails):\n            tails.append(x)\n        else:\n            tails[i] = x\n    return len(tails)"
        },
        "top-dwon.py": {
          "time_complexity": "O(n^2)",
          "code": "def longest_increasing_subsequence(nums: list[int]):\n    memo, n = {}, len(nums)\n\n    def dp(i):\n        if i not in memo:\n            memo[i] = 1 + max(\n                (dp(j) for j in range(i + 1, n) if nums[j] > nums[i]),\n                default=0\n            )\n        return memo[i]\n\n    return max(dp(i) for i in range(n))"
        }
      },
      "title": "Longest Increasing Subsequence",
      "definition": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
      "leetcode": "https://leetcode.com/problems/longest-increasing-subsequence/",
      "difficulty": "medium",
      "topics": ["dp", "patience sorting", "binary search"],
      "group": [["binary_search.py"], ["bottom-up.py"], ["top-dwon.py"]]
    },
    "875-koko-eating-bananas": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:03.945955",
        "updated_at": "2026-01-22T09:23:27.870261"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Binary searching the answer space, (eating speed `k`):\n    The range of possible speeds is from `1` to `max(piles)`\n    The key property is that the problem is **monotonic** (if a speed `k` is fast enough, any speed greater than `k` will also be fast enough)\n    This allows us to binary search for the *minimum* valid speed\n    We test a mid speed (`k = (l + r) // 2`)\n        If it's valid (`hours(k) <= h`), we try to find a smaller valid speed by searching the lower half (`r = k`)\n        If it's too slow, we must increase the speed by searching the upper half (`l = k + 1`)\n    The loop converges on the smallest `k` that works ðŸŒ",
          "time_complexity": "O(n log m):\n    n is the number of piles\n    m is the maximum pile size",
          "args": {
            "piles: list[int]": "The banana piles",
            "h: int": "The hour limit (constraint:`len(piles) <= h`)"
          },
          "variables": {
            "l": "The left pointer of the binary search",
            "r": "The right pointer of the binary search",
            "k": "The mid pointer of the binary search"
          },
          "expressions": {
            "max(piles)": "at this speed, each pile takes â‰¤ 1 hour â†’ total = len(piles) â‰¤ h"
          },
          "returns": "`int`: The minimum eating speed",
          "code": "def koko_eating_bananas(piles: list[int], h: int) -> int:\n\n    def hours(k:int) -> int:\n        return sum((p + k - 1) // k for p in piles)\n\n    l, r = 1, max(piles)\n    while l < r:\n        k = (l + r) // 2\n        if hours(k) <= h:\n            r = k\n        else:\n            l = k + 1\n    return l"
        }
      },
      "title": "Koko Eating Bananas",
      "definition": "Given banana piles `piles` and hour limit `h`, find the minimum eating speed\n**$k\\in\\mathbb{N}$** such that $\\sum_{i=1}^{|piles|} \\lceil \\frac{p_i}{k} \\rceil \\leq h$ where each hour Koko eats up to `k` bananas from one pile (any leftover hour is wasted)\n*[19!]constraint:`len(piles) <= h`)*",
      "leetcode": "https://leetcode.com/problems/koko-eating-bananas",
      "difficulty": "medium",
      "topics": ["binary-search", "binary-search-answer-space"]
    },
    "1143-longest-common-subsequence": {
      "time_stamps": {
        "created_at": "2025-10-25T10:54:30.351124",
        "updated_at": "2025-10-25T11:38:39.029357"
      },
      "solutions": {
        "top-down-suffix.py": {
          "code": "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    memo = {}\n\n    def dp(i, j):\n        if i >= len(text1) or j >= len(text2):\n            return 0\n        if (k := (i, j)) not in memo:\n            if text1[i] == text2[j]:\n                memo[k] = 1 + dp(i + 1, j + 1)\n            else:\n                memo[k] = max(dp(i + 1, j), dp(i, j + 1))\n        return memo[k]\n\n    return dp(0, 0)"
        },
        "bottom-up-suffix.py": {
          "code": "def longestCommonSubsequence( text1: str, text2: str) -> int:\n    n1, n2 = len(text1), len(text2)\n    dp = [[0] * (n2+1) for _ in range(n1+1)]\n\n    for i in reversed(range(n1)):\n        for j in reversed(range(n2)):\n            if text1[i] == text2[j]:\n                dp[i][j] = 1 + dp[i + 1][j + 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n    return dp[0][0]"
        },
        "bottom-up-prefix-1d.py": {
          "code": "def longestCommonSubsequence(a: str, b: str) -> int:\n    if len(a) < len(b):\n        a, b = b, a\n    dp = [0] * (len(b) + 1)\n    for ca in a:\n        diag = 0\n        for j, cb in enumerate(b, 1):\n            diag, dp[j] = dp[j], (diag + 1 if ca == cb else max(dp[j], dp[j - 1]))\n    return dp[-1]"
        }
      },
      "title": "Longest Common Subsequence",
      "definition": "Given two strings , return the length of their longest common subsequence",
      "leetcode": "https://leetcode.com/problems/longest-common-subsequence",
      "difficulty": "medium",
      "topics": ["dynamic-programming"]
    },
    "460-lfu-cache": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:57.930976",
        "updated_at": "2025-09-15T18:58:00.237451"
      },
      "solutions": {
        "solution.py": {
          "code": "from collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity    = capacity\n        self.cache       = {}\n        self.freq        = {}\n        self.buckets     = defaultdict(OrderedDict)\n        self.minfreq     = 0\n\n    def _bump(self, key: int):\n        f = self.freq[key]\n        del self.buckets[f][key]\n        if not self.buckets[f]:\n            del self.buckets[f]\n            if self.minfreq == f:\n                self.minfreq += 1\n\n        self.freq[key] +=1\n        self.buckets[f + 1][key] = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self._bump(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity <= 0:\n            return\n\n        if key in self.cache:\n            self.cache[key] = value\n            self._bump(key)\n            return\n\n        if len(self.cache) >= self.capacity:\n            old_key, _ = self.buckets[self.minfreq].popitem(last=False)\n            del self.cache[old_key]\n            del self.freq[old_key]\n\n        self.cache[key] = value\n        self.freq[key] = 1\n        self.buckets[1][key] = None\n        self.minfreq = 1"
        }
      },
      "title": "LFU Cache",
      "definition": "A cache that evicts the least frequently used item when the cache is full.",
      "leetcode": "https://leetcode.com/problems/lfu-cache",
      "difficulty": "hard",
      "topics": ["cache"]
    },
    "133-clone-graph": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:33.324061",
        "updated_at": "2025-09-30T19:05:08.948114"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Hash Map as a Visited Set & Node Cache ðŸ—ºï¸\n    The key to traversing a potentially cyclic graph is a `visited` set. Here, the `cloned` dictionary serves a dual purpose. It acts as both a **`visited` set** (by checking `if n not in cloned`) and a **cache** that maps an original node to its clone. This ensures each node is cloned exactly once and prevents getting stuck in an infinite loop.",
          "time_complexity": "O(V + E)\n    where V is the number of vertices (nodes) and E is the number of edges. This is optimal as we must visit every node and traverse every edge to create the full copy.",
          "args": {
            "node: Node | None": "The node to clone"
          },
          "expressions": {
            "if n not in cloned": "Check if the node has not been visited",
            "cloned[n] = Node(n.val)": "Create a new node for the neighbor",
            "queue.append(n)": "Add the neighbor to the queue",
            "cloned[cur].neighbors.append(cloned[n])": "Add the neighbor to the current node's neighbors"
          },
          "variables": {
            "cloned": "A dictionary that maps an original node to its clone",
            "queue": "A queue that stores the nodes to be visited",
            "cur": "The current node being visited",
            "n": "The neighbor of the current node"
          },
          "returns": "`Node | None`: The cloned graph",
          "code": "from collections import deque\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef clone_graph(node: Node | None) -> Node | None:\n    if not node:\n        return None\n    cloned = {node: Node(node.val)}\n    queue = deque([node])\n    while queue:\n        cur = queue.popleft()\n        for n in cur.neighbors:\n            if n not in cloned:\n                cloned[n] = Node(n.val)\n                queue.append(n)\n            cloned[cur].neighbors.append(cloned[n])\n    return cloned[node]"
        }
      },
      "title": "Clone Graph",
      "definition": "Given a reference to a node in a connected undirected graph, return a deep copy (clone) of the graph.",
      "leetcode": "https://leetcode.com/problems/clone-graph",
      "difficulty": "medium",
      "topics": ["bfs"]
    },
    "238-product-of-array-except-self": {
      "time_stamps": {
        "created_at": "2025-09-29T10:06:33.328225",
        "updated_at": "2025-09-30T19:05:08.949484"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Two passes:\n        1.  *[orange!]Prefix* pass â†’ `res[i]` = product of all elements *[orange!]before* `i`.\n        2.  *[purple!]Suffix* pass â†’ multiply each `res[i]` by product of all elements *[purple!]after* `i`.",
          "time_complexity": "O(n)\n    where n is the length of the nums array. We iterate through the array twice.",
          "code": "def product_of_array_except_self(nums: list[int]) -> list[int]:\n\n    pre, res = 1, [1] * (n := len(nums))\n    for i, x in enumerate(nums):\n        res[i], pre = pre, pre * x\n    suf = 1\n    for i in range(n - 1, -1, -1):\n        res[i], suf = res[i] * suf, suf * nums[i]\n    return res"
        }
      },
      "title": "Product of Array Except Self",
      "definition": "Given an integer array nums, return an array answer such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`,      *[sky!]Achieve $O(n)$ time complexity and without using the division operator.*",
      "leetcode": "https://leetcode.com/problems/product-of-array-except-self",
      "difficulty": "medium",
      "topics": ["prefix-suffix", "two-pass-scan"]
    },
    "410-split-array-largest-sum": {
      "time_stamps": {
        "created_at": "2026-01-22T08:45:27.634687",
        "updated_at": "2026-01-22T12:11:40.297642"
      },
      "solutions": {
        "binary_search_on_answer_space.py": {
          "intuition": "We are minimizing the maximum subarray sum after splitting `nums` into `k`\n    contiguous parts. If we fix a candidate maximum sum `max_sum`, we can greedily\n    scan left-to-right and create a new subarray only when adding the next element\n    would exceed `max_sum`. This greedy strategy minimizes the number of parts.\n    The feasibility is monotonic: if a given `max_sum` works, any larger value\n    will also work, so binary search applies.",
          "time_complexity": "O(n log S):\n    where `n = len(nums`) and `S = sum(nums) - max(nums)`\n    (binary search over the answer space, O(n) greedy check per step).",
          "code": "def splitArray(nums: list[int], k: int) -> int:\n\n    def can(max_sum: int) -> bool:\n        parts = curr = 0\n        for x in nums:\n            if curr + x > max_sum:\n                parts += 1\n                curr = 0\n            curr += x\n        return parts + 1 <= k\n\n    lo, hi = max(nums), sum(nums)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if can(mid):\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo"
        },
        "topdown-dp.py": {
          "time_complexity": "$O(n^2 \\cdot k)$:\n    There are $O(n \\cdot k)$ memo states $(i, \\text{cuts})$\n    Each state tries $O(n)$ split points $j$, doing $O(1)$ work per $j$ (prefix diff + memoized dp)\n    Prefix build is $O(n)$, dominated",
          "code": "def splitArray(nums: list[int], k: int) -> int:\n    prefix = [0]\n    for x in nums:\n        prefix.append(prefix[-1] + x)\n\n    memo, n = {}, len(nums)\n\n    def dp(i: int, cuts: int) -> int:\n        if cuts == 0:\n            return prefix[n] - prefix[i]\n\n        if (i, cuts) not in memo:\n            memo[i, cuts] = min(\n                (\n                    max(prefix[j] - prefix[i], dp(j, cuts - 1))\n                    for j in range(i + 1, n - cuts + 1)\n                ),\n                default=float(\"inf\"),\n            )\n        return memo[i, cuts]\n\n    return dp(0, k - 1)"
        }
      },
      "title": "Split Array Largest Sum",
      "definition": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.Return the minimized largest sum of the split.A subarray is a contiguous part of the array.",
      "leetcode": "https://leetcode.com/problems/split-array-largest-sum",
      "difficulty": "hard",
      "topics": ["dp", "binary search on answer space", "greedy"]
    },
    "523-continuous-subarray-sum": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:57.931080",
        "updated_at": "2025-09-29T12:48:05.175290"
      },
      "solutions": {
        "solution.py": {
          "args": {
            "segments: list[int]": "List of integers representing trip segments.",
            "k: int": "The divisor."
          },
          "returns": "`bool`: True if such a subarray exists, False otherwise.",
          "code": "def checkSubarraySumIsMultipleOfK(segments: list[int], k: int) -> bool:\n\n    remainder_idx = {0: -1}\n    prefix_remainder = 0\n\n    for i, segment in enumerate(segments):\n        prefix_remainder = (prefix_remainder + segment) % k\n        if prefix_remainder in remainder_idx:\n            if i - remainder_idx[prefix_remainder] > 1:\n                return True\n        else:\n            remainder_idx[prefix_remainder] = i\n    return False"
        }
      },
      "title": "Continuous Subarray Sum",
      "definition": "Given an array of integers and a target k, determine if there exists a subarray with sum divisible by k.",
      "leetcode": "https://leetcode.com/problems/continuous-subarray-sum",
      "difficulty": "medium",
      "topics": ["prefix-sum"]
    },
    "1162-as-far-from-land-as-possible": {
      "time_stamps": {
        "created_at": "2025-11-02T16:06:57.892639",
        "updated_at": "2025-11-02T16:50:12.272026"
      },
      "solutions": {
        "solution.py": {
          "code": "from collections import deque\n\nclass Solution:\n    def maxDistance(self, grid: list[list[int]]) -> int:\n\n        n = len(grid)\n        q = deque([(r, c) for r in range(n) for c in range(n) if grid[r][c]])\n\n        if not q or len(q) == n * n:\n            return -1\n\n        distance = 0\n        while q:\n            distance += 1\n            for _ in range(len(q)):\n                (y, x) = q.popleft()\n                for dy, dx in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if 0 <= (i := y + dy) < n and 0 <= (j := x + dx) < n and not grid[i][j]:\n                        grid[i][j] = 1\n                        q.append((i, j))\n        return distance"
        }
      },
      "title": "As Far from Land as Possible",
      "definition": "Given an n x n grid of 0s (water) and 1s (land), find the maximum distance from any water cell to the nearest land cell. Return -1 if the grid has only land or only water",
      "leetcode": "https://leetcode.com/problems/as-far-from-land-as-possible/",
      "difficulty": "medium",
      "topics": ["multi-source bfs", "bfs"]
    },
    "1235-maximum-profit-in-job-scheduling": {
      "time_stamps": {
        "created_at": "2025-11-09T11:21:22.314054",
        "updated_at": "2025-11-09T14:10:10.607119"
      },
      "solutions": {
        "top_down.py": {
          "expressions": {
            "dp(i + 1)": "Skip this job and move to the next one\n    'bisect_left(jobs, e, key=lambda x: x[0]))': Find the index of the first job whose start time is greater than or equal to the end time `e` of this job\n    'p + dp(': Take this job and move accordingly\n    'sorted(zip(startTime, endTime, profit))': pack and sort by start so we can jump to the next non-overlapping job"
          },
          "variables": {
            "memo": "memo[i] = max profit starting from job i"
          },
          "time_complexity": "O(n log n):\n    Sorting the jobs â†’ O(n log n)\n    For each of the `n` jobs, the top-down DP does one binary search (`bisect_left`) â†’ O(log n) per call.\n    Each state is memoized once â†’ total O(n log n).",
          "code": "from bisect import bisect_left\n\ndef maximum_profit_in_job_scheduling(\n    startTime: list[int], endTime: list[int], profit: list[int]\n) -> int:\n\n    jobs = sorted(zip(startTime, endTime, profit))\n    memo = {}\n\n    def dp(i: int) -> int:\n        if i == len(jobs):\n            return 0\n        if i not in memo:\n            _, e, p = jobs[i]\n            memo[i] = max(dp(i + 1), p + dp(bisect_left(jobs, e, key=lambda x: x[0])))\n        return memo[i]\n\n    return dp(0)"
        },
        "bottom_up.py": {
          "code": "from bisect import bisect_right\n\ndef maximum_profit_in_job_scheduling(\n    startTime: list[int], endTime: list[int], profit: list[int]\n) -> int:\n\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n\n    ends, dp = [0], [0]\n\n    for s, e, p in jobs:\n\n        i = bisect_right(ends, s) - 1\n        take = dp[i] + p\n\n        if take > dp[-1]:\n            ends.append(e)\n            dp.append(take)\n\n    return dp[-1]"
        },
        "top_down_explicit.py": {
          "code": "from bisect import bisect_left\n\ndef maximum_profit_in_job_scheduling(\n    startTime: list[int], endTime: list[int], profit: list[int]\n) -> int:\n\n    jobs = sorted([x for x in zip(startTime, endTime, profit)], key=lambda x: x[0])\n    starts = [s for s, _, _ in jobs]\n\n    n, memo = len(startTime), {}\n    nextIdx = [bisect_left(starts, jobs[i][1]) for i in range(n)]\n\n    def dp(i):\n        if i >= n:\n            return 0\n        if i not in memo:\n            memo[i] = max(jobs[i][2] + dp(nextIdx[i]), dp(i + 1))\n        return memo[i]\n\n    return dp(0)"
        }
      },
      "title": "Maximum Profit in Job Scheduling",
      "definition": "Schedule non-overlapping jobs with given start, end, and profit to maximize total profit",
      "leetcode": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/",
      "difficulty": "hard",
      "topics": ["interval", "binary-search", "dp"]
    },
    "547-number-of-provinces": {
      "time_stamps": {
        "created_at": "2025-10-27T11:31:50.829497",
        "updated_at": "2025-10-27T12:18:50.369449"
      },
      "solutions": {
        "solution.py": {
          "expressions": {
            "p = list(range(n := len(isConnected)))": "Each node starts as its own parent (each city = its own province)\n    'while x != p[x]' : This walks up the chain until it reaches the root.\n    'p[x] = p[p[x]]' : flattens the chain â†’ next time find is faster\n    'p[find(i)] = find(j)' :  Whenever two cities are connected (`isConnected[i][j]`), we union their groups by linking one root to the other.\n    'sum(i == find(i) for i in range(n))' : Counts how many nodes are their own root â€” each root = one province."
          },
          "intuition": "Union-Find:\n    We treat each city as a node\n    If two cities are connected (directly or indirectly), they belong to the same set or group\n    Union-Find (or Disjoint Set Union, DSU) keeps track of which node belongs to which group",
          "time_complexity": "O(n^2):\n    *Building connections:* *O(n^2)*\n    *Each union/find:* amortized *O(Î±(n))*\n        *Î±(n) is the inverse Ackermann function (~constant)*",
          "code": "class Solution:\n    def findCircleNum(self, isConnected: list[list[int]]) -> int:\n        p = list(range(n := len(isConnected)))\n\n        def union(a, b):\n            p[find(a)] = find(b)\n\n        def find(x):\n            while x != p[x]:\n                p[x] = p[p[x]]\n                x = p[x]\n            return x\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j]:\n                    union(i, j)\n\n        return sum(i == find(i) for i in range(n))"
        }
      },
      "title": "Number of Provinces",
      "definition": "Given an *$n x n$* symmetric adjacency matrix isConnected    (`isConnected[i][i]`=`1` or `0`) for an *[6!]undirected* graph of n cities,    return the number of connected components (â€œprovincesâ€). $1\\le n\\le 200$",
      "leetcode": "https://leetcode.com/problems/number-of-provinces/",
      "difficulty": "medium",
      "topics": ["dsu"]
    },
    "407-trapping-rain-water-ii": {
      "time_stamps": {
        "created_at": "2025-11-10T09:05:17.629545",
        "updated_at": "2025-11-10T19:18:19.976012"
      },
      "solutions": {
        "solution.py": {
          "code": "from heapq import heapify, heappush, heappop\n\ndef trapRainWater(heightMap: list[list[int]]) -> int:\n\n    R, C = len(heightMap), len(heightMap[0])\n    is_border = lambda r, c: r in (0, R - 1) or c in (0, C - 1)\n    heapify(heap := [(heightMap[r][c], r, c)for r in range(R)for c in range(C)if is_border(r, c)])\n    vis = [[is_border(r, c) for c in range(C)] for r in range(R)]\n\n    water = 0\n    while heap:\n        h, r, c = heappop(heap)\n        for nr, nc in ((r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)):\n            if 0 <= nr < R and 0 <= nc < C and not vis[nr][nc]:\n                vis[nr][nc] = True\n                if (nh := heightMap[nr][nc]) < h:\n                    water += h - nh\n                heappush(heap, (h if h > nh else nh, nr, nc))\n    return water"
        }
      },
      "title": "Trapping Rain Water II",
      "definition": "Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining",
      "leetcode": "https://leetcode.com/problems/trapping-rain-water-ii/",
      "difficulty": "hard",
      "topics": ["dijkstra", "heap"]
    },
    "518-coin-change-ii": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:57.931034",
        "updated_at": "2025-11-16T15:13:00.722231"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Paradigm: This is a classic **Unbounded Knapsack** counting problem.\n\n    Insight: To count *combinations* without overcounting *permutations* (`1+2` vs `2+1`), the DP imposes a strict processing order on the coins. This ensures that combinations are always built in the same sequence (e.g., using smaller denomination coins before larger ones), elegantly eliminating duplicates.",
          "time_complexity": "O(n * amount)\n    where n is the number of coins and amount is the target amount.",
          "code": "def coin_change_II(amount: int, coins: list[int]) -> int:\n    memo, n = {}, len(coins)\n\n    def dp(c, amount):\n        if amount == 0:\n            return 1\n        if amount < 0 or c == n:\n            return 0\n        if (c, amount) not in memo:\n            memo[c, amount] = dp(c, amount - coins[c]) + dp(c + 1, amount)\n        return memo[c, amount]\n\n    return dp(0, amount)"
        }
      },
      "title": "Coin Change II",
      "definition": "Given an array of coin denominations and a total amount, return the number of combinations of coins that make up that amount. You can assume an infinite number of each coin.",
      "leetcode": "https://leetcode.com/problems/coin-change-ii",
      "difficulty": "medium",
      "topics": ["dp"]
    },
    "416-partition-equal-subset-sum": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:57.930844",
        "updated_at": "2025-10-29T19:11:07.314625"
      },
      "solutions": {
        "solution.py": {
          "intuition": "This is the **0/1 Knapsack** decision problem in disguise:\n    The problem transforms from partitioning an array into a simpler question:             can a subset of \"items\" (`nums`) perfectly fill a \"knapsack\" with capacity `total_sum // 2`?             Each item's weight is equal to its value.",
          "time_complexity": "O(n * target)",
          "expressions": {
            "(total := sum(nums)) & 1": "odd sum"
          },
          "code": "def canPartition(nums: list[int]) -> bool:\n\n    if (total := sum(nums)) & 1:\n        return False\n\n    nums.sort(reverse=True)\n    if nums[0] > (target := total // 2):\n        return False\n\n    memo = {}\n\n    def dp(i: int, r: int) -> bool:\n        if r == 0:\n            return True\n        if r < 0 or i == len(nums):\n            return False\n        if (k := (i, r)) not in memo:\n            memo[k] = dp(i + 1, r - nums[i]) or dp(i + 1, r)\n        return memo[k]\n\n    return dp(0, target)"
        }
      },
      "title": "Partition Equal Subset Sum",
      "definition": "Given an integer array `nums`, determine if you can partition it into two subsets with an equal sum    `1 <= nums.length <= 200` , `1 <= nums[i] <= 100`",
      "leetcode": "https://leetcode.com/problems/partition-equal-subset-sum",
      "difficulty": "medium",
      "topics": ["dynamic-programming"]
    },
    "188-best-time-to-buy-and-sell-stock-iv": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:43.508701",
        "updated_at": "2025-09-29T12:41:30.357182"
      },
      "solutions": {
        "dp.py": {
          "code": "def best_time_to_buy_and_sell_stock_IV(k: int, prices: list[int]) -> int:\n\n    cost = [float(\"inf\")] * (k + 1)\n    profit = [0] * (k + 1)\n    for p in prices:\n        for t in range(1, k + 1):\n            cost[t] = min(cost[t], p - profit[t - 1])\n            profit[t] = max(profit[t], p - cost[t])\n    return profit[k]"
        },
        "states.py": {
          "code": "def best_time_to_buy_and_sell_stock_IV(k: int, prices: list[int]) -> int:\n    buy  = [float(\"-inf\")] * (k + 1)\n    sell = [0] * (k + 1)\n    for p in prices:\n        for t in range(1, k + 1):\n            buy[t]  = max(buy[t],  sell[t - 1] - p)\n            sell[t] = max(sell[t], buy[t] + p)\n    return sell[k]"
        }
      },
      "title": "Best Time to Buy and Sell Stock IV",
      "definition": "Given a list of daily stock prices `prices` and an integer `k` (max transactions), return the maximum profit.",
      "leetcode": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv",
      "difficulty": "hard",
      "topics": ["dynamic-programming"]
    },
    "20-valid-parentheses": {
      "time_stamps": {
        "created_at": "2025-10-03T15:45:20.243728",
        "updated_at": "2025-10-03T15:59:14.202009"
      },
      "solutions": {
        "solution.py": {
          "time_complexity": "O(n)",
          "code": "def isValid(s: str) -> bool:\n    m, stack = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}, []\n    for b in s:\n        if b in m:\n            if not stack or m[b] != stack.pop():\n                return False\n        else:\n            stack.append(b)\n    return not stack"
        }
      },
      "title": "Valid Parentheses",
      "definition": "Given a string `s` containing just the characters `'()', '{}', '[]'`,     determine if the input string is valid",
      "leetcode": "https://leetcode.com/problems/valid-parentheses",
      "difficulty": "easy",
      "topics": ["stack"]
    },
    "370-range-addition": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:43.509337",
        "updated_at": "2025-09-29T12:53:25.721288"
      },
      "solutions": {
        "solution.py": {
          "args": {
            "length: int": "The number of days in the itinerary.",
            "updates: list[list[int]]": "List of [start_day, end_day, change_in_km] updates."
          },
          "returns": "`list[int]`: The final daily travel plan after all updates.",
          "code": "def getModifiedArray(length: int, updates: list[list[int]]) -> list[int]:\n\n    delta = [0] * (length + 1)\n\n    for start_day, end_day, change_in_km in updates:\n        delta[start_day] += change_in_km\n        delta[end_day + 1] -= change_in_km\n\n    prefix_sum = 0\n    return [prefix_sum := prefix_sum + change for change in delta[:-1]]"
        }
      },
      "title": "Range Addition",
      "definition": "Given an array and a list of operations, apply range updates and return the final array.",
      "leetcode": "https://leetcode.com/problems/range-addition",
      "difficulty": "medium",
      "topics": ["prefix-sum"]
    },
    "120-triangle": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:33.323838",
        "updated_at": "2025-11-02T16:50:17.419206"
      },
      "solutions": {
        "solution.py": {
          "code": "class Solution:\n\n    def minimumTotal(self, triangle: list[list[int]]) -> int:\n\n        memo = {}\n\n        def dp(r, i):\n            if r == len(triangle):\n                return 0\n            if (r, i) not in memo:\n                memo[r, i] = triangle[r][i] + min(dp(r + 1, i), dp(r + 1, i + 1))\n            return memo[r, i]\n\n        return dp(0, 0)"
        }
      },
      "title": "Triangle Minimum Path Sum",
      "definition": "Given a `triangle` (list of lists), find the minimum path sum from top to bottom. From index `i` in a row, you may move to index `i` or `i + 1` in the next row.",
      "leetcode": "https://leetcode.com/problems/triangle",
      "difficulty": "medium",
      "topics": ["dp"]
    },
    "787-cheapest-flights-within-k-stops": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:03.945900",
        "updated_at": "2025-11-02T12:08:08.835370"
      },
      "solutions": {
        "dijkstra.py": {
          "variables": {
            "pq": "Priority queue to store the state (cost, city, stops_taken)",
            "min_stops": "Tracks the minimum stops to reach each city"
          },
          "code": "from collections import defaultdict\nimport heapq\n\ndef cheapest_flights_with_at_most_k_stops( flights: list[list[int]], src: int, dst: int, k: int) -> int:\n\n    graph = defaultdict(list)\n    for u, v, price in flights:\n        graph[u].append((v, price))\n\n    pq, min_stops = [(0, src, 0)], {}\n\n    while pq:\n        cost, city, stops = heapq.heappop(pq)\n\n        if stops > min_stops.get(city, float(\"inf\")): continue\n        if city == dst: return cost\n\n        min_stops[city] = stops\n        if stops <= k:\n            for neighbor, price in graph[city]:\n                heapq.heappush(pq, (cost + price, neighbor, stops + 1))\n    return -1"
        },
        "bellman_ford.py": {
          "time_complexity": "O(kE)\n    where `k` is the number of stops and `E` is the number of flights.",
          "code": "def cheapest_flights_with_at_most_k_stops(\n    n: int, flights: list[list[int]], src: int, dst: int, k: int\n) -> int:\n    d = [float(\"inf\")] * n\n    d[src] = 0\n\n    for _ in range(k + 1):\n        tmp = d[:]\n        for u, v, w in flights:\n            if d[u] + w < tmp[v]:\n                tmp[v] = d[u] + w\n        d = tmp\n\n    return d[dst] if d[dst] < float(\"inf\") else -1"
        }
      },
      "title": "Cheapest Flights Within K Stops",
      "definition": "Given a list of flights where flights[i] = [from, to, price] represents a flight from city from to city to with a price price, and a starting city src and a destination city dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, return -1.",
      "leetcode": "https://leetcode.com/problems/cheapest-flights-within-k-stops",
      "difficulty": "medium",
      "topics": ["dijkstra", "bfs"]
    },
    "837-new-21-game": {
      "time_stamps": {
        "created_at": "2025-11-17T12:14:05.140565",
        "updated_at": "2026-01-18T19:04:58.385976"
      },
      "solutions": {
        "solution.py": {
          "intuition": "`dp[i]` is the probability that the game **ends** with total score `i`:\n    To end at score `i` in one draw, you must have been at some score `j` that:\n        was **still active** (`j < k`, so drawing is allowed), and\n        was **close enough to reach i** in a single draw (`i - maxPts â‰¤ j â‰¤ i - 1`).\n    All such `j` values form a sliding window behind `i`.\n    The variable `s` keeps the **sum of dp[j] over exactly those valid j**.\n    Since every draw 1..maxPts is equally likely, the transition is: *$dp[i] = \\frac{s}{\\text{maxPts}}$*\n    And the answer is the total probability of all **terminal scores** *$i \\ge k$* that are also â‰¤ n.",
          "args": {
            "n: int": "Final score must be â‰¤ n to count as a win.",
            "k: int": "Drawing stops the moment the running total reaches â‰¥ k.",
            "maxPts: int": "Each draw is an integer from 1..maxPts, uniformly random."
          },
          "variables": {
            "dp": "dp[i] = probability the game ended with total score = i",
            "s": "sliding window sum of dp[j] for j < k and i-maxPts â‰¤ j â‰¤ i-1."
          },
          "time_complexity": "O(n + maxPts):\n    Each index enters and leaves the sliding window once",
          "returns": "`float`: The total probability that the final stopped score is â‰¤ n (i.e., sum over i â‰¥ k).",
          "code": "def new21Game(n: int, k: int, maxPts: int) -> float:\n\n    if k == 0 or n >= k + maxPts:\n        return 1.0\n\n    dp = [0] * (n + 1)\n    dp[0] = s = 1\n\n    for i in range(1, n + 1):\n        dp[i] = s / maxPts\n        if i < k:\n            s += dp[i]\n        if i - maxPts >= 0 and i - maxPts < k:\n            s -= dp[i - maxPts]\n    return sum(dp[k:])"
        }
      },
      "title": "New 21 Game",
      "definition": "You start at 0. Keep adding a random number from 1â€¦n while your total < k.\n    Find P(final total â‰¤ maxPts).",
      "leetcode": "https://leetcode.com/problems/new-21-game/",
      "difficulty": "medium",
      "topics": ["game"]
    },
    "363-max-sum-of-rectangle-no-larger-than-k": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:43.509273",
        "updated_at": "2026-01-18T19:04:58.384290"
      },
      "solutions": {
        "solution.py": {
          "code": "from bisect import bisect_left, insort\n\ndef max_sum_of_rectangle_no_larger_than_k(mat: list[list[int]], k: int) -> int:\n    m, n = len(mat), len(mat[0])\n    if m > n:\n        mat = [list(r) for r in zip(*mat)]\n        m, n = n, m\n\n    def kadane_leq(arr: list[int], K: int) -> int | None:\n        best = cur = arr[0]\n        for x in arr[1:]:\n            cur = x if cur < 0 else cur + x\n            best = max(best, cur)\n            if best == K:\n                return K\n        return best if best <= K else None\n\n    ans = float(\"-inf\")\n\n    for l in range(n):\n        row = [0] * m\n        for r in range(l, n):\n            for i in range(m):\n                row[i] += mat[i][r]\n\n            fast = kadane_leq(row, k)\n            if fast is not None:\n                ans = max(ans, fast)\n                if ans == k:\n                    return k\n                continue\n\n            s, pref = 0, [0]\n            for v in row:\n                s += v\n                j = bisect_left(pref, s - k)\n                if j < len(pref):\n                    ans = max(ans, s - pref[j])\n                    if ans == k:\n                        return k\n                insort(pref, s)\n\n    return ans"
        }
      },
      "title": "Max Sum of Rectangle No Larger Than K",
      "definition": "Given a 2D matrix and a target sum, return the maximum sum of any submatrix no larger than K.",
      "leetcode": "https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k",
      "difficulty": "hard",
      "topics": ["kadane"]
    },
    "778-swim-in-rising-water": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:03.945808",
        "updated_at": "2025-09-15T18:58:00.237748"
      },
      "solutions": {
        "solution.py": {
          "args": {
            "grid: list[list[int]]": "2D list of integers representing the elevations of the cells"
          },
          "returns": "`int`: minimum time to travel from `(0, 0)` to `(N-1, N-1)`",
          "variables": {
            "pq": "Priority queue stores (max_elevation_on_path, r, c)",
            "resolved": "set to store the cells for which we have found the minimum time required to reach them"
          },
          "code": "import heapq\n\ndef swim_in_rising_water(grid: list[list[int]]) -> int:\n\n    n=len(grid)\n    pq, resolved = [(grid[0][0], 0, 0)], set()\n\n    while pq:\n        time, r, c = heapq.heappop(pq)\n        if (r, c) in resolved:continue\n        if (r, c) == (n - 1, n - 1):return time\n        resolved.add((r, c))\n\n        for nr, nc in [(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)]:\n            if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in resolved:\n                bottleneck_time = max(time, grid[nr][nc])\n                heapq.heappush(pq, (bottleneck_time, nr, nc))"
        }
      },
      "title": "Swim in Rising Water",
      "definition": "You are given an `N x N` grid of elevations. Find the minimum \"time\" `t` to travel from `(0, 0)` to `(N-1, N-1)`. You can only move between adjacent cells if their elevation is less than or equal to the time `t`",
      "leetcode": "https://leetcode.com/problems/swim-in-rising-water",
      "difficulty": "hard",
      "topics": ["dijkstra"]
    },
    "525-contiguous-array": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:57.931146",
        "updated_at": "2025-09-29T12:50:27.977981"
      },
      "solutions": {
        "solution.py": {
          "args": {
            "segments: list[int]": "List of integers (positive for forward, negative/zero for backward)."
          },
          "returns": "`int`: The length of the longest balanced subarray.",
          "code": "import sys, os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..','325-maximum-size-subarray-sum-equals-k'))\nfrom solution import maxSizeSubarraySumEqualsK\n\ndef findMaxLengthOfBalancedSubarray(segments: list[int]) -> int:\n\n    normalized_segments = [1 if num > 0 else -1 for num in segments]\n    return maxSizeSubarraySumEqualsK(normalized_segments, 0)"
        }
      },
      "title": "Contiguous Array",
      "definition": "Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.",
      "leetcode": "https://leetcode.com/problems/contiguous-array",
      "difficulty": "medium",
      "topics": ["prefix-sum"]
    },
    "3-longest-substring-without-repeating-characters": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:16.849870",
        "updated_at": "2025-10-03T14:18:45.257450"
      },
      "solutions": {
        "solution.py": {
          "time_complexity": "O(n)",
          "args": {
            "s: str": "Input string to analyze"
          },
          "expressions": {
            "l = max(c_idx[c] + 1, l)": "ensures that l does not move backward in cases where the last occurrence of s[r] was before l."
          },
          "returns": "`int`: Length of the longest substring without repeating characters",
          "code": "def longest_substring_without_repeating_characters(s: str) -> int:\n    c_idx, l, max_length = {}, 0, 0\n    for r, c in enumerate(s):\n        if c in c_idx:\n            l = max(c_idx[c] + 1, l)\n        c_idx[c] = r\n        max_length = max(max_length, r - l + 1)\n    return max_length"
        }
      },
      "title": "Longest Substring Without Repeating Characters",
      "definition": "Given a string `s`, find the length of the longest substring without repeating characters.",
      "leetcode": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
      "difficulty": "medium",
      "topics": ["sliding-window"]
    },
    "616-add-bold-tag-in-string": {
      "time_stamps": {
        "created_at": "2025-11-21T17:11:39.618476",
        "updated_at": "2025-11-23T13:19:32.023808"
      },
      "solutions": {
        "solution.py": {
          "code": "def addBoldTag(s: str, words: list[str]) -> str:\n\n    bold, end = [False] * (n := len(s)), 0\n    for i in range(n):\n        for w in words:\n            if s.startswith(w, i):\n                end = max(end, i + len(w))\n        bold[i] = i < end\n\n    out, i = [], 0\n    while i < n:\n        if not bold[i]:\n            out.append(s[i]); i += 1\n        else:\n            out.append(\"<b>\")\n            while i < n and bold[i]:\n                out.append(s[i]); i += 1\n            out.append(\"</b>\")\n    return \"\".join(out)"
        },
        "trie.py": {
          "code": "from collections import deque\n\nclass ACNode:\n    __slots__ = (\"next\", \"fail\", \"out\")\n    def __init__(self):\n        self.next = {}\n        self.fail = None\n        self.out = []\n\nclass Solution:\n    def addBoldTag(self, s: str, words: list[str]) -> str:\n        root = ACNode()\n        for w in words:\n            cur = root\n            for c in w:\n                cur = cur.next.setdefault(c, ACNode())\n            cur.out.append(len(w))\n\n        q = deque()\n        root.fail = root\n        for c, nxt in root.next.items():\n            nxt.fail = root\n            q.append(nxt)\n\n        while q:\n            u = q.popleft()\n            for c, v in u.next.items():\n                f = u.fail\n                while f is not root and c not in f.next:\n                    f = f.fail\n                v.fail = f.next.get(c, root)\n                v.out += v.fail.out\n                q.append(v)\n\n        intervals = []\n        cur = root\n        for i, ch in enumerate(s):\n            while cur is not root and ch not in cur.next:\n                cur = cur.fail\n            cur = cur.next.get(ch, root)\n            for L in cur.out:\n                intervals.append((i - L + 1, i))\n\n        if not intervals:\n            return s\n\n        intervals.sort()\n        merged = []\n        a, b = intervals[0]\n        for x, y in intervals[1:]:\n            if x <= b + 1:\n                b = max(b, y)\n            else:\n                merged.append((a, b))\n                a, b = x, y\n        merged.append((a, b))\n\n        out = []\n        idx = 0\n        for a, b in merged:\n            out.append(s[idx:a])\n            out.append(\"<b>\")\n            out.append(s[a:b+1])\n            out.append(\"</b>\")\n            idx = b + 1\n        out.append(s[idx:])\n        return \"\".join(out)"
        }
      },
      "title": "Add Bold Tag in String",
      "definition": "Given a string s and a list of words words, wrap every substring in s that matches any word in words with HTML bold tags <b> and </b>. If two such substrings overlap or are adjacent, merge them into one continuous bold-tagged region",
      "leetcode": "https://leetcode.com/problems/add-bold-tag-in-string/",
      "difficulty": "medium",
      "topics": ["TODO"]
    },
    "51-n-queens": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:16.850151",
        "updated_at": "2025-11-02T17:09:45.499196"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Backtrack with State Tracking â™›\n    Place one queen per row. Track blocked columns, diagonals: Valid placement â†’ recurse to next row, Invalid â†’ skip, After recursion, remove queen to try next column. Track state using: `cols` for columns, `diag1` for main diagonal *â†˜* `row - col`, `diag2` for anti-diagonal *â†™* `row + col`.",
          "time_complexity": "O(N!)\n    first row: N choices, second row: N-1 choices, total permutations = N!, pruning drastically reduces actual recursion tree.",
          "args": {
            "n: int": "Size of the chessboard (n x n)"
          },
          "variables": {
            "cols": "Columns where queens are placed",
            "diag1": "The main diagonal where queens are placed (â†˜) `r - c`",
            "diag2": "The anti-diagonal where queens are placed (â†™) `r + c`"
          },
          "expressions": {
            "`board[row][col] = \".\"`": "Remove the queen (backtrack)",
            "`board[row][col] = \"Q\"`": "Place the queen",
            "`continue`": "Skip invalid positions",
            "`dfs(row + 1)`": "Recurse to the next row"
          },
          "returns": "`list[list[str]]`: List of all valid queen placements",
          "code": "def n_queens(n: int) -> list[list[str]]:\n\n    result, board = [], [[\".\"] * n for _ in range(n)]\n\n    cols, diag1, diag2 = set(), set(), set()\n\n    def dfs(row: int):\n        if row == n:\n            result.append([\"\".join(r) for r in board])\n            return\n\n        for col in range(n):\n            if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                continue\n\n            board[row][col] = \"Q\"\n\n            cols.add(col)\n            diag1.add(row - col)\n            diag2.add(row + col)\n\n            dfs(row + 1)\n\n            board[row][col] = \".\"\n            cols.remove(col)\n            diag1.remove(row - col)\n            diag2.remove(row + col)\n\n    dfs(0)\n    return result"
        }
      },
      "title": "N-Queens",
      "definition": "Place n queens on an n x n board such that no two queens threaten each other. *[19!]meaning no two queens share the same row, column, or diagonal*.",
      "leetcode": "https://leetcode.com/problems/n-queens",
      "difficulty": "hard",
      "topics": ["backtrack", "game"]
    },
    "684-redundant-connection": {
      "time_stamps": {
        "created_at": "2025-10-28T11:35:49.425325",
        "updated_at": "2025-10-28T12:11:32.263782"
      },
      "solutions": {
        "solution.py": {
          "code": "class Solution:\n\n    def findRedundantConnection(self, edges: list[list[int]]) -> list[int]:\n\n        p = [*range(len(edges) + 1)]\n\n        def union(a, b):\n            p[a] = b\n\n        def find(x):\n            while x != p[x]:\n                p[x] = p[p[x]]\n                x = p[x]\n            return x\n\n        for u, v in edges:\n            if (a := find(u)) == (b := find(v)):\n                return [u, v]\n            union(a, b)\n        return [] "
        },
        "rank.py": {
          "code": "class Solution:\n    def findRedundantConnection(self, edges: list[list[int]]) -> list[int]:\n\n        p = [*range(len(edges) + 1)]\n        r = [0] * (len(edges) + 1)\n\n        def union(a, b):\n            if r[a] < r[b]:\n                a, b = b, a\n            p[b] = a\n            if r[a] == r[b]:\n                r[a] += 1\n\n        def find(x):\n            while x != p[x]:\n                p[x] = p[p[x]]\n                x = p[x]\n            return x\n\n        for u, v in edges:\n            if (a := find(u)) == (b := find(v)):\n                return [u, v]\n            union(a, b)\n\n        return []"
        }
      },
      "title": "Redundant Connection",
      "definition": "Given a tree with one extra edge added, return the edge that creates a cycleâ€”removing it restores the tree",
      "leetcode": "https://leetcode.com/problems/redundant-connection",
      "difficulty": "medium",
      "topics": ["dsu"]
    },
    "42-trapping-rain-water": {
      "time_stamps": {
        "created_at": "2025-11-10T09:04:29.440058",
        "updated_at": "2025-11-10T19:21:27.871578"
      },
      "solutions": {
        "two-pointer.py": {
          "intuition": "Water trapped above each bar depends on the smaller of the tallest walls to its left and right:\n    By keeping two pointersâ€”one at each endâ€”and always moving the smaller side inward, we ensure that the limiting wall for that side is already known.\n        When the left bar is shorter, we can safely compute water at left using lmax (its tallest left wall), because a taller or equal wall must exist on the right.\n        Symmetrically, when the right bar is shorter, we compute water using rmax.\n    This invariant guarantees every positionâ€™s water level is computed exactly once in O(n) time and O(1) space",
          "time_complexity": "O(n)",
          "code": "def trap(height: list[int]) -> int:\n    l, r = 0, len(height) - 1\n    lmax = rmax = water = 0\n\n    while l < r:\n        if (hl:=height[l]) < (hr:=height[r]):\n            lmax = max(lmax, hl)\n            water += lmax - hl\n            l += 1\n        else:\n            rmax = max(rmax, hr)\n            water += rmax - hr\n            r -= 1\n    return water"
        },
        "forward-fill-with-tail-closure.py": {
          "time_complexity": "O(n)",
          "code": "def trapping_rain_water(height: list[int]) -> int:\n    l = trapped = 0\n\n    for r, h in enumerate(height):\n        if h >= (wall := height[l]):\n            for v in height[l:r]:\n                trapped += wall - v\n            l = r\n\n    maxr = height[-1]\n    for v in reversed(height[l:]):\n        maxr = max(maxr, v)\n        trapped += max(0, maxr - v)\n\n    return trapped"
        }
      },
      "title": "Trapping Rain Water",
      "definition": "Given a list of n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
      "leetcode": "https://leetcode.com/problems/trapping-rain-water/",
      "difficulty": "hard",
      "topics": ["two-pointer"]
    },
    "498-diagonal-traverse": {
      "time_stamps": {
        "created_at": "2025-11-16T12:37:14.852802",
        "updated_at": "2026-01-18T19:04:58.385172"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Each diagonal is defined by `r + c = d`.\n    (note: always diagonal `r+c=d` â†—ï¸ ,not anti-diagonal `[red!]r-c=d` â†™ï¸)\n    Even-indexed diagonals `( d % 2 == 0)` must be read up-right â†—ï¸  ,\n        so we start from the lowest valid `(r,c)`.\n    Odd-indexed diagonals go down-left â†™ï¸,\n        so we start from the rightmost valid `(r,c)`.\n    Each diagonal is traversed once in its direction, collecting every cell exactly once.",
          "time_complexity": "O(m x n):\n        Every matrix cell is visited exactly once across all diagonals.",
          "code": "def diagonal_traverse(mat: list[list[int]]) -> list[int]:\n    m, n = len(mat), len(mat[0])\n    res = []\n    for d in range(m + n - 1):\n        if d % 2 == 0:\n            r = min(d, m - 1)\n            c = d - r\n            while r >= 0 and c < n:\n                res.append(mat[r][c])\n                r -= 1\n                c += 1\n        else:\n            c = min(d, n - 1)\n            r = d - c\n            while c >= 0 and r < m:\n                res.append(mat[r][c])\n                r += 1\n                c -= 1\n    return res"
        }
      },
      "title": "Diagonal Traverse",
      "definition": "Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order",
      "leetcode": "https://leetcode.com/problems/diagonal-traverse",
      "difficulty": "medium",
      "topics": ["matrix"]
    },
    "560-subarray-sum-equals-k": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:57.931241",
        "updated_at": "2025-09-29T12:53:12.615462"
      },
      "solutions": {
        "solution.py": {
          "args": {
            "segments: list[int]": "List of integers representing trip segments.",
            "k: int": "Target sum."
          },
          "returns": "`int`: The count of subarrays with sum == k.",
          "code": "from collections import defaultdict\n\ndef subarraySumEqualsK(segments: list[int], k: int) -> int:\n\n    marker_frequency = defaultdict(int, {0: 1})\n    prefix_sum = count = 0\n\n    for segment in segments:\n        prefix_sum += segment\n        count += marker_frequency[prefix_sum - k]\n        marker_frequency[prefix_sum] += 1\n\n    return count"
        }
      },
      "title": "Subarray Sum Equals K",
      "definition": "Given an array of integers and a target sum k, return the total number of continuous subarrays whose sum equals to k.",
      "leetcode": "https://leetcode.com/problems/subarray-sum-equals-k",
      "difficulty": "medium",
      "topics": ["prefix-sum"]
    },
    "312-burst-balloons": {
      "time_stamps": {
        "created_at": "2025-10-25T12:53:19.175675",
        "updated_at": "2025-10-26T20:58:37.576406"
      },
      "solutions": {
        "solution.py": {
          "code": "class Solution:\n    def maxCoins(self, nums: list[int]) -> int:\n\n        nums, memo = [1, *nums, 1], {}\n        cost = lambda l, r, k: nums[l] * nums[k] * nums[r]\n\n        def dp(l, r):\n            if (key := (l, r)) not in memo:\n                memo[key] = max(\n                    (dp(l, k) + dp(k, r) + cost(l, r, k) for k in range(l + 1, r)),\n                    default=0,\n                )\n            return memo[key]\n\n        return dp(0, len(nums) - 1)"
        }
      },
      "title": "Burst Balloons",
      "definition": "Burst balloons in any order; bursting i yields nums[iâˆ’1]*nums[i]*nums[i+1] (coedges = 1). Find the max coins possible.",
      "leetcode": "https://leetcode.com/problems/burst-balloons",
      "difficulty": "hard",
      "topics": ["dp", "interval-dp"]
    },
    "50-pow": {
      "time_stamps": {
        "created_at": "2025-11-12T16:08:37.700913",
        "updated_at": "2025-11-13T10:22:08.312102"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Compute $(x^n)$ using **binary exponentiation**:\n    Each iteration inspects the lowest bit of n:\n        if the bit is 1 â†’ include the current power (base) in the result,\n        square the base for the next power-of-two,\n        shift n right to move to the next bit.\n    For negative n, take the reciprocal and reuse the same logic.\n\n    Example:\n        x = 2, n = 13 â†’ 13 (1101â‚‚):\n            bit 1 â†’ multiply 2Â¹\n            bit 0 â†’ skip 2Â²\n            bit 1 â†’ multiply 2â´\n            bit 1 â†’ multiply 2â¸\n        Result = 2Â¹ Ã— 2â´ Ã— 2â¸ = 8192",
          "time_complexity": "O(log n):\n    one step per binary digit of n, (The number of bits in n is *$\\lfloor \\logâ‚‚ n \\rfloor + 1$* â€” fixed by the value of n itself.\n    It doesnâ€™t matter whether those bits are 0 or 1; the loop processes one bit per iteration, so the total work is always proportional to the bit-length of n, not the bit pattern.)",
          "expressions": {
            "if n < 0": "return 1 / myPow(x, -n)   (handle negative exponent)\n    'n & 1' :            check lowest bit          (1 â†’ use base)\n    'base *= base' :     move to next power-of-two (`x` â†’ `xÂ²` â†’ `xâ´` â†’ `xâ¸` â€¦)\n    'n >>= 1' :          bitwise right shift; same effect as `n //= 2` for `n â‰¥ 0`"
          },
          "args": {
            "x: float": "base (float)",
            "n: int": "exponent (int)"
          },
          "returns": "`float`: x raised to the power n.",
          "code": "def myPow(x: float, n: int) -> float:\n    if n == 0: return 1.0\n    if n < 0: return 1.0 / myPow(x, -n)\n\n    result, base = 1.0, x\n    while n:\n        if n & 1:\n            result *= base\n        base *= base\n        n >>= 1     \n    return result"
        }
      },
      "title": "Pow(x, n)",
      "definition": "Given a floating-point number x and an integer n, return xâ¿ (i.e., x raised to the power n). Constraints: -100.0 < x < 100.0, -2Â³Â¹ â‰¤ n â‰¤ 2Â³Â¹ âˆ’ 1, and -10â´ â‰¤ xâ¿ â‰¤ 10â´",
      "leetcode": "https://leetcode.com/problems/powx-n/",
      "difficulty": "medium",
      "topics": ["math", "binary exponentiation"]
    },
    "1590-make-sum-divisible-by-p": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:10.762653",
        "updated_at": "2025-09-29T12:49:52.934968"
      },
      "solutions": {
        "solution.py": {
          "args": {
            "segments: list[int]": "List of integers representing trip segments.",
            "p: int": "The divisor."
          },
          "returns": "`int`: The length of the shortest subarray to remove, or -1 if not possible.",
          "code": "def minSubarrayToMakeSumDivisibleByP(segments: list[int], p: int) -> int:\n\n    total_remainder = sum(segments) % p\n    if total_remainder == 0:\n        return 0\n\n    remainder_idx = {0: -1}\n    prefix_remainder, min_length = 0, len(segments)\n\n    for i, segment in enumerate(segments):\n        prefix_remainder = (prefix_remainder + segment) % p\n        need = (prefix_remainder - total_remainder + p) % p\n        if need in remainder_idx:\n            min_length = min(min_length, i - remainder_idx[need])\n        remainder_idx[prefix_remainder] = i\n\n    return min_length if min_length < len(segments) else -1"
        }
      },
      "title": "Make Sum Divisible by P",
      "definition": "Given an array of positive integers and a positive integer p, remove the shortest subarray such that the sum of the remaining elements is divisible by p. Return the length of the shortest subarray to remove, or -1 if not possible.",
      "leetcode": "https://leetcode.com/problems/make-sum-divisible-by-p",
      "difficulty": "medium",
      "topics": ["prefix-sum"]
    },
    "191-number-of-1-bits": {
      "time_stamps": {
        "created_at": "2025-10-03T12:08:53.211195",
        "updated_at": "2025-10-03T13:16:10.347547"
      },
      "solutions": {
        "bit_count.py": {
          "code": "def hammingWeight( n: int) -> int:\n    return n.bit_count()"
        },
        "brian-kernighan.py": {
          "intuition": "Brian Kernighan's algorithm:\n    counts the number of set bits (1s) in an integer efficiently by             repeatedly clearing the lowest set bit until the number becomes 0.\n\n    Deep Dive: Why this always works\n    When you subtract 1 from a binary number:\n            You flip the lowest set bit (1) to 0\n            And everything to the right of it flips to 1\n\n    Example:\n    Start\n        ```python\n            n = 13 (1101)\n            count = 0\n        ```\n    Iteration 1\n        ```python\n            n   = 1101 (13)\n            n-1 = 1100 (12)\n            ---------------- &\n                  1100 (12)\n            count = 1\n        ```\n    Iteration 2\n        ```python\n            n   = 1100 (12)\n            n-1 = 1011 (11)\n            ---------------- &\n                  1000 (8)\n            count = 2\n        ```\n    Iteration 3\n        ```python\n            n   = 1000 (8)\n            n-1 = 0111 (7)\n            ---------------- &\n                  0000 (0)\n            count = 3\n        ```",
          "time_complexity": "O(k):\n    where k = number of 1s (faster than looping 32 times)",
          "code": "def hammingWeight(n: int) -> int:\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count"
        }
      },
      "title": "Number of 1 Bits",
      "definition": "Given a positive integer, return the number set bits (1s) in it's binary representation",
      "leetcode": "https://leetcode.com/problems/number-of-1-bits",
      "difficulty": "Easy",
      "topics": ["bit-manipulation"]
    },
    "70-climbing-stairs": {
      "time_stamps": {
        "created_at": "2025-10-05T11:34:24.045380",
        "updated_at": "2025-10-05T19:58:41.319391"
      },
      "solutions": {
        "bottomup.py": {
          "code": "def climbStairs(n: int) -> int:\n    a = b = 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a"
        },
        "topdown.py": {
          "code": "def climbStairs(n: int) -> int:\n    memo = {}\n    def dp(i):\n        if i <= 0:\n            return i == 0\n        if i not in memo:\n            memo[i] = dp(i - 1) + dp(i - 2)\n        return memo[i]\n    return dp(n)"
        }
      },
      "title": "Climbing Stairs",
      "definition": "You are climbing a staircase. It takes `n` steps to reach the top.     Each time you can either climb `1` or `2` steps.    In how many distinct ways can you climb to the top?",
      "leetcode": "https://leetcode.com/problems/climbing-stairs",
      "difficulty": "easy",
      "topics": ["dynamic-programming"]
    },
    "918-maximum-sum-of-circular-subarray": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:03.946154",
        "updated_at": "2025-09-15T18:58:00.237782"
      },
      "solutions": {
        "solution.py": {
          "code": "def maximum_sum_of_circular_subarray(nums: list[int]) -> int:\n    total, max_end = min_end = 0\n    max_sum, min_sum = float(\"-inf\"), float(\"inf\")\n    for x in nums:\n        total += x\n        max_end = max(x, max_end + x)\n        max_sum = max(max_sum, max_end)\n        min_end = min(x, min_end + x)\n        min_sum = min(min_sum, min_end)\n    return max_sum if max_sum < 0 else max(max_sum, total - min_sum)"
        }
      },
      "title": "Maximum Sum of Circular Subarray",
      "definition": "Given a circular array of integers, return the maximum sum of any contiguous subarray.",
      "leetcode": "https://leetcode.com/problems/maximum-sum-of-circular-subarray",
      "difficulty": "medium",
      "topics": ["kadane"]
    },
    "215-kth-largest-element-in-an-array": {
      "time_stamps": {
        "created_at": "2025-10-04T12:12:22.407617",
        "updated_at": "2025-10-04T15:19:16.074591"
      },
      "solutions": {
        "solution.py": {
          "time_complexity": "O(n log k):\n    Deep Dive: one sift (faster constant) vs push+pop\n        heappush does a sift-up â†’ O(log k)\n        heappop does a sift-down â†’ O(log k)\n        total â‰ˆ 2 x O(log k) operations\n        heapreplace does one sift operation, not two\n        removes root, places new element, and does only one sift-down â†’ O(log k)\n        So same asymptotic complexity, but half the work, fewer comparisons and function calls â†’ faster constant factor.",
          "expressions": {
            "heapreplace(h, x)": "replaces root with x, performs one sift-down          â†’ O(log k) with ~Â½ the operations of heappush(sift-up)+heappop(sift-down) (â‰ˆ 2 Ã— O(log k))"
          },
          "code": "import heapq\n\ndef findKthLargest(nums: list[int], k: int) -> int:\n    h = nums[:k]; heapq.heapify(h)\n    for x in nums[k:]:\n        if x > h[0]:\n            heapq.heapreplace(h, x) \n    return h[0]"
        }
      },
      "title": "Kth Largest Element In An Array",
      "definition": "Given an integer array nums and an integer k, return the kth largest element in the array.",
      "leetcode": "https://leetcode.com/problems/kth-largest-element-in-an-array",
      "difficulty": "medium",
      "topics": ["heap", "min-heap"]
    },
    "198-house-robber": {
      "time_stamps": {
        "created_at": "2025-10-08T20:56:07.516185",
        "updated_at": "2025-10-24T12:21:01.225020"
      },
      "solutions": {
        "bottom-up-prefix.py": {
          "intuition": "Deep Dive: Subproblems: dp(i) = maximum money obtainable robbing prefix `houses[0..i]\n    for 0 â‰¤ i < n.  (*[14!]prefix â‰™ starting from 0 until i*)\n\n    Deep Dive: Relation: dp(i) = max(dp(i-1), houses[i] + dp(i-2))\n        Either skip house `i` (best stays `dp(i-1)`)\n        or rob it and skip `i-1` (best is `houses[i] + dp(i-2)`)\n\n    Deep Dive: Topo. order: Increasing i\n        Increasing i  (i = 0, 1, ..., n-1)\n\n    Deep Dive: Base: dp(0)\n        max money obtainable robbing the empty prefix `houses[0..0]`\n\n    Deep Dive: Original: dp(n)\n        maximum money obtainable robbing prefix `houses[0..n-1]` (the whole array)",
          "time_complexity": "O(n):\n    *Î˜(n)* subproblems, *Î˜(1)* work each â†’ *Î˜(n)* total",
          "variables": {
            "h1": "the best total so far (that is, dp(i-1), the best up to the previous house).",
            "h2": "the best total up to two houses ago (dp(i-2))."
          },
          "expressions": {
            "h2, h1 = h1, max(h1, h2 + h)": "choose best between:\n        - skipping this house â†’ keep h1 (dp(i-1))\n        - robbing this house â†’ add h to h2 (dp(i-2) + h)"
          },
          "code": "def rob(houses: list[int]) -> int:\n    h1, h2 = 0, 0\n    for h in houses:\n        h2, h1 = h1, max(h1, h2 + h)\n    return h1"
        },
        "top-down-suffix.py": {
          "expressions": {
            "max(dp(i + 1), houses[i] + dp(i + 2))": "Either skip house `i` *[1!](best stays `dp(i+1)`)*\n        or rob it and skip `i+1` *[2!](best is `houses[i] + dp(i+2)`)*"
          },
          "intuition": "Deep Dive: Subproblems: dp(i) = maximum money obtainable robbing **suffix** `houses[i..n-1]`,             for 0 â‰¤ i â‰¤ n.  (*[4!]suffix â‰™ starting from i until the end*)\n\n    Deep Dive: Relation: dp(i) = max(dp(i+1), houses[i] + dp(i+2))\n        Either skip house `i` (best stays `dp(i+1)`)\n        or rob it and skip `i+1` (best is `houses[i] + dp(i+2)`)\n\n    Deep Dive: Topo. order: Decreasing i\n        Subproblems `dp(i)` depend solely on strictly larger `i` so acyclic\n\n    Deep Dive: Base: dp(n)\n        max money obtainable robbing the empty suffix `houses[n..n]`\n\n    Deep Dive: Original: dp(0)\n        maximum money obtainable robbing suffix `houses[0..n-1]` (the whole array)",
          "time_complexity": "O(n):\n    *Î˜(n)* subproblems, *Î˜(1)* work each â†’ *Î˜(n)* total (with memoization)",
          "code": "def rob(houses: list[int]) -> int:\n\n    memo = {}\n    def dp(i: int) -> int:\n        if i >= len(houses):\n            return 0\n        if i not in memo:\n            memo[i] = max(dp(i + 1), houses[i] + dp(i + 2))\n        return memo[i]\n\n    return dp(0)"
        },
        "bottom-up-suffix.py": {
          "expressions": {
            "reversed(range(len(houses)))": "for i in range(len(houses) - 1, -1, -1)"
          },
          "code": "def rob(houses: list[int]) -> int:\n    h1 = h2 = 0\n    for i in reversed(range(len(houses))):\n        h1, h2 = max(h1, houses[i] + h2), h1\n    return h1"
        }
      },
      "title": "House Robber",
      "definition": "Given houses[i] = money in house i, return the maximum amount you can rob without robbing two adjacent house.",
      "leetcode": "https://leetcode.com/problems/house-robber",
      "difficulty": "medium",
      "topics": ["dynamic_programming", "dynamic_programming-1D"],
      "group": [["top-down-suffix.py"], ["bottom-up-suffix.py"], ["bottom-up-prefix.py"]]
    },
    "146-lru-cache": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:33.324105",
        "updated_at": "2025-10-10T11:47:41.674401"
      },
      "solutions": {
        "solution.py": {
          "code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache: OrderedDict[int, int] = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if (val := self.cache.get(key)) is None:\n            return -1\n        self.cache.move_to_end(key)\n        return val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)"
        }
      },
      "title": "LRU Cache",
      "definition": "A cache that evicts the least recently used item when the cache is full.",
      "leetcode": "https://leetcode.com/problems/lru-cache",
      "difficulty": "medium",
      "topics": ["cache"]
    },
    "102-binary-tree-level-order-traversal": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:33.323765",
        "updated_at": "2025-11-02T16:49:49.156635"
      },
      "solutions": {
        "solution.py": {
          "intuition": "The core logic hinges on the inner `for` loop\n    The expression `len(queue)` takes a \"snapshot\" of the number of nodes on the current level before the loop begins. The loop then dequeues and processes exactly that many nodes, ensuring that only nodes from the current level are handled while their children are queued up for the next iteration. This technique is the key to cleanly separating the levels.",
          "time_complexity": "O(n)\n    where n is the total number of nodes in the tree. This is optimal as every node must be visited once.",
          "args": {
            "root: TreeNode | None": "Root node of the binary tree"
          },
          "returns": "`list[list[int]]`: List of lists, where each inner list contains values of nodes at the same level",
          "code": "from collections import deque\nfrom core.Tree.binary_tree_node import TreeNode\n\nclass Solution:\n    def levelOrder(self, root: TreeNode | None) -> list[list[int]]:\n        if not root:\n            return []\n        q, result = deque([root]), []\n        while q:\n            level = []\n            for _ in range(len(q)):\n                u = q.popleft()\n                level.append(u.val)\n                if u.left:\n                    q.append(u.left)\n                if u.right:\n                    q.append(u.right)\n            result.append(level)\n        return result"
        },
        "similar.py": {
          "code": "from collections import deque\n\nclass Solution:\n    def levelOrder(self, root):\n        if not root:\n            return [] \n\n        result, q = [], deque([root])\n        while q:\n            result.append([n.val for n in q])\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node.left: \n                    q.append(node.left)\n                if node.right:  \n                    q.append(node.right)\n        return result "
        }
      },
      "title": "Binary Tree Level Order Traversal",
      "definition": "Given the root of a binary tree, return its nodes values organized by level , from left to right",
      "leetcode": "https://leetcode.com/problems/binary-tree-level-order-traversal",
      "difficulty": "medium",
      "topics": ["binary-tree", "bfs"]
    },
    "974-subarray-sums-divisible-by-k": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:03.946196",
        "updated_at": "2025-09-29T12:50:27.977945"
      },
      "solutions": {
        "solution.py": {
          "args": {
            "segments: list[int]": "List of integers representing trip segments.",
            "k: int": "The divisor."
          },
          "returns": "`int`: The count of subarrays with sum divisible by k.",
          "code": "from collections import defaultdict\n\ndef subarraysSumIsDivisibleByK(segments: list[int], k: int) -> int:\n    remainder_frequency = defaultdict(int, {0: 1})\n    prefix_remainder = count = 0\n\n    for segment in segments:\n        prefix_remainder = (prefix_remainder + segment) % k\n        count += remainder_frequency[prefix_remainder]\n        remainder_frequency[prefix_remainder] += 1\n    return count"
        }
      },
      "title": "Subarray Sums Divisible by K",
      "definition": "Given an array of integers and an integer k, return the number of non-empty subarrays that have a sum divisible by k.",
      "leetcode": "https://leetcode.com/problems/subarray-sums-divisible-by-k",
      "difficulty": "medium",
      "topics": ["prefix-sum"]
    },
    "2402-meeting-rooms-iii": {
      "time_stamps": {
        "created_at": "2025-11-05T10:38:18.353277",
        "updated_at": "2025-11-05T13:40:33.475953"
      },
      "solutions": {
        "solution.py": {
          "expressions": {
            "max(range(n), key=count.__getitem__)": "`range(n)` :creates `indices 0â€¦n-1`, then for each `index i`, calls `count.__getitem__(i)` (same as `count[i]`) to fetch the value; after comparing all, returns the `index i` whose `count[i]` is largest."
          },
          "code": "from heapq import heappush, heappop, heapify\n\ndef mostBooked(n: int, meetings: list[list[int]]) -> int:\n\n    busy = []\n    heapify((free := [*range(n)]))\n    count = [0] * n\n\n    for s, e in sorted(meetings):\n        while busy and busy[0][0] <= s:\n            _, r = heappop(busy)\n            heappush(free, r)\n        if free:\n            r = heappop(free)\n            heappush(busy, (e, r))\n        else:\n            next_end, r = heappop(busy)\n            heappush(busy, (next_end + (e - s), r))\n        count[r] += 1\n\n    return max(range(n), key=count.__getitem__)"
        }
      },
      "title": "Meeting Rooms III",
      "definition": "Given n rooms (0â€¦n-1) and meetings[i] = [startáµ¢, endáµ¢), assign each meeting to the lowest-numbered available room or delay it if none are free. Return the room that hosted the most meetings (tie â†’ smallest index). (Constraints: 1 â‰¤ n â‰¤ 100, 1 â‰¤ m â‰¤ 10âµ, 0 â‰¤ startáµ¢ < endáµ¢ â‰¤ 5Ã—10âµ)",
      "leetcode": "https://leetcode.com/problems/meeting-rooms-iii/",
      "difficulty": "hard",
      "topics": ["heap", "interval"]
    },
    "122-best-time-to-buy-and-sell-stock-ii": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:33.323910",
        "updated_at": "2025-09-17T16:17:51.939682"
      },
      "solutions": {
        "solution.py": {
          "code": "def best_time_to_buy_and_sell_stock_II(prices: list[int]) -> int:\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            profit += prices[i] - prices[i - 1]\n    return profit"
        }
      },
      "title": "Best Time to Buy and Sell Stock II",
      "definition": "Given a list of daily stock prices `prices`; you may complete multiple transactions (buy â†’ sell â†’ buy â€¦) but cannot hold more than one share at a time. Return the maximum total profit.",
      "leetcode": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii",
      "difficulty": "medium",
      "topics": ["greedy"]
    },
    "794-valid-tic-tac-toe-state": {
      "time_stamps": {
        "created_at": "2025-11-02T18:02:04.046880",
        "updated_at": "2025-11-02T19:54:10.541172"
      },
      "solutions": {
        "solution.py": {
          "code": "def valid_tic_tac_toe_state(board: list[str]) -> bool:\n\n    rows, cols = [0] * (n := 3), [0] * n\n    diag = anti_diag = diff = 0\n\n    for r, row in enumerate(board):\n        for c, p in enumerate(row):\n\n            diff += (d := 1 if p == \"X\" else -1 if p == \"O\" else 0)\n            rows[r] += d\n            cols[c] += d\n            diag += (r == c) * d\n            anti_diag += (r + c == n - 1) * d\n\n    win = lambda p: any(line == n * p for line in (diag, anti_diag, *rows, *cols))\n\n    x_win ,o_win = win(1), win(-1)\n\n    return not (diff < 0 or diff > 1 or x_win and o_win or x_win and diff != 1 or o_win and diff != 0 )"
        }
      },
      "title": "Valid Tic-Tac-Toe State",
      "definition": "Given a Tic Tac Toe board, check if itâ€™s reachable from a valid game where X starts and turns alternate",
      "leetcode": "https://leetcode.com/problems/valid-tic-tac-toe-state/",
      "difficulty": "medium",
      "topics": ["game", "matrix"]
    },
    "207-course-schedule": {
      "time_stamps": {
        "created_at": "2025-10-28T10:30:03.325215",
        "updated_at": "2025-10-29T17:12:44.194916"
      },
      "solutions": {
        "solution.py": {
          "intuition": "1. **Model**\n    Each course = a node.\n    Each prerequisite `[a, b]` = a directed edge `b â†’ a` (â€œb before aâ€).\n\n    2. **Goal**\n    Can we take all courses = does the graph have **no cycle**?\n    If a cycle exists, youâ€™ll never get a course with indegree 0 again.\n\n    3. **Idea (Kahnâ€™s algorithm)**\n    Compute **indegree** for each node (how many prereqs it has)\n    Put all nodes with indegree 0 into a queue (theyâ€™re ready)\n    While queue not empty:\n        Pop one â†’ mark as taken\n        For each neighbor (course unlocked by it), decrement indegree\n        If indegree becomes 0 â†’ enqueue it\n    If youâ€™ve taken all courses â†’ no cycle â†’ return True\n    Otherwise â†’ cycle â†’ return False",
          "variables": {
            "taken": "counter for how many courses we've \"completed\"",
            "g": "`g[b]` = list of courses unlocked by taking `b`",
            "indeg": "`indeg[a]` =  number of prerequisites left for course `a`"
          },
          "expressions": {
            "g[b].append(a)": "add edge `b â†’ a`\n    'indeg[a] += 1':    a has one more incoming edge\n    'deque(i for i, d in enumerate(indeg) if d == 0)' : Initialize queue with all courses having no prerequisites\n    'u = q.popleft()' : take a course with no remaining prereqs\n    'taken += 1' : increment the counter for how many courses we've \"completed\"\n    'for v in g[u]' : for each course unlocked by u\n    'indeg[v] -= 1' : one prerequisite is now satisfied\n    'if indeg[v] == 0' : if no prereqs left\n    'q.append(v)' : course is now ready to take\n    'taken == n' : If we managed to take all n courses, there was no cycle\n    'while q' : Process courses in BFS order"
          },
          "args": {
            "prerequisites: list[list[int]]": "$prerequisites[i]=[a_i, b_i]$ indicates that you *must* take course *$b_i$* first before taking course $a_i$ *(b â†’ a)*"
          },
          "code": "from collections import deque\n\nclass Solution:\n    def canFinish(self, n: int, prerequisites: list[list[int]]) -> bool:\n        g = [[] for _ in range(n)]     \n        indeg = [0] * n                \n        for a, b in prerequisites:\n            g[b].append(a)             \n            indeg[a] += 1              \n\n        q = deque(i for i, d in enumerate(indeg) if d == 0)\n        taken = 0                      \n\n        while q:\n            u = q.popleft()             \n            taken += 1\n            for v in g[u]:              \n                indeg[v] -= 1           \n                if indeg[v] == 0:       \n                    q.append(v)         \n\n        return taken == n"
        }
      },
      "title": "Course Schedule",
      "definition": "Given `n` number of courses and `prerequisites` *[pink!][a, b]* meaning *[pink!]b â†’ a*,     determine if all courses can be completed",
      "leetcode": "https://leetcode.com/problems/course-schedule",
      "difficulty": "medium",
      "topics": ["topological-sort", "kahn's algorithm"]
    },
    "33-search-in-rotated-sorted-array": {
      "time_stamps": {
        "created_at": "2025-10-04T15:24:13.926042",
        "updated_at": "2025-10-04T16:40:07.398403"
      },
      "solutions": {
        "solution.py": {
          "code": "def search(nums: list[int], target: int) -> int:\n\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[l] <= nums[mid]:\n            if nums[l] <= target < nums[mid]:\n                r = mid - 1\n            else:\n                l = mid + 1\n        else:\n            if nums[mid] < target <= nums[r]:\n                l = mid + 1\n            else:\n                r = mid - 1\n    return -1"
        }
      },
      "title": "Search In Rotated Sorted Array",
      "definition": "Given a sorted array that has been left-rotated at an unknown pivot, return the index of a target value if found, otherwise return -1.\n    *[pink!] time complexity O(logn)*.",
      "leetcode": "https://leetcode.com/problems/search-in-rotated-sorted-array",
      "difficulty": "medium",
      "topics": ["binary-search", "rotated-array"]
    },
    "124-binary-tree-maximum-path-sum": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:33.323992",
        "updated_at": "2025-09-15T18:58:00.232319"
      },
      "solutions": {
        "solution.py": {
          "code": "def binary_tree_maximum_path_sum(root) -> int:\n    best = float(\"-inf\")\n    def dfs(node):\n        nonlocal best\n        if not node:\n            return 0\n        l = max(dfs(node.left), 0)\n        r = max(dfs(node.right), 0)\n        best = max(best, node.val + l + r)\n        return node.val + max(l, r)\n\n    dfs(root)\n    return best"
        }
      },
      "title": "Binary Tree Maximum Path Sum",
      "definition": "Given a binary tree, find the maximum path sum.",
      "leetcode": "https://leetcode.com/problems/binary-tree-maximum-path-sum",
      "difficulty": "hard",
      "topics": ["kadane"]
    },
    "497-random-point-in-non-overlapping-rectangles": {
      "time_stamps": {
        "created_at": "2026-01-28T12:09:41.744566",
        "updated_at": "2026-01-28T12:29:33.436785"
      },
      "solutions": {
        "solution.py": {
          "code": "import bisect\nimport random\n\nclass Solution:\n    def __init__(self, rectangles: list[list[int]]):\n        p, s = [], 0\n        for a, b, x, y in rectangles:\n            s += (x - a + 1) * (y - b + 1)\n            p.append(s)\n        self.prefix, self.total, self.rectangles = p, s, rectangles\n\n    def pick(self) -> list[int]:\n        r = bisect.bisect_right(self.prefix, random.randrange(self.total))\n        a, b, x, y = self.rectangles[r]\n        return [random.randint(a, x), random.randint(b, y)]"
        }
      },
      "title": "Random Point in Non-overlapping Rectangles",
      "definition": "Given non-overlapping axis-aligned rectangles `rectangles[i]=[x1,y1,x2,y2]`,     where `(x1,y1)` is the bottom-left and `(x2,y2)` the top-right corner (integer coordinates, inclusive).\n    Implement a class Solution(rectangles) and a method `pick()`     such that each integer point inside the union of all rectangles is chosen with equal probability.",
      "leetcode": "https://leetcode.com/problems/random-point-in-non-overlapping-rectangles/description/",
      "difficulty": "medium",
      "topics": ["prefix-sum", "binary-search", "reservoir-sampling"]
    },
    "69-sqrt": {
      "time_stamps": {
        "created_at": "2025-11-12T16:06:51.559341",
        "updated_at": "2025-11-12T19:30:21.146437"
      },
      "solutions": {
        "binary-search.py": {
          "code": "def mySqrt(x: int) -> int:\n    l, r = 0, x // 2\n    while l <= r:\n        m = (l + r) // 2\n        if (p:=m * m) <= x < (m + 1) * (m + 1):\n            return m\n        (l, r) = (m + 1, r) if p < x else (l, m - 1)\n    return l"
        },
        "newtons-method.py": {
          "intuition": "We need the integer part of âˆšx:\n        Start with a guess `r = x`.\n            If `r` is **too large**, `rÂ²` exceeds `x`.\n            Dividing `x // r` gives a value **too small**, since dividing by something too big shrinks the result.\n            The true âˆšx lies **between** these two â€” `x//r` and `r`.\n            Averaging them, $r_{\\text{new}} = \\left\\lfloor \\frac{r + \\lfloor x / r \\rfloor}{2} \\right\\rfloor$,\n            moves the guess to the midpoint, cutting the error sharply.\n        Each step refines the balance:\n            if `rÂ² > x`, the average drops lower;\n            once `rÂ² â‰¤ x`, we stop.\n        This â€œbalance-and-refineâ€ loop homes in on âˆšx extremely fast â€” often in under 6â€“7 steps.\n\n    Correctness follows from the invariant:\n        âˆšx always remains between `x//r` and `r`.\n            Since `rÂ² > x â‡’ r > âˆšx â‡’ âˆšx > x/r â‡’ x//r â‰¤ âˆšx < r`.\n            The update average stays inside that interval: *$x//r â‰¤ r_{\\text{new}} < r$*,\n            ensuring `r` decreases but never falls below âˆšx.\n            Because r strictly drops while staying â‰¥ 1, the loop must stop when `rÂ² â‰¤ x`.\n            At that point, r is the largest integer with `rÂ² â‰¤ x`, i.e. âŒŠâˆšxâŒ‹.",
          "time_complexity": "O(log x) iterations in the worst case, typically constant for 32-bit inputs.\n    Each update:\n    $$r_{\\text{new}} = \\frac{r + x//r}{2}$$\n    halves the relative error â€” the method shows **quadratic convergence**:\n    $$E_{k+1} â‰ˆ cÂ·E_k^2$$\n    meaning the number of correct digits doubles each step.\n    Space is constant, storing only `x` and `r`.",
          "args": {
            "x: int": "Non-negative integer to take the square root of"
          },
          "returns": "`int`: The floor of âˆšx.",
          "expressions": {
            "r * r > x": "Loop continues while r is an overestimate of âˆšx\n    '(r + x // r) // 2':  Integer form of Newtonâ€™s update â€” averages the overestimate (r) and the underestimate (x//r)"
          },
          "variables": {
            "r": "Current approximation of âˆšx, refined each step"
          },
          "code": "def mySqrt(x: int) -> int:\n\n    if x < 2: return x\n    r = x\n    while r * r > x:\n        r = (r + x // r) // 2\n    return r"
        }
      },
      "title": "Sqrt(x)",
      "definition": "Given a non-negative integer x, compute and return the integer part of its square root (i.e., the floor value of âˆšx)     without using any built-in tools that directly compute powers or roots",
      "leetcode": "https://leetcode.com/problems/sqrtx/",
      "difficulty": "easy",
      "topics": ["math", "binary search", "newton's method"]
    },
    "1510-stone-game-iv": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:10.762509",
        "updated_at": "2025-11-29T00:07:34.753251"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Minimax:\n    *Paradigm*: This is a classic *impartial game* solved using the *Minimax* principle on game states.\n    *Insight*: A position is defined as *winning* if you can make *any* move to a position that you know is *losing* for your opponent. The DP builds this win/loss classification for every number of stones up to `n`, starting from the base case that 0 stones is a losing position.",
          "time_complexity": "O(n * sqrt(n))\n    try all squares for each `x`",
          "code": "def stone_game_IV(n: int) -> bool:\n\n    memo = {0: False}\n\n    def dp(n):\n        if n not in memo:\n            memo[n] = any(not dp(n - i**2) for i in range(int(n**0.5), 0, -1))\n        return memo[n]\n\n    return dp(n)"
        }
      },
      "title": "Stone Game IV",
      "definition": "Alice and Bob alternately take turns removing a perfect square from the board. The first player to have no moves loses. Return True if Alice wins, False otherwise.",
      "leetcode": "https://leetcode.com/problems/stone-game-iv",
      "difficulty": "hard",
      "topics": ["dp", "game", "minimax"]
    },
    "153-find-minimum-in-rotated-sorted-array": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:43.508577",
        "updated_at": "2025-09-29T12:42:20.260872"
      },
      "solutions": {
        "solution.py": {
          "intuition": "The goal is to find the *inflection point* in the rotated list (where the numbers switch from high to low) â€” this point is the minimum element.\n    We use a modified binary search to home in on this point.\n    The key is comparing the middle element `nums[mid]` with the rightmost element `nums[r]`. This comparison tells us which part of the array is currently sorted and can be discarded.\n        **Case 1: `nums[mid] < nums[r]`**\n            **Example:** In `[4, 5, 1, 2, 3]`, if `mid` points to `1`, `nums[mid]` (`1`) is less than `nums[r]` (`3`).\n            **Logic:** This indicates that the entire right portion of the array from `mid` to `r` (i.e., `[1, 2, 3]`) is sorted. The minimum element could be `nums[mid]` itself, or it could be to its left. We can safely search the left half (including `mid`) by setting `r = mid`.\n        **Case 2: `nums[mid] >= nums[r]`**\n            **Example:** In `[4, 5, 1, 2, 3]`, if `mid` points to `5` in an earlier step, `nums[mid]` (`5`) is greater than `nums[r]` (`3`).\n            **Logic:** This indicates that the inflection point (the minimum value) must lie to the right of `mid`. The left portion `[4, 5]` is sorted but contains values larger than the true minimum. We discard this left portion by setting `l = mid + 1`.\n    The loop terminates when `l` and `r` converge, at which point `nums[l]` is the smallest element.",
          "expressions": {
            "r = mid": "If nums[mid] is less than nums[r], the minimum is in the left half (inclusive of mid).",
            "l = mid + 1": "the smallest is on the right"
          },
          "code": "def find_minimum_in_rotated_sorted_array(nums: list[int]) -> int:\n\n    l, r = 0, len(nums) - 1\n    while l < r:\n        mid = (l + r) // 2\n        if nums[mid] < nums[r]:\n            r = mid\n        else:\n            l = mid + 1 \n    return nums[l]"
        }
      },
      "title": "Find Minimum in Rotated Sorted Array",
      "definition": "Given a unique-element sorted array that has been rotated at an unknown pivot, find its minimum value.",
      "leetcode": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array",
      "difficulty": "medium",
      "topics": ["binary-search"]
    },
    "994-rotting-oranges": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:03.946253",
        "updated_at": "2025-11-02T20:08:52.754379"
      },
      "solutions": {
        "solution.py": {
          "code": "from collections import deque\n\ndef orangesRotting( grid: list[list[int]]) -> int:\n\n    R, C = len(grid), len(grid[0])\n    fresh, q = 0, deque()\n\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append((r, c))\n\n    if not fresh:\n        return 0\n\n    minute = 0\n    while q and fresh:\n        minute += 1\n        for _ in range(len(q)):\n            y, x = q.popleft()\n            for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                if 0 <= (i := y + dy) < R and 0 <= (j := x + dx) < C and grid[i][j] == 1:\n                    grid[i][j] = 2\n                    fresh -= 1\n                    q.append((i, j))\n    return -1 if fresh else minute"
        }
      },
      "title": "Rotting Oranges",
      "definition": "Given an `m x n` 2D grid of `0`s (empty), `1`s (fresh), and `2`s (rotten), every minute, any fresh orange adjacent to a rotten one becomes rotten. Return the minimum minutes required until no fresh oranges remain. If it's impossible, return -1.",
      "leetcode": "https://leetcode.com/problems/rotting-oranges",
      "difficulty": "medium",
      "topics": ["bfs", "multi-source bfs"]
    },
    "1547-minimum-cost-to-cut-a-stick": {
      "time_stamps": {
        "created_at": "2025-10-25T15:40:33.947699",
        "updated_at": "2025-11-02T16:50:24.816871"
      },
      "solutions": {
        "solution.py": {
          "code": "class Solution:\n    def minCost(self, n: int, cuts: list[int]) -> int:\n\n        cuts, memo = [0, *sorted(cuts), n], {}\n        cost = lambda l, r: cuts[r] - cuts[l]\n\n        def dp(l, r):\n            if (l, r) not in memo:\n                memo[l, r] = min(\n                    (dp(l, k) + dp(k, r) + cost(l, r) for k in range(l + 1, r)),\n                    default=0,\n                )\n            return memo[l, r]\n\n        return dp(0, len(cuts) - 1)"
        }
      },
      "title": "Minimum Cost to Cut a Stick",
      "definition": "Given a stick of length n and cut positions, each cut costs the stick's current length.    Find the minimum total cost to make all cuts\n    + `[7!]2 <= n <= 10^6` , `[7!]1 <= cuts.length <= min(n - 1, 100)` , `[7!]1 <= cuts[i] <= n - 1`\n    + *[8!]All the integers in cuts array are distinct*",
      "leetcode": "https://leetcode.com/problems/minimum-cost-to-cut-a-stick/",
      "difficulty": "hard",
      "topics": ["dp", "interval-dp"]
    },
    "121-best-time-to-buy-and-sell-stock": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:33.323875",
        "updated_at": "2025-10-10T11:47:38.013491"
      },
      "solutions": {
        "solution.py": {
          "time_complexity": "O(n)\n    where n is the length of the prices array. We iterate through the array once.",
          "args": {
            "prices: list[int]": "List of stock prices"
          },
          "returns": "`int`: Maximum profit from buying and selling stock",
          "code": "def best_time_to_buy_and_sell_stock(prices: list[int]) -> int:\n    cost, profit = float(\"inf\"), 0\n    for price in prices:\n        cost = min(cost, price)\n        profit = max(profit, price - cost)\n    return profit"
        }
      },
      "title": "Best Time to Buy and Sell Stock",
      "definition": "Given a list of daily stock prices `prices`; choose one day to buy and a later day to sell for maximum profit. Return the max profit, or `0` if no profit is possible.",
      "leetcode": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
      "difficulty": "easy",
      "topics": ["dynamic-programming"]
    },
    "53-maximum-subarray": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:16.850187",
        "updated_at": "2025-11-28T17:40:12.545297"
      },
      "solutions": {
        "solution.py": {
          "intuition": "This is essentially *Kadane's Algorithm*:\n        Kadaneâ€™s Algorithm is an $O(n)$ dynamic programming method for finding the maximum subarray sum in a list of integers (contiguous elements).\n        Core idea:\n            Keep track of the best sum ending at the current position\n            If adding the current number hurts the sum, start fresh from the current number\n            Track the overall maximum as you go\n\n\n    Deep Dive: SRT BOT:\n        Subproblem: `dp(i) = max(nums[i], nums[i] + dp(i-1))`\n        Relate: `dp(i)` depends only on `dp(i-1)`\n        Topological order: increasing `i`\n        Base case: `dp(0) = nums[0]`\n        Original problem: `max(dp(i))` over all i",
          "time_complexity": "O(n)",
          "space_complexity": "O(1)",
          "variables": {
            "curr_sum": "the best subarray sum ending at the current index",
            "max_sum": "the best subarray sum found so far"
          },
          "expressions": {
            "curr_sum = max(num, curr_sum + num)": "If extending the previous subarray lowers the sum (`num > curr_sum + num `), start a new subarray from the current element"
          },
          "args": {
            "nums: list[int]": "list of integers (can include negatives)"
          },
          "returns": "`int`: int: Maximum subarray sum",
          "code": "def maximum_subarray(nums: list[int]) -> int:\n    max_sum = curr_sum = float(\"-inf\")\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum"
        }
      },
      "title": "Maximum Subarray",
      "definition": "Given an array of integers, return the maximum sum of any contiguous subarray.",
      "leetcode": "https://leetcode.com/problems/maximum-subarray",
      "difficulty": "medium",
      "topics": ["kadane", "dp"]
    },
    "1570-dot-product-of-two-sparse-vectors": {
      "time_stamps": {
        "created_at": "2025-10-24T15:31:44.411566",
        "updated_at": "2025-10-24T15:34:23.802860"
      },
      "solutions": {
        "solution.py": {
          "code": "class SparseVector:\n    __slots__ = (\"m\",)\n    def __init__(self, nums: list[int]):\n        self.m = {i: v for i, v in enumerate(nums) if v}\n\n    def dotProduct(self, vec: 'SparseVector') -> int:  \n        a, b = (self.m, vec.m) if len(self.m) <= len(vec.m) else (vec.m, self.m)\n        s = 0\n        for i, v in a.items():          \n            if (w := b.get(i)) is not None:\n                s += v * w\n        return s"
        }
      },
      "title": "Dot Product of Two Sparse Vectors",
      "definition": "Given two sparse vectors, compute their dot product",
      "leetcode": "https://leetcode.com/problems/dot-product-of-two-sparse-vectors/description/",
      "difficulty": "medium",
      "topics": ["vector", "hash-table"]
    },
    "34-find-first-and-last-position-of-element-in-sorted-array": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:16.849941",
        "updated_at": "2025-09-29T12:42:20.261137"
      },
      "solutions": {
        "solution.py": {
          "code": "from bisect import bisect_left, bisect_right\n\ndef find_first_and_last_position_of_element_in_sorted_array(nums: list[int], target: int) -> list[int]:\n\n    start = bisect_left(nums, target)\n    if start < len(nums) and nums[start] == target:\n        return start, bisect_right(nums, target) - 1\n    return -1, -1"
        }
      },
      "title": "Find First and Last Position of Element in Sorted Array",
      "definition": "Given a sorted array of integers `nums` that may contain duplicates, find the starting and ending indices of a given `target`. If the target is not in the array, return `[-1, -1]`.",
      "leetcode": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
      "difficulty": "medium",
      "topics": ["binary-search"]
    },
    "348-design-tic-tac-toe": {
      "time_stamps": {
        "created_at": "2025-11-02T18:03:24.304336",
        "updated_at": "2025-11-02T19:58:35.324908"
      },
      "solutions": {
        "solution.py": {
          "code": "class TicTacToe:\n\n    def __init__(self, n: int):\n\n        self.n = n\n        self.rows, self.cols = [0] * n, [0] * n\n        self.diag = self.anti_diag = 0\n\n    def move(self, r: int, c: int, player: int) -> int:\n\n        p = 1 if player == 1 else -1\n\n        self.cols[c] += p\n        self.rows[r] += p\n        self.diag += (c == r) * p\n        self.anti_diag += (c == self.n - 1 - r) * p\n\n        return player if self.n*p in [ self.rows[r] , self.cols[c] , self.diag , self.anti_diag ] else 0"
        }
      },
      "title": "Design Tic-Tac-Toe",
      "definition": "Design an nÃ—n Tic Tac Toe class with move(row, col, player) that records the move and returns 0 if no one won yet, or the winning playerâ€™s number",
      "leetcode": "https://leetcode.com/problems/design-tic-tac-toe",
      "difficulty": "medium",
      "topics": ["game", "matrix", "simulation"]
    },
    "76-minimum-window-substring": {
      "time_stamps": {
        "created_at": "2025-10-03T14:38:56.852556",
        "updated_at": "2025-10-03T15:41:07.016797"
      },
      "solutions": {
        "solution.py": {
          "time_complexity": "O(m + n)",
          "code": "from collections import Counter, defaultdict\n\ndef minWindow(s: str, t: str) -> str:\n    t_count, have = Counter(t), defaultdict(int)\n    letters_needed, min_idx, l = len(t_count), None, 0\n    for r, c in enumerate(s):\n        have[c] += 1\n        if have[c] == t_count[c]:\n            letters_needed -= 1\n            while letters_needed == 0:\n                if not min_idx or r - l + 1 < min_idx[1] - min_idx[0]:\n                    min_idx = l, r + 1\n                have[s[l]] -= 1\n                if have[s[l]] < t_count[s[l]]:\n                    letters_needed += 1\n                l += 1\n    return \"\" if min_idx == None else s[min_idx[0] : min_idx[1]]"
        }
      },
      "title": "Minimum Window Substring",
      "definition": "Given two strings `s` and `t` of lengths `m` and `n` respectively,     return the minimum window substring of `s` such that every character in `t` (including duplicates)     is included in the window. If no such window exists, return an empty string `\"\"`,\n    *[19!]solve it in linear time complexity O(m + n)*",
      "leetcode": "https://leetcode.com/problems/minimum-window-substring",
      "difficulty": "hard",
      "topics": ["sliding-window"]
    },
    "84-largest-rectangle-in-histogram": {
      "time_stamps": {
        "created_at": "2025-09-29T10:05:50.776011",
        "updated_at": "2025-10-04T11:59:05.354285"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Each bar can form a rectangle where its height is the limiting factor:\n    That rectangle extends until a strictly shorter bar appears on either side.\n    Instead of searching both directions explicitly, we discover these bounds on the fly:\n        when a shorter bar appears at `r`, every taller bar popped from the stack\n        now knows its right boundary (`r`) and its left boundary (`l = stack.pop()`).\n\n    Deep Dive: Walkthrough:\n    Append `0` so every bar eventually meets a shorter right neighbor\n    Keep *[3!]indices* in strictly increasing heights (stack starts *[3!][-1]*)\n    For each `r, h`: while top is taller, pop `l` and compute area = `heights[l] * (r - stack[-1] - 1)`\n    Push `r`; remove the sentinel; return best",
          "time_complexity": "O(n):\n    Each index is pushed once and popped once, so the total operations across the loop are linear\n    *[19!]It remains linear despite the inner while, because every pop is matched to one push*",
          "expressions": {
            "heights.append(0)": "adds a **right sentinel** bar smaller than all others, forcing the stack to empty and compute all remaining areas at the end (no leftover bars).",
            "stack = [-1]": "adds a **left sentinel** index before the array start, so width computation `r - stack[-1] - 1` always works (never empty stack).",
            "heights[stack[-1]] > h": "pop while current bar is lower than stack's top",
            "width = r - stack[-1] - 1": "We subtract 1 because the bar at stack[-1] is strictly smaller and marks the left boundary, which is excluded from the rectangle",
            "heights.pop()": "restore original list"
          },
          "variables": {
            "stack": "indices with strictly increasing heights"
          },
          "code": "def largestRectangleArea(heights: list[int]) -> int:\n    heights.append(0)\n    stack = [-1]; best = 0\n    for r, h in enumerate(heights):\n        while stack[-1] != -1 and heights[stack[-1]] > h:\n            l = stack.pop()\n            best = max(best, heights[l] * (r - stack[-1] - 1))\n        stack.append(r)\n    heights.pop()\n    return best"
        }
      },
      "title": "Largest Rectangle in Histogram",
      "definition": "Given an array of integers representing the histogram's bar heights where the width of each bar is 1,     return the area of the largest rectangle in the histogram.",
      "leetcode": "https://leetcode.com/problems/largest-rectangle-in-histogram",
      "difficulty": "hard",
      "topics": ["stack"]
    },
    "136-single-number": {
      "time_stamps": {
        "created_at": "2025-09-30T11:20:36.046635",
        "updated_at": "2025-10-03T12:14:39.572548"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Using bitwise XOR to cancel out the duplicates:\n    XOR cancels pairs (a^a=0, a^0=a; associative/commutative), so the lone element remains\n\n    Deep Dive: XOR Reminder\n    XOR properties:\n            a ^ a = 0 (a number XOR itself is zero)\n            a ^ 0 = a (a number XOR zero is itself)\n            Commutative: a ^ b = b ^ a\n            Associative: (a ^ b) ^ c = a ^ (b ^ c)\n        Meaning:\n        Because order and grouping don't matter, you can XOR all numbers in any sequence\n        Cancellation:\n        Each pair of identical numbers a ^ a becomes 0\n        XORing by zero doesn't change the result\n        Result:\n        After all pairs cancel, only the unpaired (single) element remains\n    Example:\n        nums = [**[1!]4**, **[10!]1**, **[14!]2**, **[10!]1**, **[14!]2**]\n        **[1!]4** ^ **[10!]1** ^ **[14!]2** ^ **[10!]1** ^ **[14!]2**\n        **[10!](1 ^ 1)** ^ **[14!](2 ^ 2)** ^ **[1!]4**\n        **[10!]0** ^ **[14!]0** ^ **[1!]4** = **[1!]4**",
          "time_complexity": "O(n):\n    where n is the number of elements in the nums array",
          "code": "def singleNumber(nums: list[int]) -> int:\n    x = 0\n    for v in nums:\n        x ^= v\n    return x"
        }
      },
      "title": "Single Number",
      "definition": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.    *[sky!]Achieve *linear* time complexity and *constant* space complexity.*",
      "leetcode": "https://leetcode.com/problems/single-number",
      "difficulty": "Easy",
      "topics": ["bit-manipulation"]
    },
    "311-sparse-matrix-multiplication": {
      "time_stamps": {
        "created_at": "2025-11-13T10:31:46.730091",
        "updated_at": "2025-11-13T11:57:47.360958"
      },
      "solutions": {
        "naive.py": {
          "code": "def sparse_matrix_multiplication( mat1: list[list[int]], mat2: list[list[int]] ) -> list[list[int]]:\n\n    m, k, n = len(mat1), len(mat1[0]), len(mat2[0])\n    res = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            for t in range(k):\n                res[i][j] += mat1[i][t] * mat2[t][j]\n    return res"
        },
        "optimized.py": {
          "code": "def sparse_matrix_multiplication(A: list[list[int]], B: list[list[int]]) -> list[list[int]]:\n\n    m, n = len(A), len(B[0])\n    C = [[0] * n for _ in range(m)]\n\n    A_rows = [[(c, v) for c, v in enumerate(row) if v] for row in A]\n    B_rows = [[(c, v) for c, v in enumerate(row) if v] for row in B]\n\n    for i, row in enumerate(A_rows):\n        for k, a in row:\n            for j, b in B_rows[k]:\n                C[i][j] += a * b\n\n    return C"
        }
      },
      "title": "Sparse Matrix Multiplication",
      "definition": "Given two sparse matrices mat1 of size m x k and mat2 of size k x n, return the result of mat1 x mat2.You may assume that multiplication is always possible",
      "leetcode": "https://leetcode.com/problems/sparse-matrix-multiplication/",
      "difficulty": "medium",
      "topics": ["matrix"],
      "group": [["optimized.py"], ["naive.py"]]
    },
    "210-course-schedule-ii": {
      "time_stamps": {
        "created_at": "2025-10-28T11:22:57.625379",
        "updated_at": "2025-10-28T11:32:15.910635"
      },
      "solutions": {
        "solution.py": {
          "code": "from collections import deque\n\nclass Solution:\n    def findOrder(self, n: int, prerequisites: list[list[int]]) -> list[int]:\n        g = [[] for _ in range(n)]\n        indeg = [0] * n\n        for a, b in prerequisites: g[b].append(a); indeg[a] += 1\n        q = deque(i for i, d in enumerate(indeg) if d == 0)\n        order = []\n        while q:\n            u = q.popleft(); order.append(u)\n            for v in g[u]:\n                indeg[v] -= 1\n                if indeg[v] == 0: q.append(v)\n        return order if len(order) == n else []"
        }
      },
      "title": "Course Schedule II",
      "definition": "Given `n` number of courses and `prerequisites` *[pink!][a, b]* meaning *[pink!]b â†’ a*,     find a valid order to take all courses or return `[]` if none exists",
      "leetcode": "https://leetcode.com/problems/course-schedule-ii/",
      "difficulty": "medium",
      "topics": ["topological-sort", "kahn's algorithm"]
    },
    "1563-stone-game-v": {
      "time_stamps": {
        "created_at": "2025-11-10T19:31:01.397119",
        "updated_at": "2025-11-10T21:44:00.716672"
      },
      "solutions": {
        "bottom-up.py": {
          "intuition": "Split i..j into two parts; you can only keep the smaller-sum side,\n    or either if equal. dp[i][j] = best score in a[i..j].\n    mx[i][j] = best score + sum for a[i..j], to reuse quickly.\n\n    Deep Dive:\n    Each move divides the array into left and right parts. You can only continue with the side whose total sum is smaller; if equal, you may choose either. The goal is to maximize the total score gained from chosen parts.\n    We iterate over all subarrays i..j, expanding outward and adjusting a pointer mid so that the right part stays as large as possible without exceeding half of the total. This ensures we check only balanced splits instead of every possible index.\n    dp[i][j] stores the best score for i..j, while mx[i][j] caches the best â€œscore + sumâ€ prefix or suffix to quickly reuse.",
          "time_complexity": "O(n^2):\n    Because each subarray `i..j` is processed once and the middle pointer `mid` moves **monotonically** (never resets for a fixed `j`), every index is advanced at most O(1) times per outer loop.\n    Thus the total work is roughly proportional to the number of `(i, j)` pairs, giving **O(nÂ²)** time and **O(nÂ²)** space (for `dp` and `mx`).",
          "code": "def stone_game_v(a: list[int]) -> int:\n    n = len(a)\n    dp = [[0] * n for _ in range(n)]\n    mx = [[0] * n for _ in range(n)]\n    for i, v in enumerate(a):\n        mx[i][i] = v\n\n    for j in range(1, n):\n        mid = j\n        left = a[j]\n        right = 0\n        for i in range(j - 1, -1, -1):\n            left += a[i]\n\n            while (right + a[mid]) * 2 <= left:\n                right += a[mid]\n                mid -= 1\n\n            best = 0\n            if right * 2 == left:\n                best = mx[i][mid]\n            if mid != i:\n                best = max(best, mx[i][mid - 1])\n            if mid != j:\n                best = max(best, mx[j][mid + 1])\n\n            dp[i][j] = best\n            mx[i][j] = max(mx[i][j - 1], best + left)\n            mx[j][i] = max(mx[j][i + 1], best + left)\n\n    return dp[0][n - 1]"
        },
        "top-down.py": {
          "code": "def stone_game_v(a: list[int]) -> int:\n    n = len(a)\n    memo: dict[tuple[int, int], int] = {}\n    mx: dict[tuple[int, int], int] = {}\n    built = [False] * n\n\n    for i, v in enumerate(a):\n        memo[(i, i)] = 0\n        mx[(i, i)] = v\n\n    def build(j: int) -> None:\n        if built[j]:\n            return\n        if j:\n            build(j - 1)\n        built[j] = True\n\n        mid = j\n        left = a[j]\n        right = 0\n\n        for i in range(j - 1, -1, -1):\n            left += a[i]\n\n            while mid >= i and (right + a[mid]) * 2 <= left:\n                right += a[mid]\n                mid -= 1\n\n            best = 0\n            if right * 2 == left and mid >= i:\n                best = mx[(i, mid)]\n            if mid > i:\n                best = max(best, mx[(i, mid - 1)])\n            if mid < j:\n                best = max(best, mx[(j, mid + 1)])\n\n            memo[(i, j)] = best\n\n            cur = best + left\n            mx[(i, j)] = max(mx[(i, j - 1)], cur)\n            mx[(j, i)] = max(mx.get((j, i + 1), 0), cur)\n\n    def dp(i: int, j: int) -> int:\n        if i >= j:\n            return 0\n        build(j)\n        return memo[(i, j)]\n\n    return dp(0, n - 1)"
        }
      },
      "title": "Stone Game V",
      "definition": "Given an array of stone values, split it into two non-empty parts repeatedly. You gain the sum of the chosen side if its total is not smaller than the otherâ€™s. Return the maximum score achievable by optimal play",
      "leetcode": "https://leetcode.com/problems/stone-game-v/",
      "difficulty": "hard",
      "topics": ["dp", "game"]
    },
    "1514-path-with-maximum-probability": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:10.762600",
        "updated_at": "2025-11-02T16:50:20.243683"
      },
      "solutions": {
        "bellman-ford.py": {
          "intuition": "Bellman-Ford variant to maximize product of probabilities.\n    Each node tracks the maximum probability to reach it from `start`.",
          "args": {
            "n: int": "number of nodes",
            "edges: list[list[int]]": "edges[i] = [u, v] is an undirected edge connecting the nodes u and v with a probability of success of traversing that edge succProb[i].",
            "succProb: list[float]": "list of probabilities, e.g. [0.5,0.5,0.2],"
          },
          "code": "class Solution:\n    def maxProbability(self, n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float:\n        prob = [0.0] * n\n        prob[start] = 1.0\n\n        for _ in range(n - 1):\n            updated = False\n            for (u, v), p in zip(edges, succProb):\n                if prob[u] * p > prob[v]:\n                    prob[v] = prob[u] * p\n                    updated = True\n                if prob[v] * p > prob[u]:\n                    prob[u] = prob[v] * p\n                    updated = True\n            if not updated:\n                break\n\n        return prob[end]"
        },
        "dijkstra.py": {
          "intuition": "We want the path from `start` to `end` with the largest product of edge probabilities:\n    This is equivalent to Dijkstraâ€™s algorithm, replacing *sum of distances* with             *product of probabilities* and switching from a *[2!]min-heap* to a *[2!]max-heap*.\n\n    Deep Dive: Correctness:\n        Each edge weight (probability) *$\\in [0, 1]$*.\n        Multiplying by a value *$\\leq 1$* never increases the product, so the total probability                   along any path is monotonically non-increasing as the path length grows.\n        This monotonicity guarantees that *once we extract a node with the current                   maximum probability from the heap, no later path can improve it.*\n            same invariant that makes Dijkstra correct for nonnegative edge weights.\n            By contrast, *longest path* problems fail this property because edge weights                 can be positive and cumulative, allowing cycles to increase total weight                 indefinitely (no monotonic bound), making them *NP-hard*.",
          "returns": "`float`: Maximum probability to reach `end` from `start`, or 0.0 if unreachable.",
          "code": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\nclass Solution:\n    def maxProbability(self, n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float:\n\n        adj = defaultdict(list)\n        for (u, v), p in zip(edges, succProb):\n            adj[u].append((v, p))\n            adj[v].append((u, p))\n\n        pq, best = [(-1.0, start)], [0.0] * n\n        best[start] = 1.0\n\n        while pq:\n            p, u = heappop(pq)\n            p = -p\n            if u == end:\n                return p\n            if p < best[u]:\n                continue\n            for v, w in adj[u]:\n                new_p = p * w\n                if new_p > best[v]:\n                    best[v] = new_p\n                    heappush(pq, (-new_p, v))\n        return 0.0"
        }
      },
      "title": "Path with Maximum Probability",
      "definition": "Given an undirected graph with edges representing traversal probabilities, return the success probability of the path from a `start` to an `end` node with the highest success probability.",
      "leetcode": "https://leetcode.com/problems/path-with-maximum-probability",
      "difficulty": "medium",
      "topics": ["dijkstra", "bellman-ford"],
      "group": [["dijkstra.py"], ["bellman-ford.py"]]
    },
    "253-meeting-rooms-ii": {
      "time_stamps": {
        "created_at": "2025-11-05T10:36:51.032260",
        "updated_at": "2025-11-06T11:48:32.309893"
      },
      "solutions": {
        "two-pointer-interval-sort-and-scan.py": {
          "intuition": "1. Sort all *start times* and all *end times*\n\n    2. For each start time:\n        if it is earlier than the earliest end time we haven't used yet,                no room has freed -> take a new room.\n        otherwise, advance the end pointer -> reuse that freed room\n\n    `rooms` becomes the maximum number of simultaneous meetings",
          "time_complexity": "O(n log n) for sorting",
          "code": "def minMeetingRooms(intervals: list[list[int]]) -> int:\n    starts = sorted(s for s, _ in intervals)\n    ends = sorted(e for _, e in intervals)\n    rooms = e = 0\n    for s in starts:\n        if s < ends[e]:\n            rooms += 1\n        else:\n            e += 1\n    return rooms"
        },
        "sweep-line.py": {
          "intuition": "Each start adds a room (+1), each end frees one (-1).\n    Sweeping sorted times, track active meetings; the peak is the answer.",
          "time_complexity": "O(n log n)",
          "code": "from collections import defaultdict\n\ndef minMeetingRooms(intervals):\n\n    time = defaultdict(int)\n    for s, e in intervals:\n        time[s] += 1\n        time[e] -= 1\n\n    active = rooms = 0\n    for _, d in sorted(time.items()):\n        active += d\n        rooms = max(active, rooms)\n    return rooms"
        }
      },
      "title": "Meeting Rooms II",
      "definition": "Given `intervals[i] = [startáµ¢, endáµ¢]`, return the minimum number of conference rooms required so that no meetings overlap (Constraints: 1 â‰¤ intervals.length â‰¤ 10â´ ,0 â‰¤ startáµ¢ < endáµ¢ â‰¤ 10â¶)",
      "leetcode": "https://leetcode.com/problems/meeting-rooms-ii",
      "difficulty": "medium",
      "topics": ["sort", "sweep-line", "interval"]
    },
    "72-edit-distance": {
      "time_stamps": {
        "created_at": "2025-10-25T11:37:09.566865",
        "updated_at": "2025-10-26T21:09:04.530196"
      },
      "solutions": {
        "solution.py": {
          "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n\n        n1, n2, memo = len(word1), len(word2), {}\n\n        def dp(i, j):\n            if i >= n1: return n2 - j\n            if j >= n2: return n1 - i\n            if (k := (i, j)) not in memo:\n                memo[k] = ( \n                    dp(i + 1, j + 1) if word1[i] == word2[j] \n                    else 1 + min(dp(i + 1, j), dp(i, j + 1), dp(i + 1, j + 1))\n                )\n            return memo[k]\n\n        return dp(0, 0)"
        }
      },
      "title": "Edit Distance",
      "definition": "Given two strings a and b, return the minimum number of operations required to convert a to b(insert,delete,replace)",
      "leetcode": "https://leetcode.com/problems/edit-distance/",
      "difficulty": "medium",
      "topics": ["dp"]
    },
    "435-non-overlapping-intervals": {
      "time_stamps": {
        "created_at": "2025-11-09T08:42:36.949255",
        "updated_at": "2025-11-09T11:15:21.168322"
      },
      "solutions": {
        "concise.py": {
          "code": "def eraseOverlapIntervals(intervals: list[list[int]]) -> int:\n    intervals.sort(key=lambda x: x[1])\n    end, count = intervals[0][1], 0\n    for s, e in intervals[1:]:\n        count += s < end\n        end = end if s < end else e\n    return count"
        },
        "solution.py": {
          "intuition": "This greedy solution is correct because sorting by *[1!]end* time ensures each interval chosen leaves the most room for future ones\n    Reasoning:\n            After sorting by *end* time, *end* tracks the boundary of the last non-overlapping interval.\n                If the next start `s < end`, it *[1!]overlaps* â†’ must remove one *[1!](increment count)*.\n                Otherwise, update `end = e` *[3!](keep this interval).*\n    This guarantees the maximum number of non-overlapping intervals remain â€” equivalently, minimum removals.",
          "time_complexity": "O(n log n):\n        for the sorting",
          "code": "def eraseOverlapIntervals(intervals: list[list[int]]) -> int:\n\n    intervals.sort(key=lambda x: x[1])\n    end, count = intervals[0][1], 0\n\n    for s, e in intervals[1:]:\n        if s < end:\n            count += 1\n        else:\n            end = e\n    return count"
        }
      },
      "title": "Non-overlapping Intervals",
      "definition": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping",
      "leetcode": "https://leetcode.com/problems/non-overlapping-intervals/",
      "difficulty": "medium",
      "topics": ["interval", "greedy"],
      "group": [["solution.py"], ["concise.py"]]
    },
    "79-word-search": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:16.850224",
        "updated_at": "2025-09-30T19:05:08.952204"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Dfs with early exit on mismatch\n    Start dfs from each cell\n    At each step:\n        Check bounds and character match\n        Mark visited cell with a temp symbol (e.g. #)\n        Try 4 directions (no revisiting)\n        Restore cell after backtracking\n        Stop early if the full word is matched.",
          "time_complexity": "O(M * N * 3^L)\n    M, N = board size\n    L = word length\n    Each step explores at most 3 directions (excluding the one it came from)\n    Runtime improves with early mismatches and pruning",
          "code": "def word_search(board: list[list[str]], word: str) -> bool:\n    rows, cols, n = len(board), len(board[0]), len(word)\n    def dfs(r: int, c: int, i: int) -> bool:\n        if i == n:\n            return True\n        if not (0 <= r < rows and 0 <= c < cols and board[r][c] == word[i]):\n            return False\n        tmp, board[r][c] = board[r][c], \"#\"\n        for x, y in ((r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)):\n            if dfs(x, y, i + 1):\n                board[r][c] = tmp\n                return True\n        board[r][c] = tmp\n        return False\n    return any(\n        dfs(r, c, 0)\n        for r in range(rows)\n        for c in range(cols)\n        if board[r][c] == word[0]\n    )"
        }
      },
      "title": "Word Search",
      "definition": "Determine if a word exists in a 2D board by following adjacent letters without reuse.",
      "leetcode": "https://leetcode.com/problems/word-search",
      "difficulty": "medium",
      "topics": ["backtrack"]
    },
    "39-combination-sum": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:16.850085",
        "updated_at": "2025-09-30T19:05:08.950374"
      },
      "solutions": {
        "solution.py": {
          "intuition": "DFS with backtracking\n    Sort candidates, try each starting from current index (to allow reuse), prune if number exceeds remaining target, and record the path when rem == 0.",
          "time_complexity": "O(2^n)\n    Worst-case exponential in number of combinations explored, but pruning (if c > rem: break) reduces branches significantly.",
          "args": {
            "candidates: list[int]": "List of candidate numbers",
            "target: int": "Target sum to achieve"
          },
          "returns": "`list[list[int]]`: List of all unique combinations that sum to target",
          "code": "def combination_sum(candidates: list[int], target: int) -> list[list[int]]:\n\n    candidates.sort()\n    res, path = [], []\n\n    def dfs(i: int, rem: int) -> None:\n        if rem == 0:\n            res.append(path.copy())\n            return\n        for j in range(i, len(candidates)):\n            if (c := candidates[j]) > rem:\n                break\n            path.append(c)\n            dfs(j, rem - c)\n            path.pop()\n\n    dfs(0, target)\n    return res"
        }
      },
      "title": "Combination Sum",
      "definition": "Return all unique combinations where chosen numbers sum to a target. Numbers can be reused.",
      "leetcode": "https://leetcode.com/problems/combination-sum",
      "difficulty": "medium",
      "topics": ["backtrack"]
    },
    "256-paint-house": {
      "time_stamps": {
        "created_at": "2025-10-27T09:02:56.181645",
        "updated_at": "2025-10-27T10:16:00.882386"
      },
      "solutions": {
        "vector.py": {
          "intuition": "Deep Dive:Paint House (k=3) â€” Top-down DP with explicit memoization:\n    **Subproblems:** dp(i, c) = min total cost to paint houses *[2!]suffix [i:]* given house i is painted color c\n    **Relate:** *$dp(i, c) = costs[i][c] + \\min_{c'!=c} dp(i+1, c')$*\n    **Topological order:** *[2!]decreasing i*, subproblem `dp(i)` depends only on strictly larger i, `dp(i+1)`, so acyclic\n    **Base case:** `dp(n) = [0, 0, 0]` (no houses left)\n    **Original problem:** `answer = min(dp(0))`",
          "time_complexity": "O(n):\n    number of subproblems is n (We compute dp(i) once for each i)\n    time per subproblem is O(1) (k=3).\n    â†’ *Î˜(n)* total",
          "returns": "`int`: Minimum total cost to paint all houses with no adjacent equal colors.",
          "code": "class Solution:\n    def minCost(self, costs: list[list[int]]) -> int:\n        n, memo = len(costs), {}\n\n        def dp(i: int) -> list[int]:\n            if i == n:\n                return [0, 0, 0]  \n\n            if i not in memo:\n                nxt = dp(i + 1)  \n\n                m1 = m2 = float(\"inf\"); c1 = -1\n                for c, v in enumerate(nxt):\n                    if v < m1:\n                        m2, m1, c1 = m1, v, c\n                    elif v < m2:\n                        m2 = v\n                memo[i] = [costs[i][c] + (m2 if c == c1 else m1) for c in range(3)]\n            return memo[i]\n\n        return min(dp(0))"
        },
        "scalar.py": {
          "intuition": "Deep Dive:Paint House (k=3) â€” Top-down DP with explicit memoization:\n    **Subproblems:** dp(i, c) = min total cost to paint houses *[2!]suffix [i:]* given house i is painted color c.\n    **Relate:** `[language=\"python\"]dp(i, c) = costs[i][c] + min(dp(i+1, other_color_1), dp(i+1, other_color_2))`                 *[19!]Choose the cheaper of the two other colors for the next house.*\n    **Topological order:** *[2!]decreasing i*, subproblem `dp(i, c)` depends only on strictly larger i, `dp(i+1, other_color_1)` and `dp(i+1, other_color_2)`, so acyclic\n    **Base case:**`dp(n, c) = 0` â†’ no houses left to paint.\n    **Original problem:** return `min(dp(0, 0), dp(0, 1), dp(0, 2))` â€” start with any first color.\n    **Time complexity:** *O(n)*: each `(i, c)` computed once, constant work per state.\n    **Space:** *O(n)* for memo and recursion depth.\n    **Returns:** Minimum total cost to paint all houses so that no two adjacent share a color",
          "code": "class Solution:\n    def minCost(self, costs: list[list[int]]) -> int:\n        n, memo = len(costs), {}\n\n        def dp(i: int, c: int) -> int:\n            if i == n:\n                return \n            if (i, c) not in memo:\n\n                memo[i, c] = costs[i][c] + min(\n                    dp(i + 1, (c + 1) % 3), dp(i + 1, (c + 2) % 3)\n                )\n            return memo[i, c]\n\n        return min(dp(0, 0), dp(0, 1), dp(0, 2))"
        }
      },
      "title": "Paint House",
      "definition": "Paint n houses using colors `{red, blue, green}` with costs given by an `nx3` matrix `costs[i][c]`.Find the minimum total cost so no two adjacent houses share the same color",
      "leetcode": "https://leetcode.com/problems/paint-house/",
      "difficulty": "medium",
      "topics": ["dp"]
    },
    "642-design-search-autocomplete-system": {
      "time_stamps": {
        "created_at": "2025-11-20T08:48:17.339143",
        "updated_at": "2025-11-20T19:31:41.984213"
      },
      "solutions": {
        "solution.py": {
          "code": "from collections import defaultdict\n\nclass TrieNode:\n    __slots__ = (\"children\", \"hot\")\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.hot: list[str] = []\n\nclass AutocompleteSystem:\n\n    def __init__(self, sentences: list[str], times: list[int]):\n        self.root = TrieNode()                 \n        self.freq = defaultdict(int)          \n        self.cur: TrieNode | None = self.root  \n        self.buf = \"\"                          \n        for s, t in zip(sentences, times):\n            self._add(s, t)\n\n    def _add(self, s: str, delta: int) -> None:\n        self.freq[s] += delta\n        node = self.root\n        for ch in s:\n            node = node.children[ch]\n            self._update_hot(node, s)          \n\n    def _update_hot(self, node: TrieNode, s: str) -> None:\n        if s not in node.hot:\n            node.hot.append(s)\n        node.hot.sort(key=lambda x: (-self.freq[x], x))\n        if len(node.hot) > 3:\n            node.hot.pop()\n\n    def input(self, c: str) -> list[str]:\n        if c == \"#\":\n            if self.buf:\n                self._add(self.buf, 1)\n            self.buf = \"\"\n            self.cur = self.root\n            return []\n\n        self.buf += c\n        self.cur = self.cur.children[c]\n        return self.cur.hot"
        }
      },
      "title": "Design Search Autocomplete System",
      "definition": "Given historical sentences with frequencies,     design an autocomplete system that:\n    - On each typed character, returns the top 3 sentences starting with the current prefix (sorted by frequency, then lexicographically).\n    - On #, treats the typed string as a full sentence, stores it, and resets.",
      "leetcode": "https://leetcode.com/problems/design-search-autocomplete-system/description/",
      "difficulty": "hard",
      "topics": ["trie"]
    },
    "542-01-matrix": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:57.931194",
        "updated_at": "2025-09-30T19:05:08.951641"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Multi-Source BFS from the Target ðŸŽ¯:\n    Instead of starting a separate BFS from every `1` to find the nearest `0` (which would be slow), this approach inverts the problem. It starts a single, **multi-source BFS from all `0`s simultaneously**. The level of the BFS at which a cell is reached is, by definition, its shortest distance to any `0`. This \"start from the answer\" strategy is a powerful technique for shortest path problems.",
          "time_complexity": "O(m * n):\n    where m and n are the dimensions of the grid.\n    Every cell is enqueued and processed exactly once, making this the optimal solution.",
          "code": "from collections import deque\n\ndef zero_one_matrix(mat: list[list[int]]) -> list[list[int]]:\n    m, n = len(mat), len(mat[0])\n    dist = [[-1] * n for _ in range(m)]\n    q = deque()\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and dist[ni][nj] < 0:\n                dist[ni][nj] = dist[i][j] + 1\n                q.append((ni, nj))\n    return dist"
        }
      },
      "title": "01 Matrix",
      "definition": "Given a binary matrix `mat`, return the distance of the nearest `0` for each cell. The distance between two adjacent cells is 1.",
      "leetcode": "https://leetcode.com/problems/01-matrix",
      "difficulty": "medium",
      "topics": ["bfs"]
    },
    "57-insert-interval": {
      "time_stamps": {
        "created_at": "2025-11-09T09:49:28.315597",
        "updated_at": "2025-11-09T10:40:40.476457"
      },
      "solutions": {
        "concise.py": {
          "code": "def insert(intervals: list[list[int]], new: list[int]) -> list[list[int]]:\n    s, e = new\n    left  = [i for i in intervals if i[1] < s]\n    right = [i for i in intervals if i[0] > e]\n    mid   = [i for i in intervals if not (i[1] < s or i[0] > e)]\n\n    if mid:\n        s = min(s, mid[0][0])\n        e = max(e, mid[-1][1])\n    return left + [[s, e]] + right"
        },
        "solution.py": {
          "code": "def insert(intervals: list[list[int]], new: list[int]) -> list[list[int]]:\n    res = []\n    s, e = new\n    i, n = 0, len(intervals)\n\n    while i < n and intervals[i][1] < s:\n        res.append(intervals[i])\n        i += 1\n\n    while i < n and intervals[i][0] <= e:\n        s = min(s, intervals[i][0])\n        e = max(e, intervals[i][1])\n        i += 1\n    res.append([s, e])\n\n    res.extend(intervals[i:])\n    return res"
        }
      },
      "title": "Insert Interval",
      "definition": "Insert a new interval into a sorted list of non-overlapping intervals, merging any overlaps so the result stays sorted and disjoint",
      "leetcode": "https://leetcode.com/problems/insert-interval",
      "difficulty": "medium",
      "topics": ["interval"],
      "group": [["solution.py"], ["concise.py"]]
    },
    "56-merge-intervals": {
      "time_stamps": {
        "created_at": "2025-11-06T11:51:03.332938",
        "updated_at": "2025-11-06T12:45:37.392018"
      },
      "solutions": {
        "solution.py": {
          "code": "def merge(intervals: list[list[int]]) -> list[list[int]]:\n    intervals.sort()\n    merged = []\n    start, end = intervals[0]\n    for s, e in intervals[1:]:\n        if s > end:\n            merged.append([start, end])\n            start, end = s, e\n        else:\n            end = max(e, end)\n    merged.append(start,end)        \n    return merged        "
        },
        "same_idea.py": {
          "code": "def merge(intervals: list[list[int]]) -> list[list[int]]:\n    intervals.sort()\n    merged = [intervals[0]]\n    for s, e in intervals[1:]:\n        if s > merged[-1][1]:\n            merged.append([s, e])\n        else:\n            merged[-1][1] = max(merged[-1][1], e)\n    return merged"
        }
      },
      "title": "Merge Intervals",
      "definition": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input",
      "leetcode": "https://leetcode.com/problems/merge-intervals/",
      "difficulty": "medium",
      "topics": ["interval"]
    },
    "1011-capacity-to-ship-packages-within-d-days": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:03.946326",
        "updated_at": "2025-09-29T12:42:20.260216"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Binary searching the answer space, (the ship's capacity)\n    The range of possible capacities is from `max(weights)` to `sum(weights)`.\n    The problem has a **monotonic property** ideal for binary search. The function `daysNeeded(capacity)` is monotonically non-increasing: as `capacity` grows, the days required can only decrease or stay the same.\n    This creates a predictable `\\[False, ..., False, True, ..., True\\]` sequence for our condition, `daysNeeded(capacity) <= days`. The goal is to find the leftmost `True`, which represents the minimal valid capacity.\n        If `daysNeeded(capacity) <= days` is `True`, then `capacity` is a potential answer, and we try for a better (smaller) one in the left half by setting `r = capacity`.\n        If it is `False`, then `capacity` is too small, and we must search for a larger capacity in the right half by setting `l = capacity + 1`.",
          "code": "def capacity_to_ship_packages_within_d_days(weights: list[int], days: int) -> int:\n    def days_needed(capacity: int) -> int:\n        d, load = 1, 0\n        for w in weights:\n            if load + w <= capacity:\n                load += w\n            else:\n                d += 1\n                load = w\n        return d\n\n    l, r = max(weights), sum(weights)\n    while l < r:\n        capacity = (l + r) // 2\n        if days_needed(capacity) <= days:\n            r = capacity\n        else:\n            l = capacity + 1\n    return l"
        }
      },
      "title": "Capacity To Ship Packages Within D Days",
      "definition": "Given a list of weights and a number of days, find the minimum capacity of a ship that can ship all the weights within the given number of days.",
      "leetcode": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days",
      "difficulty": "medium",
      "topics": ["binary-search"]
    },
    "208-implement-trie-prefix-tree": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:43.508813",
        "updated_at": "2025-11-20T20:42:22.088288"
      },
      "solutions": {
        "solution.py": {
          "variables": {
            "children": "`defaultdict[str, TrieNode]` maps characters to child TrieNodes, auto-created on first access",
            "end": "bool flag indicating this node marks the end of a valid word"
          },
          "code": "from collections import defaultdict\n\nclass TrieNode:\n    __slots__ = (\"children\", \"end\")\n\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children[ch]\n        node.end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if (node := node.children.get(ch)) is None:\n                return False\n        return node.end\n\n    def starts_with(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if (node := node.children.get(ch)) is None:\n                return False\n        return True"
        }
      },
      "title": "Implement Trie (Prefix Tree)",
      "definition": "Implement a trie (prefix tree) with insert, search, and startsWith methods.",
      "leetcode": "https://leetcode.com/problems/implement-trie-prefix-tree",
      "difficulty": "medium",
      "topics": ["trie"]
    },
    "1000-minimum-cost-to-merge-stones": {
      "time_stamps": {
        "created_at": "2025-10-26T09:36:22.594314",
        "updated_at": "2025-11-02T16:49:27.775500"
      },
      "solutions": {
        "solution.py": {
          "expressions": {
            "(r - l) % (K - 1)": "",
            "- Start": "**n** piles",
            "- So to reach 1 pile from `n`, we need": ""
          },
          "time_complexity": "O(n^3):\n    There are **O(nÂ²)** subproblems (`l, r` pairs)\n    For each subproblem, the loop `[language=\"python\"]for t in range(l, r, K - 1)`\n        tries up to **O(n / (K - 1))** split points.\n        Each operation inside is *O(1)* (thanks to *[2!]prefix sums*)\n    So the time complexity is O(n^3 / (K - 1))",
          "space_complexity": "O(nÂ²) for memoization",
          "code": "class Solution:\n    def mergeStones(self, stones: list[int], K: int) -> int:\n        if ((n := len(stones)) - 1) % (K - 1):return -1\n\n        prefix, memo = [0], {}\n        for x in stones: prefix.append(prefix[-1] + x)\n        cost = lambda l, r: 0 if (r - l) % (K - 1) else prefix[r + 1] - prefix[l]\n\n        def dp(l, r):\n            if (key := (l, r)) not in memo:\n                memo[key] = min(\n                    (dp(l, t) + dp(t + 1, r) + cost(l, r) for t in range(l, r, K - 1)),\n                    default=0,\n                )\n            return memo[key]\n\n        return dp(0, n - 1)"
        }
      },
      "title": "Minimum Cost to Merge Stones",
      "definition": "Merge exactly k adjacent piles at a time (cost = sum of those piles). Return the minimum total cost to end with one pile, or -1 if impossible",
      "leetcode": "https://leetcode.com/problems/minimum-cost-to-merge-stones/",
      "difficulty": "hard",
      "topics": ["dp"]
    },
    "325-maximum-size-subarray-sum-equals-k": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:43.508934",
        "updated_at": "2025-09-29T12:53:24.553199"
      },
      "solutions": {
        "solution.py": {
          "args": {
            "segments: list[int]": "List of integers representing trip segments.",
            "k: int": "Target sum."
          },
          "returns": "`int`: The length of the longest subarray with sum == k.",
          "code": "def maxSizeSubarraySumEqualsK(segments: list[int], k: int) -> int:\n\n    marker_idx = {0: -1}\n    prefix_sum = max_length = 0\n\n    for i, segment in enumerate(segments):\n\n        prefix_sum += segment\n\n        if (target_marker := prefix_sum - k) in marker_idx:\n            max_length = max(max_length, i - marker_idx[target_marker])\n\n        if prefix_sum not in marker_idx:\n            marker_idx[prefix_sum] = i\n\n    return max_length"
        }
      },
      "title": "Maximum Size Subarray Sum Equals k",
      "definition": "Given an array of integers and a target sum k, return the length of the longest subarray with sum equal to k.",
      "leetcode": "https://leetcode.com/problems/maximum-size-subarray-sum-equals-k",
      "difficulty": "medium",
      "topics": ["prefix-sum"]
    },
    "2145-count-the-hidden-sequences": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:10.762863",
        "updated_at": "2025-09-29T12:46:45.820316"
      },
      "solutions": {
        "solution.py": {
          "args": {
            "differences: list[int]": "List of daily changes (trip segments).",
            "lower: int": "Lower bound for any marker on the highway.",
            "upper: int": "Upper bound for any marker on the highway."
          },
          "returns": "`int`: The number of valid starting values.",
          "code": "def numberOfArrays(differences: list[int], lower: int, upper: int) -> int:\n\n    prefix_sum = min_marker = max_marker = 0\n\n    for diff in differences:\n        prefix_sum += diff\n        min_marker = min(min_marker, prefix_sum)\n        max_marker = max(max_marker, prefix_sum)\n\n    return max(0, (upper - max_marker) - (lower - min_marker) + 1)"
        }
      },
      "title": "Count the Hidden Sequences",
      "definition": "Given differences array representing daily changes, lower and upper bounds, return the number of valid starting values for the sequence.",
      "leetcode": "https://leetcode.com/problems/count-the-hidden-sequences",
      "difficulty": "medium",
      "topics": ["array"]
    },
    "35-search-insert-position": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:16.849981",
        "updated_at": "2025-09-29T12:42:20.262465"
      },
      "solutions": {
        "solution.py": {
          "code": "from bisect import bisect_left\n\ndef search_insert_position(nums: list[int], target: int) -> int:\n    return bisect_left(nums, target)"
        }
      },
      "title": "Search Insert Position",
      "definition": "Given a sorted array of distinct integers and a target value, find the index of the target. If absent, return the index where it would be inserted to maintain order.",
      "leetcode": "https://leetcode.com/problems/search-insert-position",
      "difficulty": "easy",
      "topics": ["binary-search"]
    },
    "46-permutations": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:16.850118",
        "updated_at": "2025-09-30T19:05:08.950815"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Recursive Tree of Choices\n    Build permutations by choosing unused elements: At each level, try each remaining number, recurse with updated path, and backtrack to un-choose. Use used list or boolean flags to track chosen elements.",
          "time_complexity": "O(N!)\n    N levels of recursion, each level explores N - depth options, total N! permutations.",
          "space_complexity": "O(N)\n    Recursion depth is N, and we store the current permutation path.",
          "args": {
            "nums: list[int]": "List of integers to permute"
          },
          "returns": "`list[list[int]]`: List of all possible permutations",
          "code": "def permutations(nums: list[int]) -> list[list[int]]:\n\n    result, n = [], len(nums)\n\n    def dfs(i):\n\n        if i == n:\n            result.append(nums[:])\n        else:\n            for j in range(i, n):\n                nums[i], nums[j] = nums[j], nums[i]\n                dfs(i + 1)\n                nums[j], nums[i] = nums[i], nums[j]\n\n    dfs(0)\n    return result"
        }
      },
      "title": "Permutations",
      "definition": "Return all permutations of a list of unique numbers.",
      "leetcode": "https://leetcode.com/problems/permutations",
      "difficulty": "medium",
      "topics": ["backtrack", "permutation"]
    },
    "123-best-time-to-buy-and-sell-stock-iii": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:33.323948",
        "updated_at": "2025-09-30T19:05:08.947077"
      },
      "solutions": {
        "dp.py": {
          "intuition": "Cost profit tracking\n    Track the cost and profit for two separate trades, using the profit from the first trade to reduce the cost of the second trade.",
          "time_complexity": "O(n)\n    where n is the length of the prices array. We iterate through the array once.",
          "args": {
            "prices: list[int]": "List of stock prices"
          },
          "expressions": {
            "p - t1_profit": "money you'd need now if earlier profit covered part of this buy"
          },
          "variables": {
            "t1_cost": "cost of first trade",
            "t1_profit": "profit of first trade",
            "t2_cost": "cost of second trade",
            "t2_profit": "profit of second trade"
          },
          "returns": "`int`: Maximum profit from at most two transactions",
          "code": "def best_time_to_buy_and_sell_stock_III(prices: list[int]) -> int:\n\n    t1_cost = t2_cost = float(\"inf\")\n    t1_profit = t2_profit = 0\n\n    for p in prices:\n\n        t1_cost = min(t1_cost, p) \n        t1_profit = max(t1_profit, p - t1_cost)\n\n        t2_cost = min(t2_cost, p - t1_profit)\n        t2_profit = max(t2_profit, p - t2_cost)\n\n    return t2_profit"
        },
        "state.py": {
          "expressions": {
            "hold1 = hold2 = float(\"-inf\")": "money you'd have if holding first stock",
            "sell1 = sell2 = 0": "money you'd have if not holding first stock",
            "hold1 = max(hold1, -p)": "buy first stock",
            "sell1 = max(sell1, hold1 + p)": "sell first stock",
            "hold2 = max(hold2, sell1 - p)": "buy second stock",
            "sell2 = max(sell2, hold2 + p)": "sell second stock"
          },
          "intuition": "hold sell states",
          "code": "def best_time_to_buy_and_sell_stock_III(prices: list[int]) -> int:\n    hold1 = hold2 = float(\"-inf\")\n    sell1 = sell2 = 0\n\n    for p in prices:\n        hold1 = max(hold1, -p)\n        sell1 = max(sell1, hold1 + p)\n        hold2 = max(hold2, sell1 - p)\n        sell2 = max(sell2, hold2 + p)\n    return sell2"
        }
      },
      "title": "Best Time to Buy and Sell Stock III",
      "definition": "Given a list of daily stock prices `prices`; at most **two** transactions are allowed (cannot overlap). Return the maximum total profit.",
      "leetcode": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii",
      "difficulty": "hard",
      "topics": ["dynamic-programming", "array"]
    },
    "252-meeting-rooms": {
      "time_stamps": {
        "created_at": "2025-11-05T10:34:46.851058",
        "updated_at": "2025-11-05T12:06:08.589816"
      },
      "solutions": {
        "sweep-line.py": {
          "code": "from collections import defaultdict\n\ndef canAttendMeetings(self, intervals: list[list[int]]) -> bool:\n    time, count = defaultdict(int), 0\n    for s, e in intervals:\n        time[s] += 1\n        time[e] -= 1\n    for _, v in sorted(time.items()):\n        count += v\n        if count > 1:\n            return False\n    return True"
        },
        "Interval-sort-and-scan.py": {
          "code": "def canAttendMeetings( intervals: list[list[int]]) -> bool:\n        intervals.sort()\n        return all(intervals[i][0] >= intervals[i - 1][1] for i in range(1, len(intervals)))"
        }
      },
      "title": "Meeting Rooms",
      "definition": "Given `intervals[i] = [startáµ¢, endáµ¢]`,    determine if a person can attend all meetings (no overlaps).\n\n    **Constraints**: `0 â‰¤ len(intervals) â‰¤ 10â´`, `len(intervals[i]) = 2`, `0 â‰¤ startáµ¢ < endáµ¢ â‰¤ 10â¶`",
      "leetcode": "https://leetcode.com/problems/meeting-rooms/",
      "difficulty": "easy",
      "topics": ["sort", "sweep-line", "interval"]
    },
    "347-top-k-frequent-elements": {
      "time_stamps": {
        "created_at": "2025-10-04T12:12:26.433187",
        "updated_at": "2025-10-20T21:38:45.761590"
      },
      "solutions": {
        "heap.py": {
          "time_complexity": "O(n log k)",
          "code": "import heapq\nfrom collections import Counter\n\ndef topKFrequent(nums: list[int], k: int) -> list[int]:\n    freq ,h= Counter(nums), []\n    for num, f in freq.items():\n        heapq.heappush(h, (f, num))\n        if len(h) > k:\n            heapq.heappop(h)\n\n    return [num for _, num in h]"
        },
        "sort-frequency-bucketing.py": {
          "time_complexity": "O(n):\n    Counter(nums) â†’ O(n)\n    Build buckets â†’ O(n) (each element placed once)\n    Flatten in reverse until k â†’ O(n)",
          "code": "from collections import Counter\n\ndef topKFrequent(nums: list[int], k: int) -> list[int]:\n\n    bucket=[[] for _ in range(len(nums)+1)]\n    for n,f in Counter(nums).items():\n        bucket[f].append(n)\n\n    return [num for f_bucket in reversed(bucket) for num in f_bucket][:k]"
        },
        "heap-nlargets.py": {
          "expressions": {
            "freq.keys()": "iterable â†’ here freq.keys(), i.e. all unique numbers.",
            "key=freq.get": "key â†’ function that gives a value to rank by. freq.get(x) = frequency of x."
          },
          "time_complexity": "O(n log k)",
          "code": "import heapq\nfrom collections import Counter\n\ndef topKFrequent(nums: list[int], k: int) -> list[int]:\n    freq = Counter(nums)\n    return heapq.nlargest(k, freq.keys(), key=freq.get)"
        }
      },
      "title": "Top K Frequent Elements",
      "definition": "Given an integer array `nums` and an integer `k`, return the `k` most **frequent** elements\n    *[19!]Algorithm complexity must be better than *[orange!]O(nlogn)* where `n` is the length of the input array,     You may return the answer in any order*",
      "leetcode": "https://leetcode.com/problems/top-k-frequent-elements",
      "difficulty": "medium",
      "topics": ["heap", "min-heap"],
      "group": [["heap.py", "heap-nlargets.py"], ["sort-frequency-bucketing.py"]]
    },
    "64-minimum-path-sum": {
      "time_stamps": {
        "created_at": "2025-10-24T12:26:24.243097",
        "updated_at": "2025-10-24T14:34:50.615232"
      },
      "solutions": {
        "bottom-up.py": {
          "intuition": "Deep Dive: 2D to 1D:\n        In the 2D DP table, each cell depends only on its top and left neighbors:\n        `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`\n        That means to compute row i, you only need:\n            the current row's left value (`dp[i][j-1]`), and\n            the previous row's value at the same column (`dp[i-1][j]`).\n        So you can compress the table into one list of length c (number of columns):\n            `dp[j]` keeps the current min path sum at column j (effectively `dp[i][j]`),\n            `dp[j-1]` is the left cell,\n            and as you move row by row, `dp[j]` from the previous iteration serves as the top cell.",
          "variables": {
            "dp": "dp has one extra slot (index 0) as a sentinel = âˆž to avoid boundary checks . `dp[j]` = min path sum to reach current cell in column `j-1`"
          },
          "expressions": {
            "'min(dp[j], dp[j - 1]) + grid[i][j - 1]'=  update current cell": "min(top, left) + cell value"
          },
          "time_complexity": "O(r * c)",
          "code": "def minPathSum(grid: list[list[int]]) -> int:\n    r, c = len(grid), len(grid[0])\n    dp = [float(\"inf\")] * (c + 1); dp[1] = 0\n    for i in range(r):\n        for j in range(1, c + 1):\n            dp[j] = min(dp[j], dp[j - 1]) + grid[i][j - 1]\n    return dp[c]"
        },
        "top-down.py": {
          "time_complexity": "O(r * c)",
          "code": "def minPathSum(grid: list[list[int]]) -> int:\n    r, c, memo = len(grid), len(grid[0]), {}\n    def dp(i, j):\n        if i == r - 1 and j == c - 1: return grid[i][j]\n        if i >= r or j >= c: return float(\"inf\")\n        if (k := (i, j)) not in memo:\n            memo[k] = grid[i][j] + min(dp(i + 1, j), dp(i, j + 1))\n        return memo[k]\n    return dp(0, 0)"
        }
      },
      "title": "Minimum Path Sum",
      "definition": "Given a m x n grid,filled with non-negative numbers, find the minimum path from top left to bottom right by only moving down or right at any point in time.",
      "leetcode": "https://leetcode.com/problems/minimum-path-sum",
      "difficulty": "medium",
      "topics": ["dynamic-programming"],
      "group": [["bottom-up.py"], ["top-down.py"]]
    },
    "200-number-of-islands": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:43.508768",
        "updated_at": "2025-11-02T16:50:30.475607"
      },
      "solutions": {
        "iterative-dfs.py": {
          "code": "class Solution:\n    def numIslands(self, grid: list[list[str]]) -> int:\n\n        R, C = len(grid), len(grid[0])\n        islands, directions = 0, [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == \"1\":\n                    islands += 1\n                    grid[r][c] = \"0\"\n\n                    stack = [(r, c)]\n                    while stack:\n                        y, x = stack.pop()\n                        for dy, dx in directions:\n                            if 0 <= (i := y + dy) < R and 0 <= (j := x + dx) < C and grid[i][j] == \"1\":\n                                grid[i][j] = \"0\"\n                                stack.append((i, j))\n\n        return islands"
        },
        "bfs.py": {
          "intuition": "Find, Count, and Sink ðŸï¸\n    The strategy is to scan every cell of the grid. If an unvisited piece of land (`1`) is found, you've discovered a new island, so you increment the `islands` counter. Then, immediately launch a BFS from that cell to find and \"sink\" all connected parts of that same island by changing their value to `0`. This modification of the grid ensures each island group is counted exactly once.",
          "time_complexity": "O(R * C)\n    where R and C are the dimensions of the grid. This is optimal as each cell is visited a constant number of times.",
          "args": {
            "grid: list[list[str]]": "2D grid with '1' representing land and '0' representing water"
          },
          "returns": "`int`: Number of islands in the grid",
          "code": "from collections import deque\n\nclass Solution:\n    def numIslands(self, grid: list[list[str]]) -> int:\n        R, C = len(grid), len(grid[0])\n        islands, directions = 0, [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == \"1\":\n                    islands += 1\n                    grid[r][c] = \"0\"\n\n                    q = deque([(r, c)])\n                    while q:\n                        y, x = q.popleft()\n                        for dy, dx in directions:\n                            if 0 <= (i := y + dy) < R and 0 <= (j := x + dx) < C and grid[i][j] == \"1\":\n                                grid[i][j] = \"0\"\n                                q.append((i, j))\n\n        return islands"
        },
        "dfs.py": {
          "code": "from collections import deque\n\nclass Solution:\n\n    def numIslands(self, grid: list[list[str]]) -> int:\n\n        R, C = len(grid), len(grid[0])\n        islands = 0\n\n        def dfs(r, c):\n            if 0 <= r < R and 0 <= c < C and grid[r][c] == \"1\":\n                grid[r][c] = \"0\"\n                dfs(r - 1, c)\n                dfs(r + 1, c)\n                dfs(r, c - 1)\n                dfs(r, c + 1)\n\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == \"1\":\n                    islands += 1\n                    dfs(r, c)\n        return islands"
        }
      },
      "title": "Number of Islands",
      "definition": "Given an `m x n` 2D grid of '1's (land) and '0's (water), return the number of islands. An island is formed by connecting adjacent lands horizontally or vertically. Assume all four edges of the grid are all surrounded by water.",
      "leetcode": "https://leetcode.com/problems/number-of-islands",
      "difficulty": "medium",
      "topics": ["dfs", "bfs"],
      "group": [["bfs.py"], ["iterative-dfs.py"], ["dfs.py"]]
    },
    "841-keys-and-rooms": {
      "time_stamps": {
        "created_at": "2025-10-27T12:25:09.752816",
        "updated_at": "2025-11-02T12:23:09.699203"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Deep Dive:DFS reachability from room 0:\n    Goal: start from room 0 and reach every other room using the keys you find\n    Idea: DFS = â€œgo as deep as possible before backtrackingâ€\n        Each room is a node\n        Each key in that room is an edge to another node\n    Stack: we use a stack to track rooms we can explore next\n        Start with [0] (room 0 is unlocked)\n    Visited: mark rooms weâ€™ve already opened so we donâ€™t revisit them\n    Process:\n        Pop a room from the stack\n        For each key inside, if that room isnâ€™t visited, mark it and push it on the stack\n    Finish: when the stack is empty, weâ€™ve explored every reachable room\n    Check: if all rooms are visited â†’ return True, else False",
          "expressions": {
            "stack = [0]": "Start DFS from room 0",
            "[True]": "Room 0 is unlocked by default",
            "while stack": "While there are rooms to explore",
            "room = stack.pop()": "Take the last added room (DFS = LIFO)",
            "for key in rooms[room]": "For each key found in this room",
            "if not seen[key]": "If the room it unlocks isn't visited yet",
            "stack.append(key)": "Push it onto the stack to explore later"
          },
          "variables": {
            "seen": "Track which rooms have been visited"
          },
          "time_complexity": "O(N+E)",
          "code": "class Solution:\n    def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\n        stack = [0]\n        seen = [True] + [False] * (len(rooms) - 1)\n        while stack:\n            for key in rooms[stack.pop()]:\n                if not seen[key]:\n                    seen[key] = True\n                    stack.append(key)\n        return all(seen)"
        }
      },
      "title": "Keys and Rooms",
      "definition": "Start at room 0 (unlocked).    `rooms[i]` lists keys found in room `i`;    using keys, can you visit all `n` rooms?    Return true/false.    Constraints: *n=rooms.length*, *2â‰¤nâ‰¤1000*, *0â‰¤|rooms[i]|â‰¤1000*, *1â‰¤Î£|rooms[i]|â‰¤3000*, *keys in [0,n), unique per room*.",
      "leetcode": "https://leetcode.com/problems/keys-and-rooms/",
      "difficulty": "medium",
      "topics": ["dfs"]
    },
    "15-3sum": {
      "time_stamps": {
        "created_at": "2025-11-15T17:20:38.526377",
        "updated_at": "2025-11-16T12:37:54.847193"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Sort the array and use two pointers to find the triplets:\n        After sorting, each value `a[i]` becomes a fixed anchor\n        We then need a pair `(l, r)` such that:\n            `a[i] + a[l] + a[r] == 0`\n        Because the array is sorted\n            increasing `l` raises the sum\n            decreasing `r` lowers it\n        This turns the inner search into a classic two-pointer sweep\n\n    Duplicate handling:\n        Skip repeated anchors `i`.\n        After finding one valid triplet, advance `l` past duplicates, because those pairs cannot form new distinct triplets.",
          "time_complexity": "O(n ^ 2):\n        The outer loop runs `n` times, and for each anchor `i` the `(l, r)` pointers move at most `n` total steps, because each pointer only moves forward/backward and never resets â†’ O(nÂ²) overall.",
          "returns": "`list[list[int]]`: All unique triplets `[x, y, z]` with `x + y + z = 0`.",
          "code": "def three_sum(a: list[int]) -> list[list[int]]:\n\n    a.sort()\n    out: list[list[int]] = []\n\n    for i, x in enumerate(a):\n        if i and x == a[i - 1]: continue\n        l, r = i + 1, len(a) - 1\n        while l < r:\n            s = x + a[l] + a[r]\n            if s < 0: l += 1\n            elif s > 0: r -= 1\n            else:\n                out.append([x, a[l], a[r]])\n                l += 1 ; r -= 1\n                while l < r and a[l] == a[l - 1]:\n                    l += 1\n    return out"
        }
      },
      "title": "3sum",
      "definition": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
      "leetcode": "https://leetcode.com/problems/3sum/",
      "difficulty": "medium",
      "topics": ["k-sum"]
    },
    "2140-solving-questions-with-brainpower": {
      "time_stamps": {
        "created_at": "2025-09-12T16:06:10.762818",
        "updated_at": "2025-09-30T19:05:08.949268"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Paradigm: This is a classic **Longest Path** problem on a Directed Acyclic Graph (DAG).\n    Insight: The maximum score obtainable *from* any question `i` is a fixed value, regardless of past choices. This allows a backward pass from the end of the exam (where the future score is 0), calculating the optimal future score for each question by simply choosing the `max()` of two pre-computed paths: the one from \"solving\" vs. the one from \"skipping\".",
          "time_complexity": "O(n)\n    where `n` is the number of questions.",
          "code": "def most_points_solving_questions_with_brainpower(questions: list[list[int]]) -> int:\n\n    memo, n = {}, len(questions)\n\n    def dp(i):\n        if i >= n:\n            return 0\n\n        if i not in memo:\n            memo[i] = max(dp(i + 1), (q:=questions[i])[0] + dp(i + 1 + q[1]))\n        return memo[i]\n\n    return dp(0)"
        }
      },
      "title": "Most Points Solving Questions With Brainpower",
      "definition": "Given an array of `questions` where `questions[i] = [pointsáµ¢, brainpoweráµ¢]`, you process from i=0 and at each i choose to either solve (gain `pointsáµ¢` and jump `brainpoweráµ¢ + 1`) or skip (move to `i + 1`). Return the maximum points achievable.",
      "leetcode": "https://leetcode.com/problems/solving-questions-with-brainpower",
      "difficulty": "medium",
      "topics": ["dynamic-programming"]
    },
    "212-word-search-ii": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:43.508892",
        "updated_at": "2025-09-30T19:05:08.949078"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Prefix rails\n    The trie lays down \"prefix rails\" across the grid: you only move where a rail continues; offâ€‘rail steps end instantly.\n    A terminal is a station: record the word once, close that spur, and drop empty rails as you pass. In one walk, a cell is used at most once.",
          "time_complexity": "O(m n * 4^L)\n    **Symbols:** mÃ—n board, W=âˆ‘(wâˆˆdict)|w|, L=max|w|.\n    **Build trie:** O(W).\n    **DFS (worst case):** first step â‰¤ 4 choices, then â‰¤ 3 per step â‡’ O(m n * 4 * 3^(L-1)). Coarse bound: O(m n * 4^L).\n    **Space:** trie O(W); recursion/visited path O(L).",
          "variables": {
            "trie": "Build trie from **words** list. Each end node gets a `$` key holding the word",
            "m": "number of rows",
            "n": "number of columns",
            "res": "the list of found words"
          },
          "expressions": {
            "node = node.setdefault(c, {})": "create a new node for the character if it doesn't exist",
            "if \"$\" in node": "if the current node is the end of a word",
            "res.append(node.pop(\"$\"))": "add the word to the result list and remove the \"$\" key to prevent duplicates",
            "if not node": "prune the trie to remove dead branches.",
            "[dfs": ".. Launch DFS from every cell that matches any trie root key",
            "board[i][j] = \"#\"": "Mark as visited",
            "board[i][j] = c": "Restore cell"
          },
          "code": "def word_search_II(board: list[list[str]], words: list[str]) -> list[str]:\n    trie = {}  \n    for word in words:\n        node = trie\n        for c in word:\n            node = node.setdefault(c, {})\n        node[\"$\"] = word\n\n    def dfs(i, j, parent):\n        if not (0 <= i < m and 0 <= j < n) or (c := board[i][j]) not in parent:\n            return\n        node = parent[c]\n        if \"$\" in node:\n            res.append(node.pop(\"$\"))\n        board[i][j] = \"#\"\n        for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n            dfs(x, y, node)\n        board[i][j] = c\n        if not node:\n            parent.pop(c)\n\n    m, n, res = len(board), len(board[0]), []\n    [dfs(i, j, trie) for i in range(m) for j in range(n) if board[i][j] in trie]\n\n    return res"
        }
      },
      "title": "Word Search II",
      "definition": "Given a board and a list of words, find all words in the board.",
      "leetcode": "https://leetcode.com/problems/word-search-ii",
      "difficulty": "hard",
      "topics": ["trie", "backtrack"]
    },
    "380-insert-delete-getrandom-constant": {
      "time_stamps": {
        "created_at": "2026-01-26T19:56:13.058887",
        "updated_at": "2026-01-26T21:15:13.529563"
      },
      "solutions": {
        "solution.py": {
          "code": "import random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.values: list[int] = []\n        self.index: dict[int, int] = {}\n\n    def insert(self, value: int) -> bool:\n        if value in self.index:\n            return False\n\n        self.index[value] = len(self.values)\n        self.values.append(value)\n        return True\n\n    def remove(self, value: int) -> bool:\n        if value not in self.index:\n            return False\n\n        self.values[(i:=self.index[value])] = (v:=self.values[-1])\n        self.values.pop()\n\n        self.index[v] = i\n        del self.index[value]\n\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)"
        }
      },
      "title": "Insert Delete GetRandom O(1)",
      "definition": "Design a data structure that supports, in average O(1) time:\n    - `insert(val)` insert val if not present; return true if inserted, else false\n    - `remove(val)` remove val if present; return true if removed, else false\n    - `getRandom()` return a uniformly random element from the current set (each element equally likely)",
      "leetcode": "https://leetcode.com/problems/insert-delete-getrandom-o1",
      "difficulty": "medium",
      "topics": ["hash-table", "amortized-time-complexity", "random-sampling"]
    },
    "713-subarray-product-less-than-k": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:57.931365",
        "updated_at": "2025-09-30T19:05:08.951791"
      },
      "solutions": {
        "solution.py": {
          "time_complexity": "O(n)",
          "code": "def num_subarray_product_less_than_k(nums: list[int], k: int) -> int:\n    if k <= 1:\n        return 0\n    product, left, count = 1, 0, 0\n    for right, num in enumerate(nums):\n        product *= num\n        while product >= k:\n            product //= nums[left]\n            left += 1\n        count += right - left + 1\n    return count"
        }
      },
      "title": "Number of Subarrays with Product Less Than K",
      "definition": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is less than k.",
      "leetcode": "https://leetcode.com/problems/subarray-product-less-than-k",
      "difficulty": "medium",
      "topics": ["sliding-window"]
    },
    "36-valid-sudoku": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:16.850013",
        "updated_at": "2025-09-30T19:05:08.949952"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Cube index and think locally\n    **cube_index := **[pink!](r // 3) * 3** + **[purple!](c // 3)**** treats the 9Ã—9 board as a 3Ã—3 grid of 3Ã—3 boxes:\n        `[pink!]r//3` gives which *[pink!]box-row* (0,1,2) you're in\n        `[purple!]c//3` gives which *[purple!]box-column* (0,1,2)\n         multiplying the *[pink!]box-row* by *[pink!]3* and adding the *[purple!]box-column* yields a unique index 0â€“8 for each 3Ã—3 cube.",
          "time_complexity": "O(81)\n    i.e., O(n^2). Fixed 9Ã—9 boards scan at most 81 cells. Generalized nÃ—n Sudoku validation runs in O(n^2) time.",
          "args": {
            "board: list[list[str]]": "9x9 Sudoku board with digits 1-9 and '.' for empty cells"
          },
          "expressions": {
            "if (": "Check for duplicates",
            "if (num := board[r][c]) != \".\"": "Skip empty cells",
            "cube_index := (r // 3) * 3 + (c // 3)": "The formula works by treating the *9Ã—9* board as a *3Ã—3* grid of *3Ã—3* boxes:\n         - **[pink!]r//3** gives which *[pink!]box-row* (0,1,2) you're in;\n         - **[purple!]c//3** gives which *[purple!]box-column* (0,1,2).\n         - Multiplying the *[pink!]box-row* by *[pink!]3* and adding the *[purple!]box-column* yields a unique index 0â€“8 for each *3Ã—3* cube."
          },
          "returns": "`bool`: True if the board is valid, False otherwise",
          "code": "def is_valid_sudoku(board: list[list[str]]) -> bool:\n\n    row = [set() for _ in range(9)]\n    col = [set() for _ in range(9)]\n    cube = [set() for _ in range(9)]\n\n    for r in range(9):\n        for c in range(9):\n            if (num := board[r][c]) != \".\": \n\n                if (\n                    num in col[c]\n                    or num in row[r]\n                    or num in cube[(cube_index := (r // 3) * 3 + (c // 3))]\n                ):\n                    return False\n\n                col[c].add(num)\n                row[r].add(num)\n                cube[cube_index].add(num)\n    return True"
        }
      },
      "title": "Valid Sudoku",
      "definition": "Given a partially filled 9Ã—9 board with digits `1â€“9` and `.` for empty cells, determine if it is valid - *[gray!]no duplicates in any row, column, or 3Ã—3 sub-box. You do not need to solve it*.",
      "leetcode": "https://leetcode.com/problems/valid-sudoku",
      "difficulty": "medium",
      "topics": ["game"]
    },
    "54-spiral-matrix": {
      "time_stamps": {
        "created_at": "2025-11-16T14:04:13.938704",
        "updated_at": "2025-11-16T14:19:29.111229"
      },
      "solutions": {
        "solution.py": {
          "intuition": "A spiral is formed by peeling the matrix layer by layer.\n    Each layer has four edges:\n        `â†’` top row  (left â†’ right)\n        `â†“` right col (top â†’ bottom)\n        `â†` bottom row (right â†’ left)\n        `â†‘` left col  (bottom â†’ top)\n    After traversing each edge, the boundaries (top, bottom, left, right) shrink inward. The process repeats until the boundaries cross        (Every cell is visited exactly once).",
          "time_complexity": "O(m x n):\n        Every cell is visited exactly once.",
          "code": "def spiral_matrix(matrix: list[list[int]]) -> list[int]:\n    res = []\n    top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n\n    while top <= bottom and left <= right:\n\n        res += matrix[top][left : right + 1]\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            res += matrix[bottom][left : right + 1][::-1]\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res"
        }
      },
      "title": "Spiral Matrix",
      "definition": "Given an m x n matrix, return all elements of the matrix in spiral order",
      "leetcode": "https://leetcode.com/problems/spiral-matrix/",
      "difficulty": "medium",
      "topics": ["matrix"]
    },
    "322-coin-change": {
      "time_stamps": {
        "created_at": "2025-11-16T14:31:43.298329",
        "updated_at": "2025-11-16T15:11:31.460745"
      },
      "solutions": {
        "bottom-up.py": {
          "code": "def coin_change(coins: list[int], amount: int) -> int:\n\n    dp = [0] + [float(\"inf\")] * amount\n    for coin in reversed(coins):\n        for r in range(coin, amount + 1):\n            dp[r] = min(dp[r], 1 + dp[r - coin])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1"
        },
        "top-down.py": {
          "code": "def coin_change(coins: list[int], amount: int) -> int:\n\n    memo, n = {}, len(coins)\n\n    def dp(i, r):\n        if r == 0: return 0\n        if i ==n or r < 0: return float(\"inf\")\n\n        if (i, r) not in memo:\n            memo[(i, r)] = min(\n                1 + dp(i, r - coins[i]),\n                dp(i + 1, r),\n            )\n        return memo[(i, r)]\n\n    return m if (m := dp(0, amount)) < float(\"inf\") else -1"
        }
      },
      "title": "Coin Change",
      "definition": "Given `coins:list[int]` representing coins of different *denominations* and `amount:int` representing a total *amount* of money.    Return the *fewest* number of coins that you need to make up that amount or `-1` if it is not possible to make up that amount.    You may assume that you have an infinite number of each kind of coin.",
      "leetcode": "https://leetcode.com/problems/coin-change/",
      "difficulty": "mediumTopics: [dp]"
    },
    "743-network-delay-time": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:57.931423",
        "updated_at": "2025-11-02T11:33:33.358860"
      },
      "solutions": {
        "dijkstra.py": {
          "intuition": "We track the shortest known time to reach every node from the source k:\n    Initially, all distances are infinite except for k (0).\n    At each step, we pop the node with the smallest known distance from the heap.\n    If we find a shorter path to one of its neighbors, we update (relax) that distance\n    and push the new state into the heap.\n\n    By the end, `dist[v]` holds the minimum time for the signal to reach each node `v`:\n    The total network delay is the longest of these shortest times\n        i.e., `max(dist.values())`. If some node remains unreachable, return - 1.",
          "time_complexity": "O(E log V)",
          "code": "from heapq import heappush, heappop\n\nclass Solution:\n    def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int:\n\n        g = {i: [] for i in range(1, n + 1)}\n        for u, v, w in times:\n            g[u].append((w, v))\n\n        dist = {i: float(\"inf\") for i in g}\n        dist[k] = 0\n\n        pq = [(0, k)]\n\n        while pq:\n            d, u = heappop(pq)\n            if d > dist[u]: continue\n\n            for w, v in g[u]:\n                if (nd := d + w) < dist[v]:\n                    dist[v] = nd\n                    heappush(pq, (nd, v))\n\n        return ans if (ans := max(dist.values())) < float(\"inf\") else -1"
        },
        "dijkstra-b.py": {
          "intuition": "The signal starts at node k and spreads through the network.\n    Each time we pop a node from the heap, we know this is the earliest\n    possible moment the signal can reach it â€” its shortest travel time.\n    We mark it as finalized and push its neighbors with updated times.\n    When all nodes are finalized, the last recorded time is the total delay.\n    If not all nodes can be reached, return -1.",
          "time_complexity": "O(E log V):\n    E is the number of edges (the length of the input list `times`)\n    V is the number of vertices (the number of nodes `n`)\n\n    By substituting these into the standard Dijkstra complexity formula, O(E log V), you get *O(len(times)logn)*.",
          "args": {
            "times: list[list[int]]": "list of lists of integers representing the edges and their weights",
            "k: int": "starting node"
          },
          "returns": "`int`: minimum time for a signal starting at node `k` to reach *all* nodes or -1 if impossible",
          "code": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\nclass Solution:\n    def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int:\n\n        adj = defaultdict(list)\n        for u, v, w in times:\n            adj[u].append((v, w))\n\n        pq, finalized, time = [(0, k)], set(), 0\n\n        while pq:\n            t, node = heappop(pq)\n            if node in finalized:\n                continue\n            finalized.add(node)\n            time = t\n\n            for neighbor, travel_time in adj[node]:\n                if neighbor not in finalized:\n                    heappush(pq, (time + travel_time, neighbor))\n\n        return time if len(finalized) == n else -1"
        }
      },
      "title": "Network Delay Time",
      "definition": "Given `n` nodes labeled `1` through `n` and directed travel times between them, find the minimum time for a signal starting at node `k` to reach *all* nodes. If impossible, return -1",
      "leetcode": "https://leetcode.com/problems/network-delay-time",
      "difficulty": "medium",
      "topics": ["dijkstra"]
    },
    "127-word-ladder": {
      "time_stamps": {
        "created_at": "2025-09-12T16:05:33.324026",
        "updated_at": "2025-09-30T19:05:08.947226"
      },
      "solutions": {
        "solution.py": {
          "intuition": "Bidirectional BFS Meets in the Middle ðŸ¤:\n    This solution uses two  optimizations. First, it **pre-computes all possible generic transformations** (e.g., `h*t`) in a dictionary, allowing for instant lookups of neighboring words instead of generating them on the fly. Second, it performs a **bidirectional BFS**, launching one search from the `beginWord` and another from the `endWord`. By always expanding the smaller of the two frontiers, it drastically reduces the search space. The algorithm finishes when the two searches meet, at which point the shortest path is found.",
          "time_complexity": "O(N * L)\n    where N is the number of words and L is the length of each word. The dominant operation is the initial pre-computation step to build the `combos` dictionary. The subsequent bidirectional search is typically much faster than this initial setup.",
          "code": "from collections import defaultdict\n\ndef word_ladder(beginWord: str, endWord: str, wordList: list[str]) -> int:\n    if endWord not in wordList:\n        return 0\n\n    L = len(beginWord)\n    combos: dict[str, list[str]] = defaultdict(list)\n    for w in wordList:\n        for i in range(L):\n            combos[w[:i] + \"*\" + w[i+1:]].append(w)\n\n    front, back = {beginWord}, {endWord}\n    dist_front, dist_back = {beginWord: 1}, {endWord: 1}\n\n    while front and back:\n        if len(front) > len(back):\n            front, back = back, front\n            dist_front, dist_back = dist_back, dist_front\n\n        next_front = set()\n        for word in front:\n            for i in range(L):\n                for n in combos[word[:i] + \"*\" + word[i+1:]]:\n                    if n in dist_back:\n                        return dist_front[word] + dist_back[n]\n                    if n not in dist_front:\n                        dist_front[n] = dist_front[word] + 1\n                        next_front.add(n)\n        front = next_front\n\n    return 0"
        }
      },
      "title": "Word Ladder",
      "definition": "Given a `beginWord`, an `endWord`, and a dictionary `wordList`, find the length of the shortest transformation sequence from `beginWord` to `endWord` such that only one letter is changed at a time and each transformed word exists in the `wordList`.",
      "leetcode": "https://leetcode.com/problems/word-ladder",
      "difficulty": "hard",
      "topics": ["bfs"]
    },
    "1094-car-pooling": {
      "time_stamps": {
        "created_at": "2025-11-09T10:43:42.393056",
        "updated_at": "2025-11-09T11:14:45.653176"
      },
      "solutions": {
        "solution.py": {
          "code": "from collections import defaultdict\n\ndef car_pooling(trips, capacity):\n    location = defaultdict(int)\n    for p, s, e in trips:\n        location[s] += p\n        location[e] -= p\n\n    onboard = 0\n    for _, p in sorted(location.items()):\n        onboard += p\n        if onboard > capacity:\n            return False\n    return True"
        }
      },
      "title": "Car Pooling",
      "definition": "Given **$trips[i] = [numPassengers_i, from_i, to_i]$** and a **car capacity**,     determine if the car ever exceeds its capacity while moving east\n    *[19!]The locations  *[2!]$from_i$, $to_i$*  are given as the number of kilometers due east from the car's *[2!]initial* location*",
      "leetcode": "https://leetcode.com/problems/car-pooling",
      "difficulty": "medium",
      "topics": ["interval"]
    }
  },
  "core": {
    "Tree": {
      "time_stamps": {
        "created_at": "2025-10-29T19:54:28.185942",
        "updated_at": "2025-10-29T19:55:18.755975"
      },
      "solutions": {
        "binary_tree_node.py": {
          "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right"
        }
      }
    },
    "bellman-ford": {
      "time_stamps": {
        "created_at": "2025-09-17T21:12:55.387063",
        "updated_at": "2026-01-18T19:04:58.383606"
      },
      "solutions": {
        "layered_dag.py": {
          "intuition": "Compute k-edge shortest-path distances and detect negative cycles via layered relaxation.\n    1. $\\delta_0(s,v)$: initialize distances (0 at source, $\\infty$ elsewhere).\n    2. For $i = 1 \\ldots V$: perform one pass of edge-relaxation to compute $\\delta_i(s,v)$,\n       the best cost using $\\leq i$ edges.\n    3. Identify any vertex v where $\\delta_V(s,v) < \\delta_{V-1}(s,v)$ as a negative-cycle witness.\n    4. Flood successors of those witnesses and mark their distances as $-\\infty$.",
          "args": {
            "vertices: list[str]": "All hashable vertex identifiers.",
            "edges: list[tuple[str, str, float]]": "Iterable of (u, v, weight) tuples.",
            "source: str": "Starting vertex."
          },
          "returns": "`dict[str, float]`: A dict mapping each vertex to its true shortest-path cost from `source`,\n      or float('-inf') if it's reachable from a negative-weight cycle.",
          "code": "from collections import defaultdict\n\ndef bellman_ford_layered_dag(\n    vertices: list[str], edges: list[tuple[str, str, float]], source: str\n) -> dict[str, float]:\n\n    d = {v: float(\"inf\") for v in vertices}\n    d[source], V = 0, len(vertices)\n\n    for k in range(V):\n        d_k = {**d}\n        for u, v, w in edges:\n            if d[u] + w < d_k[v]:\n                d_k[v] = d[u] + w\n        d = d_k\n\n    witnesses = {v for u, v, w in edges if d[u] + w < d[v]}\n\n    if not witnesses:\n        return d\n\n    adj = defaultdict(list)\n    for u, v, _ in edges:\n        adj[u].append(v)\n\n    stack = list(witnesses)\n    reachable = set(witnesses)\n\n    while stack:\n        u = stack.pop()\n        d[u] = float(\"-inf\")\n        for v in adj[u]:\n            if v not in reachable:\n                reachable.add(v)\n                stack.append(v)\n\n    return d"
        },
        "classic.py": {
          "intuition": "Classic Bellman-Ford with early exit:\n    Raises on a reachable negative-weight cycle;\n    otherwise returns $dist[v] = \\delta(s,v)$.",
          "expressions": {
            "range(V - 1)": "relax up to V-1 times, but return early if no update\n    'if not updated':  distances have stabilizedâ€”no negative cycles reachable"
          },
          "code": "def bellman_ford_classic(\n    vertices: list[str], edges: list[tuple[str, str, float]], source: str\n) -> dict[str, float]:\n\n    d = [float(\"inf\")] * (V := len(vertices))\n    d[source] = 0\n\n    for _ in range(V - 1):\n        updated = False\n        for u, v, w in edges:\n            if d[u] + w < d[v]:\n                d[v] = d[u] + w\n                updated = True\n        if not updated:\n            return d\n\n    for u, v, w in edges:\n        if d[u] + w < d[v]:\n            raise Exception(\"Negative-weight cycle\")\n\n    return d"
        }
      },
      "title": "Bellman-Ford Algorithm",
      "definition": "Bellman-Ford ...",
      "topics": ["graph_algorithms", "shortest_path", "dynamic_programming"]
    },
    "modular-arithmetic": {
      "time_stamps": {
        "created_at": "2025-09-17T21:13:31.611970",
        "updated_at": "2025-09-17T21:20:36.929219"
      },
      "solutions": {
        "congruent2.py": {
          "args": {
            "a: int": "the first number3",
            "b: int": "the second number",
            "n: int": "the modulus, the number by which we are dividing"
          },
          "returns": "`bool`: bool",
          "code": "def congruent2(a: int, b: int, n: int) -> bool:\n    return a % n == b % n"
        },
        "congruent1.py": {
          "args": {
            "a: int": "the first number2",
            "b: int": "the second number",
            "n: int": "the modulus, the number by which we are dividing"
          },
          "returns": "`bool`: bool",
          "code": "def congruent1(a: int, b: int, n: int) -> bool:\n    return (a - b) % n == 0"
        },
        "mod.py": {
          "args": {
            "a: int": "the first number1",
            "b: int": "the second number"
          },
          "returns": "`int`: int",
          "code": "def mod(a: int, b: int) -> int:\n    return a % b"
        }
      },
      "title": "Modular Arithmetic",
      "definition": "A system of arithmetic for integers where numbers \"wrap around\" after reaching a certain value (the modulus).",
      "topics": ["number_theory", "modular_arithmetic", "congruence"]
    },
    "dp": {
      "time_stamps": {
        "created_at": "2025-10-26T09:20:39.128761",
        "updated_at": "2025-10-26T12:49:40.101485"
      },
      "solutions": {},
      "title": "Dynamic Programming",
      "definition": "Dynamic Programming is a technique for solving problems by breaking them down into smaller subproblems and solving each subproblem only once.",
      "topics": ["dp"]
    },
    "dijkstra": {
      "time_stamps": {
        "created_at": "2025-09-17T21:13:20.568516",
        "updated_at": "2025-09-30T19:05:08.945649"
      },
      "solutions": {
        "algorithm.py": {
          "time_complexity": "O((V + E) log V)",
          "args": {
            "graph: dict[str, dict[str, int]]": "A dictionary representing the graph.",
            "s: str": "The source vertex."
          },
          "code": "import heapq\n\ndef dijkstra(graph: dict[str, dict[str, int]], s: str):\n\n    d = {v: float('inf') for v in graph} | {s: 0}\n    p = {v: None for v in graph}\n\n    pq = [(0, s)]\n\n    while pq:\n        d_u, u = heapq.heappop(pq)\n        if d_u > d[u]:\n            continue\n        for v ,w in graph[u]:\n            if (weight := d_u + w) < d[v]:\n                d[v], p[v] = weight, u\n                heapq.heappush(pq, (weight, v))\n\n    return d, p"
        }
      },
      "title": "Dijkstra's Algorithm",
      "definition": "Dijkstra's Algorithm ...",
      "topics": ["graph_algorithms", "shortest_path", "greedy"]
    },
    "binary-search": {
      "time_stamps": {
        "created_at": "2025-09-17T21:13:08.414101",
        "updated_at": "2025-09-30T18:24:30.519747"
      },
      "solutions": {
        "bisect_left.py": {
          "intuition": "Return the index where to insert item x in list a, assuming a is sorted.",
          "expressions": {
            "l = mid + 1": "If the target `x` is greater than the middle element `a[mid]`, the insertion point must be to the right of `mid`.\n    'r = mid': If the target `x` is less than or equal to `a[mid]`, then `mid` is a potential answer, so we search the left half including `mid`."
          },
          "code": "def simple_bisect_left(a: list[int], x: int):\n\n    l, r = 0, len(a)\n    while l < r:\n        mid = (l + r) // 2\n        if x > a[mid]:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
        },
        "bisect_right.py": {
          "intuition": "Return the index where to insert item x in list a, assuming a is sorted.",
          "expressions": {
            "r = mid": "If the x is less than the middle element, the insertion point could be `mid` or to its left. Shrink search space to the left half.\n    'l = mid + 1': If the x is >= middle element, the insertion point must be to the right of `mid`."
          },
          "code": "def simple_bisect_right(a, x):\n\n    l, r = 0, len(a)\n    while l < r:\n        mid = (l + r) // 2\n        if x < a[mid]:\n            r = mid\n        else: \n            l = mid + 1 \n    return l"
        }
      },
      "title": "Binary Search Algorithm",
      "definition": "Binary Search ...",
      "topics": ["search_algorithm", "divide_and_conquer"]
    }
  }
}