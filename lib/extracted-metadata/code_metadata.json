{
  "manhattan_distance": {
    "name": "manhattan_distance",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/a-star.py",
    "line": 7,
    "signature": "def manhattan_distance(a: tuple[int, int], b: tuple[int, int]) -> int:",
    "parameters": [
      {
        "name": "a",
        "type": "tuple[(int, int)]",
        "description": "(row, col) of the first point.",
        "default": null
      },
      {
        "name": "b",
        "type": "tuple[(int, int)]",
        "description": "(row, col) of the second point.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The Manhattan distance |a.row - b.row| + |a.col - b.col|.",
    "description": "Manhattan distance between two grid points $(r,c)$ and the goal $(r^*,c^*)$ is $h = |r^* - r| + |c^* - c|$. It measures the minimum number of orthogonal moves (up/down/left/right) ignoring obstacles, and is both admissible and consistent on a 4‑connected grid.",
    "code": "def manhattan_distance(a: tuple[int, int], b: tuple[int, int]) -> int:\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "aStarShortestPath": {
    "name": "aStarShortestPath",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/a-star.py",
    "line": 24,
    "signature": "def aStarShortestPath(grid: list[list[int]], k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Variables:",
    "code": "def aStarShortestPath(grid: list[list[int]], k: int) -> int:\n    rows, cols = len(grid), len(grid[0])\n    def h(r: int, c: int) -> int:\n        return manhattan_distance((r, c), (rows - 1, cols - 1))\n    if k >= (md:= h(0, 0)) - 1:\n        return md\n    pq = [(md, 0, 0, 0, k)]\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n    while pq:\n        _, steps, r, c, remaining_k = heapq.heappop(pq)\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        if remaining_k < max_k[r][c]:\n            continue\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if 0 <= (nr:= r + dr) < rows and 0 <= (nc:= c + dc) < cols:\n                if (new_remaining_k := remaining_k - grid[nr][nc] ) > max_k[nr][nc]:\n                    max_k[nr][nc] = new_remaining_k\n                    heapq.heappush(pq, ((steps + 1) + h(nr, nc), steps + 1, nr, nc, new_remaining_k))\n    return -1",
    "links": [
      {
        "symbol": "nr",
        "display": "[nr]",
        "target": "nr",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "nc",
        "display": "[nc]",
        "target": "nc",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "nr",
        "display": "[nr]",
        "target": "nr",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "nc",
        "display": "[nc]",
        "target": "nc",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "nr",
        "display": "[nr]",
        "target": "nr",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "nc",
        "display": "[nc]",
        "target": "nc",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [
      {
        "name": "pq",
        "description": "(f_cost, steps, r, c, remaining_k)",
        "type": "variable"
      }
    ],
    "expressions": [
      {
        "expression": "new_remaining_k",
        "description": "= remaining_k - grid[nr][nc], how many obstacle eliminations you will have left **after** moving to the next cell , if the cell is empty grid[nr][nc] is 0, if the cell is an obstacle grid[nr][nc] is 1.",
        "type": "expression"
      },
      {
        "expression": "if remaining_k < max_k[r][c]",
        "description": "Handle items that are already outdated by the time they are popped.",
        "type": "expression"
      }
    ]
  },
  "aStarShortestPath.h": {
    "name": "h",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/a-star.py",
    "line": 37,
    "signature": "def h(r: int, c: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def h(r: int, c: int) -> int:\n        return manhattan_distance((r, c), (rows - 1, cols - 1))",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "aStarShortestPath"
  },
  "bellman_ford_classic": {
    "name": "bellman_ford_classic",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bellman-ford.py",
    "line": 3,
    "signature": "def bellman_ford_classic(vertices:list[str], edges:list[tuple[str, str, float]], source:str)->dict[str, float]:",
    "parameters": [],
    "return_type": "dict[(str, float)]",
    "return_description": "",
    "description": "Classic Bellman-Ford with early exit.",
    "code": "def bellman_ford_classic(vertices:list[str], edges:list[tuple[str, str, float]], source:str)->dict[str, float]:\n    d = [float(\"inf\")] * (V := len(vertices))\n    d[source] = 0\n    for _ in range(V - 1):\n        updated = False\n        for u, v, w in edges:\n            if d[u] + w < d[v]:\n                d[v] = d[u] + w\n                updated = True\n        if not updated:\n            return d    \n    for u, v, w in edges:\n        if d[u] + w < d[v]:\n            raise Exception(\"Negative-weight cycle\")\n    return d",
    "links": [
      {
        "symbol": "v",
        "display": "[v]",
        "target": "v",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": [
      {
        "expression": "range(V - 1)",
        "description": "relax up to V-1 times, but return early if no update",
        "type": "expression"
      },
      {
        "expression": "if not updated",
        "description": "distances have stabilized—no negative cycles reachable",
        "type": "expression"
      }
    ]
  },
  "bellman_ford_layered_dag": {
    "name": "bellman_ford_layered_dag",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bellman-ford.py",
    "line": 34,
    "signature": "def bellman_ford_layered_dag(vertices: list[str], edges: list[tuple[str, str, float]], source: str) -> dict[str, float]:",
    "parameters": [
      {
        "name": "vertices",
        "type": "list[str]",
        "description": "All hashable vertex identifiers.",
        "default": null
      },
      {
        "name": "edges",
        "type": "list[tuple[(str, str, float)]]",
        "description": "Iterable of (u, v, weight) tuples.",
        "default": null
      },
      {
        "name": "source",
        "type": "str",
        "description": "Starting vertex.",
        "default": null
      }
    ],
    "return_type": "dict[(str, float)]",
    "return_description": "A dict mapping each vertex to its true shortest-path cost from `source`,",
    "description": "Compute k-edge shortest-path distances and detect negative cycles via layered relaxation.",
    "code": "def bellman_ford_layered_dag(vertices: list[str], edges: list[tuple[str, str, float]], source: str) -> dict[str, float]:\n    d = {v: float(\"inf\") for v in vertices}\n    d[source], V = 0, len(vertices)\n    for k in range(V):  \n        d_k = {**d}  \n        for u, v, w in edges:\n            if d[u] + w < d_k[v]:\n                d_k[v] = d[u] + w\n        d = d_k  \n    witnesses = {v for u, v, w in edges if d[u] + w < d[v]}\n    if not witnesses:\n        return d\n    adj = defaultdict(list)\n    for u, v, _ in edges:\n        adj[u].append(v)\n    stack = list(witnesses)\n    reachable = set(witnesses)\n    while stack:\n        u = stack.pop()\n        d[u] = float(\"-inf\")\n        for v in adj[u]:\n            if v not in reachable:\n                reachable.add(v)\n                stack.append(v)\n    return d",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "findCheapestPrice": {
    "name": "findCheapestPrice",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bellman-ford.py",
    "line": 92,
    "signature": "def findCheapestPrice(n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def findCheapestPrice(n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int:\n    d = [float(\"inf\")] * n\n    d[src] = 0\n    for _ in range(k + 1):\n        tmp = d[:]\n        for u, v, w in flights:\n            if d[u] + w < tmp[v]:\n                tmp[v] = d[u] + w\n        d = tmp\n    return d[dst] if d[dst] < float(\"inf\") else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "maxProbability": {
    "name": "maxProbability",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bellman-ford.py",
    "line": 107,
    "signature": "def maxProbability(n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float:",
    "parameters": [
      {
        "name": "n",
        "type": "int",
        "description": "number of nodes",
        "default": null
      },
      {
        "name": "edges",
        "type": "list[list[int]]",
        "description": "edges[i] = [u, v] is an undirected edge connecting the nodes u and v with a probability of success of traversing that edge succProb[i].",
        "default": null
      },
      {
        "name": "succProb",
        "type": "list[float]",
        "description": "list of probabilities, e.g. [0.5,0.5,0.2],",
        "default": null
      }
    ],
    "return_type": "float",
    "return_description": "",
    "description": "Bellman-Ford variant to maximize product of probabilities.",
    "code": "def maxProbability(n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float:\n    prob[start] = 1.0  \n    for _ in range(n - 1):  \n        updated = False\n        for (u, v), p in zip(edges, succProb):\n            if prob[u] * p > prob[v]:  \n                prob[v] = prob[u] * p\n                updated = True\n            if prob[v] * p > prob[u]:  \n                prob[u] = prob[v] * p\n                updated = True\n        if not updated:\n            break  \n    return prob[end]",
    "links": [
      {
        "symbol": "i",
        "display": "[i]",
        "target": "i",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "i",
        "display": "[i]",
        "target": "i",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": []
  },
  "dijkstra": {
    "name": "dijkstra",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 4,
    "signature": "def dijkstra(graph: dict[str, dict[str, int]], s: str):",
    "parameters": [
      {
        "name": "graph",
        "type": "dict[(str, dict[(str, int)])]",
        "description": "A dictionary representing the graph.",
        "default": null
      },
      {
        "name": "s",
        "type": "str",
        "description": "The source vertex.",
        "default": null
      }
    ],
    "return_type": "",
    "return_description": "",
    "description": "Dijkstra's algorithm for finding the shortest path in a non-negative weighted graph.",
    "code": "def dijkstra(graph: dict[str, dict[str, int]], s: str):\n    d = {v: float('inf') for v in graph} | {s: 0}\n    p = {v: None for v in graph}\n    pq = [(0, s)]\n    while pq:\n        d_u, u = heapq.heappop(pq)\n        if d_u > d[u]:\n            continue\n        for v ,w in graph[u]:\n            if (weight := d_u + w) < d[v]:\n                d[v], p[v] = weight, u\n                heapq.heappush(pq, (weight, v))\n    return d, p",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "networkDelayTime2": {
    "name": "networkDelayTime2",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 34,
    "signature": "def networkDelayTime2(times: list[list[int]], n: int, k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def networkDelayTime2(times: list[list[int]], n: int, k: int) -> int:\n    graph = {v: [] for v in range(1, n + 1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n    d = {v: float(\"inf\") for v in graph} | {k: 0}\n    pq = [(0, k)]\n    while pq:\n        d_u, u = heapq.heappop(pq)\n        if d_u > d[u]:\n            continue\n        for v, w in graph[u]:\n            if (weight := d_u + w) < d[v]:\n                d[v] = weight\n                heapq.heappush(pq, (weight, v))\n    return m if (m := max(d.values())) != float(\"inf\") else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "networkDelayTime": {
    "name": "networkDelayTime",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 57,
    "signature": "def networkDelayTime(times: list[list[int]], n: int, k: int) -> int:",
    "parameters": [
      {
        "name": "times",
        "type": "list[list[int]]",
        "description": "list of lists of integers representing the edges and their weights",
        "default": null
      },
      {
        "name": "n",
        "type": "int",
        "description": "number of nodes",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "starting node",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum time for a signal starting at node `k` to reach *all* nodes or -1 if impossible",
    "description": "Given `n` nodes labeled `1` through `n` and directed travel times between them,",
    "code": "def networkDelayTime(times: list[list[int]], n: int, k: int) -> int:\n    adj = defaultdict(list)\n    for u, v, w in times:\n        adj[u].append((v, w))\n    pq, finalized, time = [(0, k)], set(), 0\n    while pq:\n        t, node = heapq.heappop(pq)\n        if node in finalized:\n            continue\n        finalized.add(node)\n        time = t\n        for neighbor, travel_time in adj[node]:\n            if neighbor not in finalized:\n                heapq.heappush(pq, (time + travel_time, neighbor))\n    return time if len(finalized) == n else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "minimumEffortPath": {
    "name": "minimumEffortPath",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 91,
    "signature": "def minimumEffortPath(heights: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "heights",
        "type": "list[list[int]]",
        "description": "2D list of integers representing the heights of the cells",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum effort to reach the bottom-right cell",
    "description": "Find a path from the top-left to the bottom-right of a height grid that minimizes the \"effort\".",
    "code": "def minimumEffortPath(heights: list[list[int]]) -> int:\n    R, C = len(heights), len(heights[0])\n    pq, resolved = [(0, 0, 0)], set()\n    while pq:\n        effort, r, c = heapq.heappop(pq)\n        if (r, c) in resolved: continue\n        if (r, c) == (R - 1, C - 1): return effort\n        resolved.add((r, c))\n        for nr, nc in [(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)]:\n            if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in resolved:\n                neighbor_effort = max(effort, abs(heights[nr][nc] - heights[r][c]))\n                heapq.heappush(pq, (neighbor_effort, nr, nc))",
    "links": [],
    "variables": [
      {
        "name": "pq",
        "description": "Priority queue stores (max_effort_on_path, r, c)",
        "type": "variable"
      },
      {
        "name": "resolved",
        "description": "set to store the positions that have been resolved",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "swimInWater": {
    "name": "swimInWater",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 120,
    "signature": "def swimInWater(grid: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[int]]",
        "description": "2D list of integers representing the elevations of the cells",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum time to travel from `(0, 0)` to `(N-1, N-1)`",
    "description": "You are given an `N x N` grid of elevations. Find the minimum \"time\" `t` to travel from `(0, 0)` to `(N-1, N-1)`.",
    "code": "def swimInWater(grid: list[list[int]]) -> int:\n    n=len(grid)\n    pq, resolved = [(grid[0][0], 0, 0)], set()\n    while pq:\n        time, r, c = heapq.heappop(pq)\n        if (r, c) in resolved:continue\n        if (r, c) == (n - 1, n - 1):return time\n        resolved.add((r, c))\n        for nr, nc in [(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)]:\n            if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in resolved:\n                bottleneck_time = max(time, grid[nr][nc])\n                heapq.heappush(pq, (bottleneck_time, nr, nc))",
    "links": [],
    "variables": [
      {
        "name": "pq",
        "description": "Priority queue stores (max_elevation_on_path, r, c)",
        "type": "variable"
      },
      {
        "name": "resolved",
        "description": "set to store the cells for which we have found the minimum time required to reach them",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "findCheapestPriceDijkstra": {
    "name": "findCheapestPriceDijkstra",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 152,
    "signature": "def findCheapestPriceDijkstra( flights: list[list[int]], src: int, dst: int, k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Variables:",
    "code": "def findCheapestPriceDijkstra( flights: list[list[int]], src: int, dst: int, k: int) -> int:\n    graph = defaultdict(list)\n    for u, v, price in flights:\n        graph[u].append((v, price))\n    pq, min_stops = [(0, src, 0)], {}\n    while pq:\n        cost, city, stops = heapq.heappop(pq)\n        if stops > min_stops.get(city, float(\"inf\")): continue\n        if city == dst: return cost\n        min_stops[city] = stops\n        if stops <= k:\n            for neighbor, price in graph[city]:\n                heapq.heappush(pq, (cost + price, neighbor, stops + 1))\n    return -1",
    "links": [],
    "variables": [
      {
        "name": "pq",
        "description": "Priority queue to store the state (cost, city, stops_taken)",
        "type": "variable"
      },
      {
        "name": "min_stops",
        "description": "Tracks the minimum stops to reach each city",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "dijkstraShortestPath": {
    "name": "dijkstraShortestPath",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 183,
    "signature": "def dijkstraShortestPath(grid: list[list[int]], k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Finds the shortest path using Dijkstra's algorithm.",
    "code": "def dijkstraShortestPath(grid: list[list[int]], k: int) -> int:\n    rows, cols = len(grid), len(grid[0])\n    if k >= rows + cols - 3:\n        return rows + cols - 2\n    pq = [(0, 0, 0, k)]\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n    while pq:\n        steps, r, c, k_rem = heapq.heappop(pq)\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        if k_rem < max_k[r][c]:\n            continue\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if 0 <= (nr:= r + dr) < rows and 0 <= (nc:= c + dc) < cols:\n                if (new_k:= k_rem - grid[nr][nc]) > max_k[nr][nc]:\n                    max_k[nr][nc] = new_k\n                    heapq.heappush(pq, (steps + 1, nr, nc, new_k))\n    return -1",
    "links": [
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [
      {
        "name": "pq",
        "description": "(g_cost, r, c, k_rem), The priority uses g_cost (steps) itself. No heuristic is used.",
        "type": "variable"
      },
      {
        "name": "steps",
        "description": "The number of steps taken so far (g_cost)",
        "type": "variable"
      },
      {
        "name": "max_k",
        "description": "max_k[r][c] stores the max eliminations we have at cell (r,c)",
        "type": "variable"
      }
    ],
    "expressions": [
      {
        "expression": "heapq.heappush(pq, (steps + 1, nr, nc, new_k))",
        "description": "The priority is simply the new step count.No heuristic is added, which is the only difference from the A* implementation.",
        "type": "expression"
      },
      {
        "expression": "heapq.heappop(pq)",
        "description": "Pop the path with the lowest g_cost (steps) so far",
        "type": "expression"
      },
      {
        "expression": "k_rem < max_k[r][c]",
        "description": "Prune paths that are suboptimal for a given cell",
        "type": "expression"
      }
    ]
  },
  "Stock": {
    "name": "Stock",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/stocks.py",
    "line": 1,
    "signature": "class Stock:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class Stock:\n    def maxProfit(self, prices: list[int]) -> int:\n        cost, profit = float(\"inf\"), 0\n        for price in prices:\n            cost = min(cost, price)\n            profit = max(profit, price - cost)\n        return profit\n    def maxProfitII(self, prices: list[int]) -> int:\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit\n    def maxProfitIII_cost_profit_tracking(self, prices: list[int]) -> int:\n        t1_cost = t2_cost = float(\"inf\")\n        t1_profit = t2_profit = 0\n        for p in prices:\n            t1_cost = min(t1_cost, p)\n            t1_profit = max(t1_profit, p - t1_cost)\n            t2_cost = min(t2_cost, p - t1_profit)\n            t2_profit = max(t2_profit, p - t2_cost)\n        return t2_profit\n    def maxProfitIII_hold_sell_states(self, prices: list[int]) -> int:\n        sell1 = sell2 = 0             \n        for p in prices:\n            hold1 = max(hold1, -p)         \n            sell1 = max(sell1, hold1 + p)  \n            hold2 = max(hold2, sell1 - p)  \n            sell2 = max(sell2, hold2 + p)  \n        return sell2\n    def maxProfitIV_dp(self, k: int, prices: list[int]) -> int:\n        cost = [float(\"inf\")] * (k + 1)\n        profit = [0] * (k + 1)\n        for p in prices:\n            for t in range(1, k + 1):\n                cost[t] = min(cost[t], p - profit[t - 1])\n                profit[t] = max(profit[t], p - cost[t])\n        return profit[k]\n    def maxProfitIV_states(self, k: int, prices: list[int]) -> int:\n        buy  = [float(\"-inf\")] * (k + 1)\n        sell = [0] * (k + 1)\n        for p in prices:\n            for t in range(1, k + 1):\n                buy[t]  = max(buy[t],  sell[t - 1] - p)\n                sell[t] = max(sell[t], buy[t] + p)\n        return sell[k]",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Stock.maxProfit": {
    "name": "maxProfit",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/stocks.py",
    "line": 3,
    "signature": "def maxProfit(self, prices: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def maxProfit(self, prices: list[int]) -> int:\n        cost, profit = float(\"inf\"), 0\n        for price in prices:\n            cost = min(cost, price)\n            profit = max(profit, price - cost)\n        return profit",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Stock"
  },
  "Stock.maxProfitII": {
    "name": "maxProfitII",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/stocks.py",
    "line": 11,
    "signature": "def maxProfitII(self, prices: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def maxProfitII(self, prices: list[int]) -> int:\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Stock"
  },
  "Stock.maxProfitIII_cost_profit_tracking": {
    "name": "maxProfitIII_cost_profit_tracking",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/stocks.py",
    "line": 19,
    "signature": "def maxProfitIII_cost_profit_tracking(self, prices: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Expressions:",
    "code": "def maxProfitIII_cost_profit_tracking(self, prices: list[int]) -> int:\n        t1_cost = t2_cost = float(\"inf\")\n        t1_profit = t2_profit = 0\n        for p in prices:\n            t1_cost = min(t1_cost, p)\n            t1_profit = max(t1_profit, p - t1_cost)\n            t2_cost = min(t2_cost, p - t1_profit)\n            t2_profit = max(t2_profit, p - t2_cost)\n        return t2_profit",
    "links": [],
    "variables": [],
    "expressions": [
      {
        "expression": "p - t1_profit",
        "description": "money you'd need now if earlier profit covered part of this buy",
        "type": "expression"
      }
    ],
    "parent": "Stock"
  },
  "Stock.maxProfitIII_hold_sell_states": {
    "name": "maxProfitIII_hold_sell_states",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/stocks.py",
    "line": 42,
    "signature": "def maxProfitIII_hold_sell_states(self, prices: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Expressions:",
    "code": "def maxProfitIII_hold_sell_states(self, prices: list[int]) -> int:\n        sell1 = sell2 = 0             \n        for p in prices:\n            hold1 = max(hold1, -p)         \n            sell1 = max(sell1, hold1 + p)  \n            hold2 = max(hold2, sell1 - p)  \n            sell2 = max(sell2, hold2 + p)  \n        return sell2",
    "links": [],
    "variables": [],
    "expressions": [
      {
        "expression": "hold1 = hold2 = float(\"-inf\")",
        "description": "money you'd have if holding first stock",
        "type": "expression"
      },
      {
        "expression": "sell1 = sell2 = 0",
        "description": "money you'd have if not holding first stock",
        "type": "expression"
      },
      {
        "expression": "hold1 = max(hold1, -p)",
        "description": "buy first stock",
        "type": "expression"
      },
      {
        "expression": "sell1 = max(sell1, hold1 + p)",
        "description": "sell first stock",
        "type": "expression"
      },
      {
        "expression": "hold2 = max(hold2, sell1 - p)",
        "description": "buy second stock",
        "type": "expression"
      },
      {
        "expression": "sell2 = max(sell2, hold2 + p)",
        "description": "sell second stock",
        "type": "expression"
      }
    ],
    "parent": "Stock"
  },
  "Stock.maxProfitIV_dp": {
    "name": "maxProfitIV_dp",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/stocks.py",
    "line": 64,
    "signature": "def maxProfitIV_dp(self, k: int, prices: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def maxProfitIV_dp(self, k: int, prices: list[int]) -> int:\n        cost = [float(\"inf\")] * (k + 1)\n        profit = [0] * (k + 1)\n        for p in prices:\n            for t in range(1, k + 1):\n                cost[t] = min(cost[t], p - profit[t - 1])\n                profit[t] = max(profit[t], p - cost[t])\n        return profit[k]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Stock"
  },
  "Stock.maxProfitIV_states": {
    "name": "maxProfitIV_states",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/stocks.py",
    "line": 73,
    "signature": "def maxProfitIV_states(self, k: int, prices: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def maxProfitIV_states(self, k: int, prices: list[int]) -> int:\n        buy  = [float(\"-inf\")] * (k + 1)\n        sell = [0] * (k + 1)\n        for p in prices:\n            for t in range(1, k + 1):\n                buy[t]  = max(buy[t],  sell[t - 1] - p)\n                sell[t] = max(sell[t], buy[t] + p)\n        return sell[k]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Stock"
  },
  "searchInsert": {
    "name": "searchInsert",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 3,
    "signature": "def searchInsert(nums: list[int], target: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def searchInsert(nums: list[int], target: int) -> int:\n    return bisect_left(nums, target)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "simple_bisect_left": {
    "name": "simple_bisect_left",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 7,
    "signature": "def simple_bisect_left(a:list[int], x:int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Return the index where to insert item x in list a, assuming a is sorted.",
    "code": "def simple_bisect_left(a:list[int], x:int):\n    l, r = 0, len(a)\n    while l < r:\n        mid = (l + r) // 2\n        if x > a[mid]:\n            l = mid + 1\n        else:\n            r = mid\n    return l",
    "links": [
      {
        "symbol": "mid",
        "display": "[mid]",
        "target": "mid",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "mid",
        "display": "[mid]",
        "target": "mid",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": [
      {
        "expression": "l = mid + 1",
        "description": "If the target `x` is greater than the middle element `a[mid]`, the insertion point must be to the right of `mid`.",
        "type": "expression"
      },
      {
        "expression": "r = mid",
        "description": "If the target `x` is less than or equal to `a[mid]`, then `mid` is a potential answer, so we search the left half including `mid`.",
        "type": "expression"
      }
    ]
  },
  "simple_bisect_right": {
    "name": "simple_bisect_right",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 26,
    "signature": "def simple_bisect_right(a, x):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Return the index where to insert item x in list a, assuming a is sorted.",
    "code": "def simple_bisect_right(a, x):\n    l, r = 0, len(a)\n    while l < r:\n        mid = (l + r) // 2\n        if x < a[mid]:\n            r = mid\n        else: \n            l = mid + 1 \n    return l",
    "links": [],
    "variables": [],
    "expressions": [
      {
        "expression": "r = mid",
        "description": "If the x is less than the middle element, the insertion point could be `mid` or to its left. Shrink search space to the left half.",
        "type": "expression"
      },
      {
        "expression": "l = mid + 1",
        "description": "If the x is >= middle element, the insertion point must be to the right of `mid`.",
        "type": "expression"
      }
    ]
  },
  "searchRange": {
    "name": "searchRange",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 48,
    "signature": "def searchRange(nums: list[int], target: int) -> list[int]:",
    "parameters": [],
    "return_type": "list[int]",
    "return_description": "",
    "description": "",
    "code": "def searchRange(nums: list[int], target: int) -> list[int]:\n    start = bisect_left(nums, target)\n    if start < len(nums) and nums[start] == target:\n        return start, bisect_right(nums, target) - 1\n    return -1, -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "findMin": {
    "name": "findMin",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 55,
    "signature": "def findMin(nums: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Finds the minimum element in a rotated sorted array using binary search.",
    "code": "def findMin(nums: list[int]) -> int:\n    l, r = 0, len(nums) - 1\n    while l < r:\n        mid = (l + r) // 2\n        if nums[mid] < nums[r]:\n            r = mid\n        else:\n            l = mid + 1 \n    return nums[l]",
    "links": [
      {
        "symbol": "mid",
        "display": "[mid]",
        "target": "mid",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": [
      {
        "expression": "r = mid",
        "description": "If nums[mid] is less than nums[r], the minimum is in the left half (inclusive of mid).",
        "type": "expression"
      },
      {
        "expression": "l = mid + 1",
        "description": "the smallest is on the right",
        "type": "expression"
      }
    ]
  },
  "minEatingSpeed": {
    "name": "minEatingSpeed",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 76,
    "signature": "def minEatingSpeed(piles: list[int], h: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def minEatingSpeed(piles: list[int], h: int) -> int:\n    def hours(k:int) -> int:\n    l, r = 1, max(piles)\n    while l < r:\n        k = (l + r) // 2\n        if hours(k) <= h:\n            r = k\n        else:\n            l = k + 1\n    return l",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "minEatingSpeed.hours": {
    "name": "hours",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 78,
    "signature": "def hours(k:int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "computes total hours needed at speed k",
    "code": "def hours(k:int) -> int:",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "minEatingSpeed"
  },
  "shipWithinDays": {
    "name": "shipWithinDays",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 98,
    "signature": "def shipWithinDays(weights: list[int], days: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def shipWithinDays(weights: list[int], days: int) -> int:\n    def daysNeeded(capacity: int) -> int:\n        d, load = 1, 0\n        for w in weights:\n            if load + w <= capacity:\n                load += w\n            else:\n                d += 1\n                load = w\n        return d\n    l, r = max(weights), sum(weights)\n    while l < r:\n        capacity = (l + r) // 2\n        if daysNeeded(capacity) <= days:\n            r = capacity\n        else:\n            l = capacity + 1\n    return l",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "shipWithinDays.daysNeeded": {
    "name": "daysNeeded",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 100,
    "signature": "def daysNeeded(capacity: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def daysNeeded(capacity: int) -> int:\n        d, load = 1, 0\n        for w in weights:\n            if load + w <= capacity:\n                load += w\n            else:\n                d += 1\n                load = w\n        return d",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "shipWithinDays"
  },
  "SlidingWindow": {
    "name": "SlidingWindow",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/sliding_window.py",
    "line": 1,
    "signature": "class SlidingWindow:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class SlidingWindow:\n    def numSubarrayProductLessThanK(self, nums: list[int], k: int) -> int:\n        if k <= 1:return 0\n        product, left, count = 1, 0, 0\n        for right, num in enumerate(nums):\n            product *= num\n            while product >= k:\n                product //= nums[left]\n                left += 1\n            count += right - left + 1\n        return count\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        mp, l, max_length = {}, 0, 0\n        for r,c in enumerate(s):\n            if c in mp:\n                l = max(mp[c] + 1, l)\n            mp[c] = r\n            max_length = max(max_length, r - l + 1)\n        return max_length",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "SlidingWindow.numSubarrayProductLessThanK": {
    "name": "numSubarrayProductLessThanK",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/sliding_window.py",
    "line": 3,
    "signature": "def numSubarrayProductLessThanK(self, nums: list[int], k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def numSubarrayProductLessThanK(self, nums: list[int], k: int) -> int:\n        if k <= 1:return 0\n        product, left, count = 1, 0, 0\n        for right, num in enumerate(nums):\n            product *= num\n            while product >= k:\n                product //= nums[left]\n                left += 1\n            count += right - left + 1\n        return count",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "SlidingWindow"
  },
  "SlidingWindow.lengthOfLongestSubstring": {
    "name": "lengthOfLongestSubstring",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/sliding_window.py",
    "line": 18,
    "signature": "def lengthOfLongestSubstring(self, s: str) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Expressions:",
    "code": "def lengthOfLongestSubstring(self, s: str) -> int:\n        mp, l, max_length = {}, 0, 0\n        for r,c in enumerate(s):\n            if c in mp:\n                l = max(mp[c] + 1, l)\n            mp[c] = r\n            max_length = max(max_length, r - l + 1)\n        return max_length",
    "links": [
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": [
      {
        "expression": "l = max(mp[c] + 1, l)",
        "description": "ensures that l does not move backward in cases where the last occurrence of s[r] was before l.",
        "type": "expression"
      }
    ],
    "parent": "SlidingWindow"
  },
  "DP": {
    "name": "DP",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 1,
    "signature": "class DP:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class DP:\n    def minimumTotal(self, triangle: list[list[int]]) -> int:\n        n, memo = len(triangle), {}\n        def dp(r, c):\n            if r == n - 1:\n                return triangle[r][c]\n            if (r, c) not in memo:\n                memo[(r, c)] = triangle[r][c] + min(dp(r + 1, c), dp(r + 1, c + 1))\n            return memo[(r, c)]\n        return dp(0, 0)\n    def canPartition(self, nums: list[int]) -> bool:\n        memo, n = {}, len(nums)\n        def dp(i, s):\n                return False\n            if s == 0:\n                return True\n            if (i, s) not in memo:\n                memo[i, s] = dp(i + 1, s) or dp(i + 1, s - nums[i])\n            return memo[(i, s)]\n        return False if ((total := sum(nums)) & 1) else dp(0, total / 2)\n    def change(self, amount: int, coins: list[int]) -> int:\n        memo, n = {}, len(coins)\n        def dp(c, amount):\n            if amount == 0:\n                return 1\n            if amount < 0 or c == n:\n                return 0\n            if (c, amount) not in memo:\n                memo[c, amount] = dp(c, amount - coins[c]) + dp(c + 1, amount)\n            return memo[c, amount]\n        return dp(0, amount)\n    def winnerSquareGame(self, n: int) -> bool:\n        memo = {0: False}\n        def dp(n):\n            if n not in memo:\n                memo[n] = any(not dp(n - i**2) for i in range(int(n**0.5), 0, -1))\n            return memo[n]\n        return dp(n)\n    def mostPoints(self, questions: list[list[int]]) -> int:\n        memo, n = {}, len(questions)\n        def dp(i):\n            if i >= n:\n                return 0\n            if i not in memo:\n                memo[i] = max(dp(i + 1), (q:=questions[i])[0] + dp(i + 1 + q[1]))\n            return memo[i]\n        return dp(0)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "DP.minimumTotal": {
    "name": "minimumTotal",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 3,
    "signature": "def minimumTotal(self, triangle: list[list[int]]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Given a triangle (list of lists), find the minimum path sum from top to bottom.",
    "code": "def minimumTotal(self, triangle: list[list[int]]) -> int:\n        n, memo = len(triangle), {}\n        def dp(r, c):\n            if r == n - 1:\n                return triangle[r][c]\n            if (r, c) not in memo:\n                memo[(r, c)] = triangle[r][c] + min(dp(r + 1, c), dp(r + 1, c + 1))\n            return memo[(r, c)]\n        return dp(0, 0)",
    "links": [],
    "variables": [],
    "expressions": [
      {
        "expression": "r == n - 1",
        "description": "bottom row",
        "type": "expression"
      }
    ],
    "parent": "DP"
  },
  "DP.minimumTotal.dp": {
    "name": "dp",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 14,
    "signature": "def dp(r, c):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def dp(r, c):\n            if r == n - 1:\n                return triangle[r][c]\n            if (r, c) not in memo:\n                memo[(r, c)] = triangle[r][c] + min(dp(r + 1, c), dp(r + 1, c + 1))\n            return memo[(r, c)]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "DP.minimumTotal"
  },
  "DP.canPartition": {
    "name": "canPartition",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 23,
    "signature": "def canPartition(self, nums: list[int]) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "",
    "code": "def canPartition(self, nums: list[int]) -> bool:\n        memo, n = {}, len(nums)\n        def dp(i, s):\n                return False\n            if s == 0:\n                return True\n            if (i, s) not in memo:\n                memo[i, s] = dp(i + 1, s) or dp(i + 1, s - nums[i])\n            return memo[(i, s)]\n        return False if ((total := sum(nums)) & 1) else dp(0, total / 2)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "DP"
  },
  "DP.canPartition.dp": {
    "name": "dp",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 27,
    "signature": "def dp(i, s):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Expressions:",
    "code": "def dp(i, s):\n                return False\n            if s == 0:\n                return True\n            if (i, s) not in memo:\n                memo[i, s] = dp(i + 1, s) or dp(i + 1, s - nums[i])\n            return memo[(i, s)]",
    "links": [],
    "variables": [],
    "expressions": [
      {
        "expression": "(total := sum(nums)) & 1",
        "description": "odd sum",
        "type": "expression"
      }
    ],
    "parent": "DP.canPartition"
  },
  "DP.change": {
    "name": "change",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 44,
    "signature": "def change(self, amount: int, coins: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def change(self, amount: int, coins: list[int]) -> int:\n        memo, n = {}, len(coins)\n        def dp(c, amount):\n            if amount == 0:\n                return 1\n            if amount < 0 or c == n:\n                return 0\n            if (c, amount) not in memo:\n                memo[c, amount] = dp(c, amount - coins[c]) + dp(c + 1, amount)\n            return memo[c, amount]\n        return dp(0, amount)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "DP"
  },
  "DP.change.dp": {
    "name": "dp",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 48,
    "signature": "def dp(c, amount):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def dp(c, amount):\n            if amount == 0:\n                return 1\n            if amount < 0 or c == n:\n                return 0\n            if (c, amount) not in memo:\n                memo[c, amount] = dp(c, amount - coins[c]) + dp(c + 1, amount)\n            return memo[c, amount]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "DP.change"
  },
  "DP.winnerSquareGame": {
    "name": "winnerSquareGame",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 59,
    "signature": "def winnerSquareGame(self, n: int) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "",
    "code": "def winnerSquareGame(self, n: int) -> bool:\n        memo = {0: False}\n        def dp(n):\n            if n not in memo:\n                memo[n] = any(not dp(n - i**2) for i in range(int(n**0.5), 0, -1))\n            return memo[n]\n        return dp(n)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "DP"
  },
  "DP.winnerSquareGame.dp": {
    "name": "dp",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 63,
    "signature": "def dp(n):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def dp(n):\n            if n not in memo:\n                memo[n] = any(not dp(n - i**2) for i in range(int(n**0.5), 0, -1))\n            return memo[n]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "DP.winnerSquareGame"
  },
  "DP.mostPoints": {
    "name": "mostPoints",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 71,
    "signature": "def mostPoints(self, questions: list[list[int]]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def mostPoints(self, questions: list[list[int]]) -> int:\n        memo, n = {}, len(questions)\n        def dp(i):\n            if i >= n:\n                return 0\n            if i not in memo:\n                memo[i] = max(dp(i + 1), (q:=questions[i])[0] + dp(i + 1 + q[1]))\n            return memo[i]\n        return dp(0)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "DP"
  },
  "DP.mostPoints.dp": {
    "name": "dp",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 75,
    "signature": "def dp(i):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def dp(i):\n            if i >= n:\n                return 0\n            if i not in memo:\n                memo[i] = max(dp(i + 1), (q:=questions[i])[0] + dp(i + 1 + q[1]))\n            return memo[i]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "DP.mostPoints"
  },
  "LRUCache": {
    "name": "LRUCache",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 4,
    "signature": "class LRUCache:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "The LRU system is simple. It tracks *when* a book was last used.",
    "code": "class LRUCache:\n        self.cache: OrderedDict[int, int] = OrderedDict()\n        self.capacity = capacity\n    def get(self, key: int) -> int:\n            return -1\n        self.cache.move_to_end(key)\n        return val\n    def put(self, key: int, value: int) -> None:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "LRUCache.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 8,
    "signature": "def __init__(self, capacity: int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, capacity: int):\n        self.cache: OrderedDict[int, int] = OrderedDict()\n        self.capacity = capacity",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LRUCache"
  },
  "LRUCache.get": {
    "name": "get",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 12,
    "signature": "def get(self, key: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "When an item is accessed, it becomes the most recently used. We fetch the item and move it to the end of the `OrderedDict`.",
    "code": "def get(self, key: int) -> int:\n            return -1\n        self.cache.move_to_end(key)\n        return val",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LRUCache"
  },
  "LRUCache.put": {
    "name": "put",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 21,
    "signature": "def put(self, key: int, value: int) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "When an item is added or updated, it's also considered the most recently used and is moved to the end. If the cache exceeds its capacity, the item at the front of the OrderedDict (the least recently used) is removed.",
    "code": "def put(self, key: int, value: int) -> None:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LRUCache"
  },
  "LFUCache": {
    "name": "LFUCache",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 33,
    "signature": "class LFUCache:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "The LFU system is more sophisticated. It tracks not just *when* a book was last used, but also *how often* it has been used.",
    "code": "class LFUCache:\n        self.capacity    = capacity\n        self.cache       = {}  \n        self.freq        = {}  \n        self.buckets     = defaultdict(OrderedDict)  \n        self.minfreq     = 0\n    def _bump(self, key: int):\n        del self.buckets[f][key]\n        if not self.buckets[f]:\n            del self.buckets[f]\n            if self.minfreq == f:\n                self.minfreq += 1\n        self.freq[key] +=1 \n        self.buckets[f + 1][key] = None\n    def get(self, key: int) -> int:\n            return -1\n        self._bump(key)\n        return self.cache[key]\n    def put(self, key: int, value: int) -> None:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._bump(key)\n            return\n        if len(self.cache) >= self.capacity:\n            old_key, _ = self.buckets[self.minfreq].popitem(last=False)\n            del self.cache[old_key]\n            del self.freq[old_key]\n        self.cache[key] = value\n        self.freq[key] = 1\n        self.buckets[1][key] = None\n        self.minfreq = 1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "LFUCache.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 37,
    "signature": "def __init__(self, capacity: int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, capacity: int):\n        self.capacity    = capacity\n        self.cache       = {}  \n        self.freq        = {}  \n        self.buckets     = defaultdict(OrderedDict)  \n        self.minfreq     = 0",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "LFUCache._bump": {
    "name": "_bump",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 44,
    "signature": "def _bump(self, key: int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Move key from freq f to f+1.",
    "code": "def _bump(self, key: int):\n        del self.buckets[f][key]\n        if not self.buckets[f]:\n            del self.buckets[f]\n            if self.minfreq == f:\n                self.minfreq += 1\n        self.freq[key] +=1 \n        self.buckets[f + 1][key] = None",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "LFUCache.get": {
    "name": "get",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 58,
    "signature": "def get(self, key: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "When an item is accessed (get or put), its frequency count is incremented, and it moves from its current frequency bucket to the next, becoming the most recent item in that new bucket. For eviction, we remove the least recently used item from the lowest frequency bucket.",
    "code": "def get(self, key: int) -> int:\n            return -1\n        self._bump(key)\n        return self.cache[key]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "LFUCache.put": {
    "name": "put",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 67,
    "signature": "def put(self, key: int, value: int) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "When an item is added or updated, its frequency count is set to 1, and it's added to the lowest frequency bucket. If the cache exceeds its capacity, the least recently used item from the lowest frequency bucket is removed.",
    "code": "def put(self, key: int, value: int) -> None:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._bump(key)\n            return\n        if len(self.cache) >= self.capacity:\n            old_key, _ = self.buckets[self.minfreq].popitem(last=False)\n            del self.cache[old_key]\n            del self.freq[old_key]\n        self.cache[key] = value\n        self.freq[key] = 1\n        self.buckets[1][key] = None\n        self.minfreq = 1",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "Kadane": {
    "name": "Kadane",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/kadane.py",
    "line": 1,
    "signature": "class Kadane:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class Kadane:\n    def maxSubArray(self, nums: list[int]) -> int:\n        max_sum = curr_sum = float(\"-inf\")\n        for num in nums:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n    def maxProduct(self, nums: list[int]) -> int:\n        hi = lo = max_prod = nums[0]\n        for x in nums[1:]:\n            if x < 0:\n                hi, lo = lo, hi\n            hi = max(x, hi * x)\n            lo = min(x, lo * x)\n            max_prod = max(max_prod, hi)\n        return max_prod\n    def maxSubarraySumCircular(self, nums: list[int]) -> int:\n        total, max_end = min_end = 0\n        max_sum, min_sum = float(\"-inf\"), float(\"inf\")\n        for x in nums:\n            total += x\n            max_end = max(x, max_end + x)\n            max_sum = max(max_sum, max_end)  \n            min_end = min(x, min_end + x)\n            min_sum = min(min_sum, min_end)  \n        return max_sum if max_sum < 0 else max(max_sum, total - min_sum)\n    def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:\n        pass",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Kadane.maxSubArray": {
    "name": "maxSubArray",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/kadane.py",
    "line": 3,
    "signature": "def maxSubArray(self, nums: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def maxSubArray(self, nums: list[int]) -> int:\n        max_sum = curr_sum = float(\"-inf\")\n        for num in nums:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Kadane"
  },
  "Kadane.maxProduct": {
    "name": "maxProduct",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/kadane.py",
    "line": 10,
    "signature": "def maxProduct(self, nums: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def maxProduct(self, nums: list[int]) -> int:\n        hi = lo = max_prod = nums[0]\n        for x in nums[1:]:\n            if x < 0:\n                hi, lo = lo, hi\n            hi = max(x, hi * x)\n            lo = min(x, lo * x)\n            max_prod = max(max_prod, hi)\n        return max_prod",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Kadane"
  },
  "Kadane.maxSubarraySumCircular": {
    "name": "maxSubarraySumCircular",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/kadane.py",
    "line": 22,
    "signature": "def maxSubarraySumCircular(self, nums: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def maxSubarraySumCircular(self, nums: list[int]) -> int:\n        total, max_end = min_end = 0\n        max_sum, min_sum = float(\"-inf\"), float(\"inf\")\n        for x in nums:\n            total += x\n            max_end = max(x, max_end + x)\n            max_sum = max(max_sum, max_end)  \n            min_end = min(x, min_end + x)\n            min_sum = min(min_sum, min_end)  \n        return max_sum if max_sum < 0 else max(max_sum, total - min_sum)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Kadane"
  },
  "Kadane.maxSumSubmatrix": {
    "name": "maxSumSubmatrix",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/kadane.py",
    "line": 33,
    "signature": "def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:\n        pass",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Kadane"
  },
  "Backtrack": {
    "name": "Backtrack",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/backtrack.py",
    "line": 1,
    "signature": "class Backtrack:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class Backtrack:\n    def solveNQueens(self, n: int) -> list[list[str]]:\n        result, board = [], [[\".\"] * n for _ in range(n)]\n        cols, diag1, diag2 = set(), set(), set()\n        def dfs(row: int):\n            if row == n:\n                result.append([\"\".join(r) for r in board])\n                return\n            for col in range(n):\n                if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                    continue\n                board[row][col] = \"Q\"\n                cols.add(col)\n                diag1.add(row - col)\n                diag2.add(row + col)\n                dfs(row + 1)\n                board[row][col] = \".\"\n                cols.remove(col)\n                diag1.remove(row - col)\n                diag2.remove(row + col)\n        dfs(0)\n        return result\n    def exist(self, board: list[list[str]], word: str) -> bool:\n        rows, cols, n = len(board), len(board[0]), len(word)\n        def dfs(r: int, c: int, i: int) -> bool:\n            if i == n:\n                return True\n            if not (0 <= r < rows and 0 <= c < cols and board[r][c] == word[i]):\n                return False\n            tmp, board[r][c] = board[r][c], \"\n            for x, y in ((r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)):\n                if dfs(x, y, i + 1):\n                    board[r][c] = tmp\n                    return True\n            board[r][c] = tmp\n            return False\n        return any(\n            dfs(r, c, 0)\n            for r in range(rows)\n            for c in range(cols)\n            if board[r][c] == word[0]\n        )\n    def permute(self, nums: list[int]) -> list[list[int]]:\n        result, n = [], len(nums)\n        def dfs(i):\n            if i == n:\n                result.append(nums[:])\n            else:\n                for j in range(i, n):\n                    nums[i], nums[j] = nums[j], nums[i]\n                    dfs(i + 1)\n                    nums[j], nums[i] = nums[i], nums[j]\n        dfs(0)\n        return result\n    def combinationSum(self, candidates: list[int], target: int) -> list[list[int]]:\n        candidates.sort()\n        res, path = [], []\n        def dfs(i: int, rem: int) -> None:\n            if rem == 0:\n                res.append(path.copy())\n                return\n            for j in range(i, len(candidates)):\n                if (c := candidates[j]) > rem:\n                    break\n                path.append(c)\n                dfs(j, rem - c)\n                path.pop()\n        dfs(0, target)\n        return res",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Backtrack.solveNQueens": {
    "name": "solveNQueens",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/backtrack.py",
    "line": 2,
    "signature": "def solveNQueens(self, n: int) -> list[list[str]]:",
    "parameters": [],
    "return_type": "list[list[str]]",
    "return_description": "",
    "description": "Variables:",
    "code": "def solveNQueens(self, n: int) -> list[list[str]]:\n        result, board = [], [[\".\"] * n for _ in range(n)]\n        cols, diag1, diag2 = set(), set(), set()\n        def dfs(row: int):\n            if row == n:\n                result.append([\"\".join(r) for r in board])\n                return\n            for col in range(n):\n                if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                    continue\n                board[row][col] = \"Q\"\n                cols.add(col)\n                diag1.add(row - col)\n                diag2.add(row + col)\n                dfs(row + 1)\n                board[row][col] = \".\"\n                cols.remove(col)\n                diag1.remove(row - col)\n                diag2.remove(row + col)\n        dfs(0)\n        return result",
    "links": [
      {
        "symbol": "row",
        "display": "[row]",
        "target": "row",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "col",
        "display": "[col]",
        "target": "col",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "row",
        "display": "[row]",
        "target": "row",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "col",
        "display": "[col]",
        "target": "col",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [
      {
        "name": "cols",
        "description": "Columns where queens are placed",
        "type": "variable"
      },
      {
        "name": "diag1",
        "description": "The main diagonal where queens are placed (↘) r - c",
        "type": "variable"
      },
      {
        "name": "diag2",
        "description": "The anti-diagonal where queens are placed (↙) r + c",
        "type": "variable"
      }
    ],
    "expressions": [
      {
        "expression": "board[row][col] = \".\"",
        "description": "Remove the queen (backtrack)",
        "type": "expression"
      },
      {
        "expression": "board[row][col] = \"Q\"",
        "description": "Place the queen",
        "type": "expression"
      },
      {
        "expression": "continue",
        "description": "Skip invalid positions",
        "type": "expression"
      },
      {
        "expression": "dfs(row + 1)",
        "description": "Recurse to the next row",
        "type": "expression"
      }
    ],
    "parent": "Backtrack"
  },
  "Backtrack.solveNQueens.dfs": {
    "name": "dfs",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/backtrack.py",
    "line": 20,
    "signature": "def dfs(row: int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def dfs(row: int):\n            if row == n:\n                result.append([\"\".join(r) for r in board])\n                return\n            for col in range(n):\n                if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                    continue\n                board[row][col] = \"Q\"\n                cols.add(col)\n                diag1.add(row - col)\n                diag2.add(row + col)\n                dfs(row + 1)\n                board[row][col] = \".\"\n                cols.remove(col)\n                diag1.remove(row - col)\n                diag2.remove(row + col)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Backtrack.solveNQueens"
  },
  "Backtrack.exist": {
    "name": "exist",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/backtrack.py",
    "line": 45,
    "signature": "def exist(self, board: list[list[str]], word: str) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "",
    "code": "def exist(self, board: list[list[str]], word: str) -> bool:\n        rows, cols, n = len(board), len(board[0]), len(word)\n        def dfs(r: int, c: int, i: int) -> bool:\n            if i == n:\n                return True\n            if not (0 <= r < rows and 0 <= c < cols and board[r][c] == word[i]):\n                return False\n            tmp, board[r][c] = board[r][c], \"\n            for x, y in ((r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)):\n                if dfs(x, y, i + 1):\n                    board[r][c] = tmp\n                    return True\n            board[r][c] = tmp\n            return False\n        return any(\n            dfs(r, c, 0)\n            for r in range(rows)\n            for c in range(cols)\n            if board[r][c] == word[0]\n        )",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Backtrack"
  },
  "Backtrack.exist.dfs": {
    "name": "dfs",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/backtrack.py",
    "line": 49,
    "signature": "def dfs(r: int, c: int, i: int) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "",
    "code": "def dfs(r: int, c: int, i: int) -> bool:\n            if i == n:\n                return True\n            if not (0 <= r < rows and 0 <= c < cols and board[r][c] == word[i]):\n                return False\n            tmp, board[r][c] = board[r][c], \"\n            for x, y in ((r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)):\n                if dfs(x, y, i + 1):\n                    board[r][c] = tmp\n                    return True\n            board[r][c] = tmp\n            return False",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Backtrack.exist"
  },
  "Backtrack.permute": {
    "name": "permute",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/backtrack.py",
    "line": 69,
    "signature": "def permute(self, nums: list[int]) -> list[list[int]]:",
    "parameters": [],
    "return_type": "list[list[int]]",
    "return_description": "",
    "description": "",
    "code": "def permute(self, nums: list[int]) -> list[list[int]]:\n        result, n = [], len(nums)\n        def dfs(i):\n            if i == n:\n                result.append(nums[:])\n            else:\n                for j in range(i, n):\n                    nums[i], nums[j] = nums[j], nums[i]\n                    dfs(i + 1)\n                    nums[j], nums[i] = nums[i], nums[j]\n        dfs(0)\n        return result",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Backtrack"
  },
  "Backtrack.permute.dfs": {
    "name": "dfs",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/backtrack.py",
    "line": 73,
    "signature": "def dfs(i):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def dfs(i):\n            if i == n:\n                result.append(nums[:])\n            else:\n                for j in range(i, n):\n                    nums[i], nums[j] = nums[j], nums[i]\n                    dfs(i + 1)\n                    nums[j], nums[i] = nums[i], nums[j]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Backtrack.permute"
  },
  "Backtrack.combinationSum": {
    "name": "combinationSum",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/backtrack.py",
    "line": 86,
    "signature": "def combinationSum(self, candidates: list[int], target: int) -> list[list[int]]:",
    "parameters": [],
    "return_type": "list[list[int]]",
    "return_description": "",
    "description": "",
    "code": "def combinationSum(self, candidates: list[int], target: int) -> list[list[int]]:\n        candidates.sort()\n        res, path = [], []\n        def dfs(i: int, rem: int) -> None:\n            if rem == 0:\n                res.append(path.copy())\n                return\n            for j in range(i, len(candidates)):\n                if (c := candidates[j]) > rem:\n                    break\n                path.append(c)\n                dfs(j, rem - c)\n                path.pop()\n        dfs(0, target)\n        return res",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Backtrack"
  },
  "Backtrack.combinationSum.dfs": {
    "name": "dfs",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/backtrack.py",
    "line": 90,
    "signature": "def dfs(i: int, rem: int) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "",
    "code": "def dfs(i: int, rem: int) -> None:\n            if rem == 0:\n                res.append(path.copy())\n                return\n            for j in range(i, len(candidates)):\n                if (c := candidates[j]) > rem:\n                    break\n                path.append(c)\n                dfs(j, rem - c)\n                path.pop()",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Backtrack.combinationSum"
  },
  "Stack": {
    "name": "Stack",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/stack.py",
    "line": 1,
    "signature": "class Stack:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class Stack:\n    def decodeString(self, s: str) -> str:\n        stack, s = [], \"1[\" + s + \"]\"\n        for c in s:\n            if c == \"]\":\n                curr = []\n                while stack[-1] != \"[\":\n                    curr.append(stack.pop())\n                stack.pop()  \n                num = []\n                while stack and stack[-1].isdigit():\n                    num.append(stack.pop())\n                stack.append(\"\".join(reversed(curr)) * int(\"\".join(reversed(num))))\n            else:\n                stack.append(c)\n        return stack[0]",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Stack.decodeString": {
    "name": "decodeString",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/stack.py",
    "line": 2,
    "signature": "def decodeString(self, s: str) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "",
    "code": "def decodeString(self, s: str) -> str:\n        stack, s = [], \"1[\" + s + \"]\"\n        for c in s:\n            if c == \"]\":\n                curr = []\n                while stack[-1] != \"[\":\n                    curr.append(stack.pop())\n                stack.pop()  \n                num = []\n                while stack and stack[-1].isdigit():\n                    num.append(stack.pop())\n                stack.append(\"\".join(reversed(curr)) * int(\"\".join(reversed(num))))\n            else:\n                stack.append(c)\n        return stack[0]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Stack"
  },
  "TreeNode": {
    "name": "TreeNode",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 4,
    "signature": "class TreeNode:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "TreeNode.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 5,
    "signature": "def __init__(self, val=0, left=None, right=None):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TreeNode"
  },
  "levelOrder": {
    "name": "levelOrder",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 11,
    "signature": "def levelOrder(root: TreeNode | None) -> list[list[int]]:",
    "parameters": [],
    "return_type": "list[list[int]]",
    "return_description": "",
    "description": "",
    "code": "def levelOrder(root: TreeNode | None) -> list[list[int]]:\n    if not root:\n        return []\n    queue, result = deque([root]), []\n    while queue:\n        level = [] \n        for _ in range(len(queue)):  \n            node = queue.popleft()\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level)\n    return result",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "numIslands": {
    "name": "numIslands",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 29,
    "signature": "def numIslands(grid: list[list[str]]) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[str]]",
        "description": "`m x n` 2D grid of `1`s (land) and `0`s (water), assume all four edges of the grid are all surrounded by water.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "number of islands",
    "description": "Args:",
    "code": "def numIslands(grid: list[list[str]]) -> int:\n        return 0\n    m, n = len(grid), len(grid[0])\n    dirs = ((1,0),(-1,0),(0,1),(0,-1))\n    islands = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                islands += 1\n                grid[i][j] = \"0\" \n                q = deque([(i, j)])\n                while q:\n                    r, c = q.popleft()\n                    for dr, dc in dirs:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == \"1\":\n                            grid[nr][nc] = \"0\" \n                            q.append((nr, nc)) \n    return islands",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "orangesRotting": {
    "name": "orangesRotting",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 60,
    "signature": "def orangesRotting(grid: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[int]]",
        "description": "`m x n` 2D grid of $0_{(empty)}$ , $1_{(fresh)}$ , $2_{(rotten)}$",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minutes required until no fresh oranges remain. If it's impossible, return -1.",
    "description": "Args:",
    "code": "def orangesRotting(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    q, fresh = deque(), 0\n    dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append((i, j))\n            elif grid[i][j] == 1:\n                fresh += 1\n    if fresh == 0:\n        return 0\n    minutes = 0\n    while q and fresh:\n        minutes += 1\n        for _ in range(len(q)):\n            x, y = q.popleft()\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh -= 1\n                    q.append((nx, ny))\n    return minutes if fresh == 0 else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Node": {
    "name": "Node",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 97,
    "signature": "class Node:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Node.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 98,
    "signature": "def __init__(self, val=0, neighbors=None):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Node"
  },
  "cloneGraph": {
    "name": "cloneGraph",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 103,
    "signature": "def cloneGraph(node: Node | None) -> Node | None:",
    "parameters": [
      {
        "name": "node",
        "type": "Node | None",
        "description": "reference to a node in a connected undirected graph",
        "default": null
      }
    ],
    "return_type": "Node | None",
    "return_description": "deep copy of the graph",
    "description": "Args:",
    "code": "def cloneGraph(node: Node | None) -> Node | None:\n        return None\n    cloned = {node: Node(node.val)}\n    queue = deque([node])\n    while queue:\n        cur = queue.popleft()\n        for n in cur.neighbors:\n            if n not in cloned:\n                cloned[n] = Node(n.val)\n                queue.append(n)\n            cloned[cur].neighbors.append(cloned[n])\n    return cloned[node]",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "snakesAndLadders": {
    "name": "snakesAndLadders",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 127,
    "signature": "def snakesAndLadders(board: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "board",
        "type": "list[list[int]]",
        "description": "`n x n` 2D grid of `-1`s (normal squares) or [`1` , `n*n`] (snake/ladder)",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum number of moves to reach the final square `n*n`",
    "description": "Args:",
    "code": "def snakesAndLadders(board: list[list[int]]) -> int:\n    flat_board =  [0] \n    for r, row in enumerate(reversed(board)):\n        flat_board.extend(row[::1 if r % 2 == 0 else -1])\n    target =(n:= len(board)) * n \n    moves, queue =  {1: 0}, deque([1])\n    while queue:\n        current = queue.popleft()\n        for roll in range(1, 7):\n            nxt = current + roll\n            if nxt > target:\n                break\n            landing = flat_board[nxt] if flat_board[nxt] != -1 else nxt\n            if landing not in moves:\n                moves[landing] = moves[current] + 1\n                if landing == target:\n                    return moves[landing]\n                queue.append(landing)\n    return -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "updateMatrix": {
    "name": "updateMatrix",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 157,
    "signature": "def updateMatrix(mat : list[list[int]]) -> list[list[int]]:",
    "parameters": [],
    "return_type": "list[list[int]]",
    "return_description": "",
    "description": "",
    "code": "def updateMatrix(mat : list[list[int]]) -> list[list[int]]:\n    m, n = len(mat), len(mat[0])\n    dist = [[-1] * n for _ in range(m)]\n    q = deque()\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and dist[ni][nj] < 0:\n                dist[ni][nj] = dist[i][j] + 1\n                q.append((ni, nj))\n    return dist",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "shortestPath": {
    "name": "shortestPath",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 180,
    "signature": "def shortestPath(grid: list[list[int]], k: int) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[int]]",
        "description": "`m x n` 2D grid of `0`s (empty) and `1`s (obstacle)",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "maximum number of eliminations allowed",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum number of steps to reach the bottom-right corner, or -1 if it's impossible",
    "description": "Args:",
    "code": "def shortestPath(grid: list[list[int]], k: int) -> int:\n    rows, cols = len(grid), len(grid[0])\n    min_steps = rows + cols - 3 \n    if k >= min_steps:\n        return min_steps\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n    q = deque([(0, 0, 0, k)])\n    while q:\n        r, c, steps, remaining_k = q.popleft()\n        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                new_remaining_k = remaining_k - grid[nr][nc]\n                if new_remaining_k > max_k[nr][nc]:\n                    if (nr, nc) == (rows - 1, cols - 1):\n                        return steps + 1\n                    max_k[nr][nc] = new_remaining_k\n                    q.append((nr, nc, steps + 1, new_remaining_k))\n    return -1",
    "links": [
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [
      {
        "name": "max_k",
        "description": "max_k[r][c] = maximum eliminations remaining when visiting (r,c)",
        "type": "variable"
      },
      {
        "name": "q",
        "description": "(row, col, steps, remaining_k)",
        "type": "variable"
      },
      {
        "name": "min_steps",
        "description": "Manhattan distance lower bound",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "ladderLength": {
    "name": "ladderLength",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 224,
    "signature": "def ladderLength(beginWord: str, endWord: str, wordList: list[str]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def ladderLength(beginWord: str, endWord: str, wordList: list[str]) -> int:\n    if endWord not in wordList:\n        return 0\n    L = len(beginWord)\n    combos: dict[str, list[str]] = defaultdict(list)\n    for w in wordList:\n        for i in range(L):\n            combos[w[:i] + \"*\" + w[i+1:]].append(w)\n    front, back = {beginWord}, {endWord}\n    dist_front, dist_back = {beginWord: 1}, {endWord: 1}\n    while front and back:\n        if len(front) > len(back):\n            front, back = back, front\n            dist_front, dist_back = dist_back, dist_front\n        next_front = set()\n        for word in front:\n            for i in range(L):\n                for n in combos[word[:i] + \"*\" + word[i+1:]]: \n                    if n in dist_back:\n                        return dist_front[word] + dist_back[n]\n                    if n not in dist_front:\n                        dist_front[n] = dist_front[word] + 1\n                        next_front.add(n)\n        front = next_front\n    return 0",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "mod": {
    "name": "mod",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/modular-arithmetic.py",
    "line": 1,
    "signature": "def mod(a: int, b: int) -> int:",
    "parameters": [
      {
        "name": "a",
        "type": "int",
        "description": "the first number1",
        "default": null
      },
      {
        "name": "b",
        "type": "int",
        "description": "the second number",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "int",
    "description": "a mod b",
    "code": "def mod(a: int, b: int) -> int:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "congruent1": {
    "name": "congruent1",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/modular-arithmetic.py",
    "line": 14,
    "signature": "def congruent1(a: int, b: int, n: int) -> bool:",
    "parameters": [
      {
        "name": "a",
        "type": "int",
        "description": "the first number2",
        "default": null
      },
      {
        "name": "b",
        "type": "int",
        "description": "the second number",
        "default": null
      },
      {
        "name": "n",
        "type": "int",
        "description": "the modulus, the number by which we are dividing",
        "default": null
      }
    ],
    "return_type": "bool",
    "return_description": "bool",
    "description": "a ≡ b (mod n)",
    "code": "def congruent1(a: int, b: int, n: int) -> bool:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "congruent2": {
    "name": "congruent2",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/modular-arithmetic.py",
    "line": 27,
    "signature": "def congruent2(a: int, b: int, n: int) -> bool:",
    "parameters": [
      {
        "name": "a",
        "type": "int",
        "description": "the first number3",
        "default": null
      },
      {
        "name": "b",
        "type": "int",
        "description": "the second number",
        "default": null
      },
      {
        "name": "n",
        "type": "int",
        "description": "the modulus, the number by which we are dividing",
        "default": null
      }
    ],
    "return_type": "bool",
    "return_description": "bool",
    "description": "a ≡ b (mod n)",
    "code": "def congruent2(a: int, b: int, n: int) -> bool:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "TrieNode": {
    "name": "TrieNode",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 4,
    "signature": "class TrieNode:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "A node in the Trie.",
    "code": "class TrieNode:\n    __slots__ = (\"children\", \"end\")\n    def __init__(self):\n        self.children: defaultdict[str, TrieNode] = defaultdict(TrieNode)\n        self.end = False",
    "links": [],
    "variables": [
      {
        "name": "children",
        "description": "maps characters to child TrieNodes, auto-created on first access",
        "type": "variable"
      },
      {
        "name": "end",
        "description": "bool flag indicating this node marks the end of a valid word",
        "type": "variable"
      },
      {
        "name": "__slots__",
        "description": "restrict instances to only these attributes (no __dict__) to save memory and speed up attribute access",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "TrieNode.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 16,
    "signature": "def __init__(self):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self):\n        self.children: defaultdict[str, TrieNode] = defaultdict(TrieNode)\n        self.end = False",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TrieNode"
  },
  "Trie": {
    "name": "Trie",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 22,
    "signature": "class Trie:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Trie (prefix tree) for storing strings.",
    "code": "class Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children[ch]\n        node.end = True\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if (node := node.children.get(ch)) is None:\n                return False\n        return node.end\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if (node := node.children.get(ch)) is None:\n                return False\n        return True",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Trie.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 27,
    "signature": "def __init__(self):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Initializes the Trie with an empty root node.",
    "code": "def __init__(self):\n        self.root = TrieNode()",
    "links": [],
    "variables": [
      {
        "name": "root",
        "description": "the root TrieNode, representing the empty prefix",
        "type": "variable"
      }
    ],
    "expressions": [],
    "parent": "Trie"
  },
  "Trie.insert": {
    "name": "insert",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 37,
    "signature": "def insert(self, word: str) -> None:",
    "parameters": [
      {
        "name": "word",
        "type": "str",
        "description": "string to insert into the Trie",
        "default": null
      }
    ],
    "return_type": "None",
    "return_description": "",
    "description": "Inserts a word into the Trie.",
    "code": "def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children[ch]\n        node.end = True",
    "links": [
      {
        "symbol": "ch",
        "display": "[ch]",
        "target": "ch",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [
      {
        "name": "node",
        "description": "current TrieNode during traversal",
        "type": "variable"
      }
    ],
    "expressions": [
      {
        "expression": "node = node.children[ch]",
        "description": "Traverse to the child node for ch, creating it if missing",
        "type": "expression"
      },
      {
        "expression": "node.end = True",
        "description": "Mark this node as terminating a valid word",
        "type": "expression"
      }
    ],
    "parent": "Trie"
  },
  "Trie.search": {
    "name": "search",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 61,
    "signature": "def search(self, word: str) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "",
    "code": "def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if (node := node.children.get(ch)) is None:\n                return False\n        return node.end",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Trie"
  },
  "Trie.startsWith": {
    "name": "startsWith",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 68,
    "signature": "def startsWith(self, prefix: str) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "",
    "code": "def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if (node := node.children.get(ch)) is None:\n                return False\n        return True",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Trie"
  },
  "WordDictionary": {
    "name": "WordDictionary",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 76,
    "signature": "class WordDictionary:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class WordDictionary:\n    def __init__(self):\n        self.trie: dict[str, dict] = {}\n        self.END_MARKER = \"$\"\n    def addWord(self, word: str) -> None:\n        node = self.trie\n        for c in word:\n            node = node.setdefault(c, {})\n        node[self.END_MARKER] = True\n    def search(self, word: str) -> bool:\n        def dfs(node: dict, i: int) -> bool:\n            if i == len(word):\n                return self.END_MARKER in node\n            if (c := word[i]) == \".\":\n                return any(\n                    dfs(child, i + 1)\n                    for k, child in node.items()\n                    if k != self.END_MARKER\n                )\n            child = node.get(c)\n            return bool(child) and dfs(child, i + 1)\n        return dfs(self.trie, 0)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "WordDictionary.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 77,
    "signature": "def __init__(self):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self):\n        self.trie: dict[str, dict] = {}\n        self.END_MARKER = \"$\"",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "WordDictionary"
  },
  "WordDictionary.addWord": {
    "name": "addWord",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 81,
    "signature": "def addWord(self, word: str) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "",
    "code": "def addWord(self, word: str) -> None:\n        node = self.trie\n        for c in word:\n            node = node.setdefault(c, {})\n        node[self.END_MARKER] = True",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "WordDictionary"
  },
  "WordDictionary.search": {
    "name": "search",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 87,
    "signature": "def search(self, word: str) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "",
    "code": "def search(self, word: str) -> bool:\n        def dfs(node: dict, i: int) -> bool:\n            if i == len(word):\n                return self.END_MARKER in node\n            if (c := word[i]) == \".\":\n                return any(\n                    dfs(child, i + 1)\n                    for k, child in node.items()\n                    if k != self.END_MARKER\n                )\n            child = node.get(c)\n            return bool(child) and dfs(child, i + 1)\n        return dfs(self.trie, 0)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "WordDictionary"
  },
  "WordDictionary.search.dfs": {
    "name": "dfs",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 89,
    "signature": "def dfs(node: dict, i: int) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "Expressions:",
    "code": "def dfs(node: dict, i: int) -> bool:\n            if i == len(word):\n                return self.END_MARKER in node\n            if (c := word[i]) == \".\":\n                return any(\n                    dfs(child, i + 1)\n                    for k, child in node.items()\n                    if k != self.END_MARKER\n                )\n            child = node.get(c)\n            return bool(child) and dfs(child, i + 1)",
    "links": [],
    "variables": [],
    "expressions": [
      {
        "expression": "if k != self.END_MARKER",
        "description": "try every branch except the END_MARKER",
        "type": "expression"
      }
    ],
    "parent": "WordDictionary.search"
  },
  "TrieSolution": {
    "name": "TrieSolution",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 111,
    "signature": "class TrieSolution:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class TrieSolution:\n    def replaceWords(self, dictionary: list[str], sentence: str) -> str:\n        trie = {}\n        for word in dictionary:\n            node = trie\n            for c in word:\n                if \"$\" in node:\n                    break\n                node = node.setdefault(c, {})\n            node[\"$\"] = True\n        def search(word: str) -> str:\n            node = trie\n            for i, c in enumerate(word):\n                if \"$\" in node:\n                    return word[:i]\n                if c not in node:\n                    return word\n                node = node[c]\n            return word\n        return \" \".join(search(word) for word in sentence.split())\n    def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:\n        for word in words:\n            node = trie\n            for c in word:\n                node = node.setdefault(c, {})\n            node[\"$\"] = word\n        def dfs(i, j, parent):\n                return\n            node = parent[c]\n            if \"$\" in node:\n                res.append(node.pop(\"$\"))\n            board[i][j] = \"\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                dfs(x, y, node)\n            board[i][j] = c\n            if not node:\n                parent.pop(c)\n        m, n, res = len(board), len(board[0]), []\n        [dfs(i, j, trie) for i in range(m) for j in range(n) if board[i][j] in trie]\n        return res",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "TrieSolution.replaceWords": {
    "name": "replaceWords",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 112,
    "signature": "def replaceWords(self, dictionary: list[str], sentence: str) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "",
    "code": "def replaceWords(self, dictionary: list[str], sentence: str) -> str:\n        trie = {}\n        for word in dictionary:\n            node = trie\n            for c in word:\n                if \"$\" in node:\n                    break\n                node = node.setdefault(c, {})\n            node[\"$\"] = True\n        def search(word: str) -> str:\n            node = trie\n            for i, c in enumerate(word):\n                if \"$\" in node:\n                    return word[:i]\n                if c not in node:\n                    return word\n                node = node[c]\n            return word\n        return \" \".join(search(word) for word in sentence.split())",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TrieSolution"
  },
  "TrieSolution.replaceWords.search": {
    "name": "search",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 124,
    "signature": "def search(word: str) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "",
    "code": "def search(word: str) -> str:\n            node = trie\n            for i, c in enumerate(word):\n                if \"$\" in node:\n                    return word[:i]\n                if c not in node:\n                    return word\n                node = node[c]\n            return word",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TrieSolution.replaceWords"
  },
  "TrieSolution.findWords": {
    "name": "findWords",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 138,
    "signature": "def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:",
    "parameters": [],
    "return_type": "list[str]",
    "return_description": "",
    "description": "Returns all words from 'words' that can be formed in 'board' by sequentially adjacent cells.",
    "code": "def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:\n        for word in words:\n            node = trie\n            for c in word:\n                node = node.setdefault(c, {})\n            node[\"$\"] = word\n        def dfs(i, j, parent):\n                return\n            node = parent[c]\n            if \"$\" in node:\n                res.append(node.pop(\"$\"))\n            board[i][j] = \"\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                dfs(x, y, node)\n            board[i][j] = c\n            if not node:\n                parent.pop(c)\n        m, n, res = len(board), len(board[0]), []\n        [dfs(i, j, trie) for i in range(m) for j in range(n) if board[i][j] in trie]\n        return res",
    "links": [
      {
        "symbol": "i",
        "display": "[i]",
        "target": "i",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "j",
        "display": "[j]",
        "target": "j",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "i",
        "display": "[i]",
        "target": "i",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "j",
        "display": "[j]",
        "target": "j",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [
      {
        "name": "trie",
        "description": "Build trie from **words** list. Each end node gets a `$` key holding the word",
        "type": "variable"
      },
      {
        "name": "m",
        "description": "number of rows",
        "type": "variable"
      },
      {
        "name": "n",
        "description": "number of columns",
        "type": "variable"
      },
      {
        "name": "res",
        "description": "the list of found words",
        "type": "variable"
      }
    ],
    "expressions": [
      {
        "expression": "node = node.setdefault(c, {})",
        "description": "create a new node for the character if it doesn't exist",
        "type": "expression"
      },
      {
        "expression": "if \"$\" in node",
        "description": "if the current node is the end of a word",
        "type": "expression"
      },
      {
        "expression": "res.append(node.pop(\"$\"))",
        "description": "add the word to the result list and remove the \"$\" key to prevent duplicates",
        "type": "expression"
      },
      {
        "expression": "if not node",
        "description": "prune the trie to remove dead branches.",
        "type": "expression"
      },
      {
        "expression": "[dfs",
        "description": ".. Launch DFS from every cell that matches any trie root key",
        "type": "expression"
      },
      {
        "expression": "board[i][j] = \"#\"",
        "description": "Mark as visited",
        "type": "expression"
      },
      {
        "expression": "board[i][j] = c",
        "description": "Restore cell",
        "type": "expression"
      }
    ],
    "parent": "TrieSolution"
  },
  "TrieSolution.findWords.dfs": {
    "name": "dfs",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/trie.py",
    "line": 168,
    "signature": "def dfs(i, j, parent):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "DFS from board[i][j], following *parent* trie node.",
    "code": "def dfs(i, j, parent):\n                return\n            node = parent[c]\n            if \"$\" in node:\n                res.append(node.pop(\"$\"))\n            board[i][j] = \"\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                dfs(x, y, node)\n            board[i][j] = c\n            if not node:\n                parent.pop(c)",
    "links": [
      {
        "symbol": "i",
        "display": "[i]",
        "target": "i",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "j",
        "display": "[j]",
        "target": "j",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": [],
    "parent": "TrieSolution.findWords"
  },
  "maxSubArrayLen": {
    "name": "maxSubArrayLen",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 3,
    "signature": "def maxSubArrayLen(segments: list[int], k: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "Target sum.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The length of the longest subarray with sum == k.",
    "description": "Find the maximum length of a subarray that sums to exactly k.",
    "code": "def maxSubArrayLen(segments: list[int], k: int) -> int:\n    marker_idx = {0: -1}\n    prefix_sum = max_length = 0\n    for i, segment in enumerate(segments):\n        prefix_sum += segment\n        if (target_marker := prefix_sum - k) in marker_idx:\n            max_length = max(max_length, i - marker_idx[target_marker])\n        if prefix_sum not in marker_idx:\n            marker_idx[prefix_sum] = i\n    return max_length",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "subarraySum": {
    "name": "subarraySum",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 30,
    "signature": "def subarraySum(segments: list[int], k: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "Target sum.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The count of subarrays with sum == k.",
    "description": "Count the number of subarrays that sum to exactly k.",
    "code": "def subarraySum(segments: list[int], k: int) -> int:\n    marker_frequency = defaultdict(int, {0: 1})\n    prefix_sum = count = 0\n    for segment in segments:\n        prefix_sum += segment\n        count += marker_frequency[prefix_sum - k]\n        marker_frequency[prefix_sum] += 1\n    return count",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "findMaxLength": {
    "name": "findMaxLength",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 52,
    "signature": "def findMaxLength(segments: list[int]) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers (positive for forward, negative/zero for backward).",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The length of the longest balanced subarray.",
    "description": "Find the maximum length of a contiguous subarray with an equal number of positive and negative values.",
    "code": "def findMaxLength(segments: list[int]) -> int:\n    return maxSubArrayLen(normalized_segments, 0)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "checkSubarraySum": {
    "name": "checkSubarraySum",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 65,
    "signature": "def checkSubarraySum(segments: list[int], k: int) -> bool:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "The divisor.",
        "default": null
      }
    ],
    "return_type": "bool",
    "return_description": "True if such a subarray exists, False otherwise.",
    "description": "Check if the array contains a subarray of at least length 2 whose sum is a multiple of k.",
    "code": "def checkSubarraySum(segments: list[int], k: int) -> bool:\n    remainder_idx = {0: -1}\n    prefix_remainder = 0\n    for i, segment in enumerate(segments):\n        prefix_remainder = (prefix_remainder + segment) % k\n        if prefix_remainder in remainder_idx:\n            if i - remainder_idx[prefix_remainder] > 1:\n                return True\n        else:\n            remainder_idx[prefix_remainder] = i\n    return False",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "subarraysDivByK": {
    "name": "subarraysDivByK",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 89,
    "signature": "def subarraysDivByK(segments: list[int], k: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "The divisor.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The count of subarrays with sum divisible by k.",
    "description": "Count the number of subarrays whose sum is divisible by k.",
    "code": "def subarraysDivByK(segments: list[int], k: int) -> int:\n    remainder_frequency = defaultdict(int, {0: 1})\n    prefix_remainder = count = 0\n    for segment in segments:\n        prefix_remainder = (prefix_remainder + segment) % k\n        count += remainder_frequency[prefix_remainder]\n        remainder_frequency[prefix_remainder] += 1\n    return count",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "minSubarray": {
    "name": "minSubarray",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 110,
    "signature": "def minSubarray(segments: list[int], p: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "p",
        "type": "int",
        "description": "The divisor.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The length of the shortest subarray to remove, or -1 if not possible.",
    "description": "Find the length of the shortest subarray to remove so that the sum of the remaining elements is divisible by p.",
    "code": "def minSubarray(segments: list[int], p: int) -> int:\n    total_remainder = sum(segments) % p\n    if total_remainder == 0:\n        return 0\n    remainder_idx = {0: -1}\n    prefix_remainder, min_length = 0, len(segments)\n    for i, segment in enumerate(segments):\n        prefix_remainder = (prefix_remainder + segment) % p\n        need = (prefix_remainder - total_remainder + p) % p\n        if need in remainder_idx:\n            min_length = min(min_length, i - remainder_idx[need])\n        remainder_idx[prefix_remainder] = i\n    return min_length if min_length < len(segments) else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "getModifiedArray": {
    "name": "getModifiedArray",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 138,
    "signature": "def getModifiedArray(length: int, updates: list[list[int]]) -> list[int]:",
    "parameters": [
      {
        "name": "length",
        "type": "int",
        "description": "The number of days in the itinerary.",
        "default": null
      },
      {
        "name": "updates",
        "type": "list[list[int]]",
        "description": "List of [start_day, end_day, change_in_km] updates.",
        "default": null
      }
    ],
    "return_type": "list[int]",
    "return_description": "The final daily travel plan after all updates.",
    "description": "Apply a list of range updates to an array and return the modified array.",
    "code": "def getModifiedArray(length: int, updates: list[list[int]]) -> list[int]:\n    delta = [0] * (length + 1)\n    for start_day, end_day, change_in_km in updates:\n        delta[start_day] += change_in_km\n        delta[end_day + 1] -= change_in_km\n    prefix_sum = 0\n    return [prefix_sum := prefix_sum + change for change in delta[:-1]]",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "numberOfArrays": {
    "name": "numberOfArrays",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 159,
    "signature": "def numberOfArrays(differences: list[int], lower: int, upper: int) -> int:",
    "parameters": [
      {
        "name": "differences",
        "type": "list[int]",
        "description": "List of daily changes (trip segments).",
        "default": null
      },
      {
        "name": "lower",
        "type": "int",
        "description": "Lower bound for any marker on the highway.",
        "default": null
      },
      {
        "name": "upper",
        "type": "int",
        "description": "Upper bound for any marker on the highway.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The number of valid starting values.",
    "description": "Count the number of valid starting values for a hidden sequence given the differences and bounds.",
    "code": "def numberOfArrays(differences: list[int], lower: int, upper: int) -> int:\n    prefix_sum = min_marker = max_marker = 0\n    for diff in differences:\n        prefix_sum += diff\n        min_marker = min(min_marker, prefix_sum)\n        max_marker = max(max_marker, prefix_sum)\n    return max(0, (upper - max_marker) - (lower - min_marker) + 1)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "JumpGameIV": {
    "name": "JumpGameIV",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/games/JumpGameIV.py",
    "line": 4,
    "signature": "class JumpGameIV:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class JumpGameIV:\n    def minJumps(self, nums: list[int]) -> int:\n        if (n := len(nums)) < 2:\n            return 0\n        indicies = defaultdict(list)\n        for i, num in enumerate(nums):\n            indicies[num].append(i)\n        begin, end = {0}, {n - 1}\n        seen = {0, n - 1}\n        steps = 0\n        while begin:\n            if begin & end:\n                return steps\n            if len(begin) > len(end):\n                begin, end = end, begin\n            next_level = set()\n            for i in begin:\n                for j in indicies[nums[i]]:\n                    if j in end:\n                        return steps + 1\n                    if j not in seen:\n                        seen.add(j)\n                        next_level.add(j)\n                indicies[nums[i]].clear()  \n                for j in (i - 1, i + 1):\n                    if j in end:\n                        return steps + 1\n                    if 0 <= j < n and j not in seen:\n                        seen.add(j)\n                        next_level.add(j)\n            begin = next_level\n            steps += 1\n        return steps",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "JumpGameIV.minJumps": {
    "name": "minJumps",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/games/JumpGameIV.py",
    "line": 5,
    "signature": "def minJumps(self, nums: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def minJumps(self, nums: list[int]) -> int:\n        if (n := len(nums)) < 2:\n            return 0\n        indicies = defaultdict(list)\n        for i, num in enumerate(nums):\n            indicies[num].append(i)\n        begin, end = {0}, {n - 1}\n        seen = {0, n - 1}\n        steps = 0\n        while begin:\n            if begin & end:\n                return steps\n            if len(begin) > len(end):\n                begin, end = end, begin\n            next_level = set()\n            for i in begin:\n                for j in indicies[nums[i]]:\n                    if j in end:\n                        return steps + 1\n                    if j not in seen:\n                        seen.add(j)\n                        next_level.add(j)\n                indicies[nums[i]].clear()  \n                for j in (i - 1, i + 1):\n                    if j in end:\n                        return steps + 1\n                    if 0 <= j < n and j not in seen:\n                        seen.add(j)\n                        next_level.add(j)\n            begin = next_level\n            steps += 1\n        return steps",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "JumpGameIV"
  },
  "StoneGameIII": {
    "name": "StoneGameIII",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/games/stone_3.py",
    "line": 1,
    "signature": "class StoneGameIII:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class StoneGameIII:\n    def stoneGameIII(self, stoneValue: list[int]) -> str:\n        memo, n = {}, len(stoneValue)\n        def dp(i):\n            if i >= n:\n                return 0\n            if i not in memo:\n                memo[i] = max(\n                    sum(stoneValue[i : i + k]) - dp(i + k) for k in range(1, 4)\n                )\n            return memo[i]\n        return \"Alice\" if dp(0) > 0 else \"Bob\" if dp(0) < 0 else \"Tie\"",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "StoneGameIII.stoneGameIII": {
    "name": "stoneGameIII",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/games/stone_3.py",
    "line": 3,
    "signature": "def stoneGameIII(self, stoneValue: list[int]) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "",
    "code": "def stoneGameIII(self, stoneValue: list[int]) -> str:\n        memo, n = {}, len(stoneValue)\n        def dp(i):\n            if i >= n:\n                return 0\n            if i not in memo:\n                memo[i] = max(\n                    sum(stoneValue[i : i + k]) - dp(i + k) for k in range(1, 4)\n                )\n            return memo[i]\n        return \"Alice\" if dp(0) > 0 else \"Bob\" if dp(0) < 0 else \"Tie\"",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "StoneGameIII"
  },
  "StoneGameIII.stoneGameIII.dp": {
    "name": "dp",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/games/stone_3.py",
    "line": 7,
    "signature": "def dp(i):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def dp(i):\n            if i >= n:\n                return 0\n            if i not in memo:\n                memo[i] = max(\n                    sum(stoneValue[i : i + k]) - dp(i + k) for k in range(1, 4)\n                )\n            return memo[i]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "StoneGameIII.stoneGameIII"
  },
  "SudokuSolver": {
    "name": "SudokuSolver",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/games/sudoku_solver.py",
    "line": 1,
    "signature": "class SudokuSolver:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class SudokuSolver:\n    def solveSudoku(self, board: list[list[str]]) -> None:\n        D = set(\"123456789\")\n        rows = [set() for _ in range(9)]; cols = [set() for _ in range(9)]; boxes = [set() for _ in range(9)]\n        empties: list[tuple[int,int]] = []\n        for i in range(9):\n            for j in range(9):\n                v = board[i][j]\n                if v == '.': empties.append((i, j))\n                else: \n                    rows[i].add(v); cols[j].add(v); boxes[i//3*3 + j//3].add(v)\n        def dfs() -> bool:\n            if not empties: return True\n            k, (i, j), cand = min(\n                ((t, (i, j), D - (rows[i] | cols[j] | boxes[i//3*3 + j//3])) for t, (i, j) in enumerate(empties)),\n                key=lambda x: len(x[2])\n            )\n            empties.pop(k)\n            for d in cand:\n                board[i][j] = d; rows[i].add(d); cols[j].add(d); boxes[(b:=i//3*3 + j//3)].add(d)\n                if dfs(): return True\n                rows[i].remove(d); cols[j].remove(d); boxes[b].remove(d)\n            board[i][j] = '.'; empties.insert(k, (i, j))\n            return False\n        dfs()",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "SudokuSolver.solveSudoku": {
    "name": "solveSudoku",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/games/sudoku_solver.py",
    "line": 2,
    "signature": "def solveSudoku(self, board: list[list[str]]) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "Topics:",
    "code": "def solveSudoku(self, board: list[list[str]]) -> None:\n        D = set(\"123456789\")\n        rows = [set() for _ in range(9)]; cols = [set() for _ in range(9)]; boxes = [set() for _ in range(9)]\n        empties: list[tuple[int,int]] = []\n        for i in range(9):\n            for j in range(9):\n                v = board[i][j]\n                if v == '.': empties.append((i, j))\n                else: \n                    rows[i].add(v); cols[j].add(v); boxes[i//3*3 + j//3].add(v)\n        def dfs() -> bool:\n            if not empties: return True\n            k, (i, j), cand = min(\n                ((t, (i, j), D - (rows[i] | cols[j] | boxes[i//3*3 + j//3])) for t, (i, j) in enumerate(empties)),\n                key=lambda x: len(x[2])\n            )\n            empties.pop(k)\n            for d in cand:\n                board[i][j] = d; rows[i].add(d); cols[j].add(d); boxes[(b:=i//3*3 + j//3)].add(d)\n                if dfs(): return True\n                rows[i].remove(d); cols[j].remove(d); boxes[b].remove(d)\n            board[i][j] = '.'; empties.insert(k, (i, j))\n            return False\n        dfs()",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "SudokuSolver"
  },
  "SudokuSolver.solveSudoku.dfs": {
    "name": "dfs",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/games/sudoku_solver.py",
    "line": 21,
    "signature": "def dfs() -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "",
    "code": "def dfs() -> bool:\n            if not empties: return True\n            k, (i, j), cand = min(\n                ((t, (i, j), D - (rows[i] | cols[j] | boxes[i//3*3 + j//3])) for t, (i, j) in enumerate(empties)),\n                key=lambda x: len(x[2])\n            )\n            empties.pop(k)\n            for d in cand:\n                board[i][j] = d; rows[i].add(d); cols[j].add(d); boxes[(b:=i//3*3 + j//3)].add(d)\n                if dfs(): return True\n                rows[i].remove(d); cols[j].remove(d); boxes[b].remove(d)\n            board[i][j] = '.'; empties.insert(k, (i, j))\n            return False",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "SudokuSolver.solveSudoku"
  },
  "Sudoku": {
    "name": "Sudoku",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/games/valid_sudoku.py",
    "line": 1,
    "signature": "class Sudoku:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class Sudoku:\n    def isValidSudoku(self, board: list[list[str]]) -> bool:\n        row = [set() for _ in range(9)]\n        col = [set() for _ in range(9)]\n        cube = [set() for _ in range(9)]\n        for r in range(9):\n            for c in range(9):\n                if (num := board[r][c]) != \".\": \n                    if (\n                        num in col[c]\n                        or num in row[r]\n                        or num in cube[(cube_index := (r // 3) * 3 + (c // 3))]\n                    ):\n                        return False\n                    col[c].add(num)\n                    row[r].add(num)\n                    cube[cube_index].add(num)\n        return True",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Sudoku.isValidSudoku": {
    "name": "isValidSudoku",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/games/valid_sudoku.py",
    "line": 2,
    "signature": "def isValidSudoku(self, board: list[list[str]]) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "Expressions:",
    "code": "def isValidSudoku(self, board: list[list[str]]) -> bool:\n        row = [set() for _ in range(9)]\n        col = [set() for _ in range(9)]\n        cube = [set() for _ in range(9)]\n        for r in range(9):\n            for c in range(9):\n                if (num := board[r][c]) != \".\": \n                    if (\n                        num in col[c]\n                        or num in row[r]\n                        or num in cube[(cube_index := (r // 3) * 3 + (c // 3))]\n                    ):\n                        return False\n                    col[c].add(num)\n                    row[r].add(num)\n                    cube[cube_index].add(num)\n        return True",
    "links": [
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": [
      {
        "expression": "if (",
        "description": "Check for duplicates",
        "type": "expression"
      },
      {
        "expression": "if (num := board[r][c]) != \".\"",
        "description": "Skip empty cells",
        "type": "expression"
      },
      {
        "expression": "cube_index := (r // 3) * 3 + (c // 3)",
        "description": "The formula works by treating the 9×9 board as a 3×3 grid of 3×3 boxes:                - `r//3` gives which box-row (0,1,2) you’re in; `c//3` gives which box-column (0,1,2).                - Multiplying the box-row by 3 and adding the box-column yields a unique index 0–8 for each 3×3 cube.",
        "type": "expression"
      }
    ],
    "parent": "Sudoku"
  }
}