{
  "manhattan_distance": {
    "name": "manhattan_distance",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/a-star.py",
    "line": 7,
    "signature": "def manhattan_distance(a: tuple[int, int], b: tuple[int, int]) -> int:",
    "parameters": [
      {
        "name": "a",
        "type": "tuple[(int, int)]",
        "description": "(row, col) of the first point.",
        "default": null
      },
      {
        "name": "b",
        "type": "tuple[(int, int)]",
        "description": "(row, col) of the second point.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The Manhattan distance |a.row - b.row| + |a.col - b.col|.",
    "description": "Manhattan distance between two grid points $(r,c)$ and the goal $(r^*,c^*)$ is $h = |r^* - r| + |c^* - c|$. It measures the minimum number of orthogonal moves (up/down/left/right) ignoring obstacles, and is both admissible and consistent on a 4‑connected grid.",
    "code": "def manhattan_distance(a: tuple[int, int], b: tuple[int, int]) -> int:\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "aStarShortestPath": {
    "name": "aStarShortestPath",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/a-star.py",
    "line": 24,
    "signature": "def aStarShortestPath(grid: list[list[int]], k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Variables:",
    "code": "def aStarShortestPath(grid: list[list[int]], k: int) -> int:\n    rows, cols = len(grid), len(grid[0])\n    def h(r: int, c: int) -> int:\n        return manhattan_distance((r, c), (rows - 1, cols - 1))\n    if k >= (md:= h(0, 0)) - 1:\n        return md\n    pq = [(md, 0, 0, 0, k)]\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n    while pq:\n        _, steps, r, c, remaining_k = heapq.heappop(pq)\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        if remaining_k < max_k[r][c]:\n            continue\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if 0 <= (nr:= r + dr) < rows and 0 <= (nc:= c + dc) < cols:\n                if (new_remaining_k := remaining_k - grid[nr][nc] ) > max_k[nr][nc]:\n                    max_k[nr][nc] = new_remaining_k\n                    heapq.heappush(pq, ((steps + 1) + h(nr, nc), steps + 1, nr, nc, new_remaining_k))\n    return -1",
    "links": [
      {
        "symbol": "nr",
        "display": "[nr]",
        "target": "nr",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "nc",
        "display": "[nc]",
        "target": "nc",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "nr",
        "display": "[nr]",
        "target": "nr",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "nc",
        "display": "[nc]",
        "target": "nc",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "nr",
        "display": "[nr]",
        "target": "nr",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "nc",
        "display": "[nc]",
        "target": "nc",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [
      {
        "name": "pq",
        "description": "(f_cost, steps, r, c, remaining_k)",
        "type": "variable"
      }
    ],
    "expressions": [
      {
        "expression": "new_remaining_k",
        "description": "= remaining_k - grid[nr][nc], how many obstacle eliminations you will have left **after** moving to the next cell , if the cell is empty grid[nr][nc] is 0, if the cell is an obstacle grid[nr][nc] is 1.",
        "type": "expression"
      },
      {
        "expression": "if remaining_k < max_k[r][c]",
        "description": "Handle items that are already outdated by the time they are popped.",
        "type": "expression"
      }
    ]
  },
  "aStarShortestPath.h": {
    "name": "h",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/a-star.py",
    "line": 37,
    "signature": "def h(r: int, c: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def h(r: int, c: int) -> int:\n        return manhattan_distance((r, c), (rows - 1, cols - 1))",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "aStarShortestPath"
  },
  "bellman_ford_classic": {
    "name": "bellman_ford_classic",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bellman-ford.py",
    "line": 3,
    "signature": "def bellman_ford_classic(vertices:list[str], edges:list[tuple[str, str, float]], source:str)->dict[str, float]:",
    "parameters": [],
    "return_type": "dict[(str, float)]",
    "return_description": "",
    "description": "Classic Bellman-Ford with early exit.",
    "code": "def bellman_ford_classic(vertices:list[str], edges:list[tuple[str, str, float]], source:str)->dict[str, float]:\n    d = [float(\"inf\")] * (V := len(vertices))\n    d[source] = 0\n    for _ in range(V - 1):\n        updated = False\n        for u, v, w in edges:\n            if d[u] + w < d[v]:\n                d[v] = d[u] + w\n                updated = True\n        if not updated:\n            return d    \n    for u, v, w in edges:\n        if d[u] + w < d[v]:\n            raise Exception(\"Negative-weight cycle\")\n    return d",
    "links": [
      {
        "symbol": "v",
        "display": "[v]",
        "target": "v",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": [
      {
        "expression": "range(V - 1)",
        "description": "relax up to V-1 times, but return early if no update",
        "type": "expression"
      },
      {
        "expression": "if not updated",
        "description": "distances have stabilized—no negative cycles reachable",
        "type": "expression"
      }
    ]
  },
  "bellman_ford_layered_dag": {
    "name": "bellman_ford_layered_dag",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bellman-ford.py",
    "line": 34,
    "signature": "def bellman_ford_layered_dag(vertices: list[str], edges: list[tuple[str, str, float]], source: str) -> dict[str, float]:",
    "parameters": [
      {
        "name": "vertices",
        "type": "list[str]",
        "description": "All hashable vertex identifiers.",
        "default": null
      },
      {
        "name": "edges",
        "type": "list[tuple[(str, str, float)]]",
        "description": "Iterable of (u, v, weight) tuples.",
        "default": null
      },
      {
        "name": "source",
        "type": "str",
        "description": "Starting vertex.",
        "default": null
      }
    ],
    "return_type": "dict[(str, float)]",
    "return_description": "A dict mapping each vertex to its true shortest-path cost from `source`,",
    "description": "Compute k-edge shortest-path distances and detect negative cycles via layered relaxation.",
    "code": "def bellman_ford_layered_dag(vertices: list[str], edges: list[tuple[str, str, float]], source: str) -> dict[str, float]:\n    d = {v: float(\"inf\") for v in vertices}\n    d[source], V = 0, len(vertices)\n    for k in range(V):  \n        d_k = {**d}  \n        for u, v, w in edges:\n            if d[u] + w < d_k[v]:\n                d_k[v] = d[u] + w\n        d = d_k  \n    witnesses = {v for u, v, w in edges if d[u] + w < d[v]}\n    if not witnesses:\n        return d\n    adj = defaultdict(list)\n    for u, v, _ in edges:\n        adj[u].append(v)\n    stack = list(witnesses)\n    reachable = set(witnesses)\n    while stack:\n        u = stack.pop()\n        d[u] = float(\"-inf\")\n        for v in adj[u]:\n            if v not in reachable:\n                reachable.add(v)\n                stack.append(v)\n    return d",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "findCheapestPrice": {
    "name": "findCheapestPrice",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bellman-ford.py",
    "line": 92,
    "signature": "def findCheapestPrice(n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def findCheapestPrice(n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int:\n    d = [float(\"inf\")] * n\n    d[src] = 0\n    for _ in range(k + 1):\n        tmp = d[:]\n        for u, v, w in flights:\n            if d[u] + w < tmp[v]:\n                tmp[v] = d[u] + w\n        d = tmp\n    return d[dst] if d[dst] < float(\"inf\") else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "maxProbability": {
    "name": "maxProbability",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bellman-ford.py",
    "line": 107,
    "signature": "def maxProbability(n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float:",
    "parameters": [
      {
        "name": "n",
        "type": "int",
        "description": "number of nodes",
        "default": null
      },
      {
        "name": "edges",
        "type": "list[list[int]]",
        "description": "edges[i] = [u, v] is an undirected edge connecting the nodes u and v with a probability of success of traversing that edge succProb[i].",
        "default": null
      },
      {
        "name": "succProb",
        "type": "list[float]",
        "description": "list of probabilities, e.g. [0.5,0.5,0.2],",
        "default": null
      }
    ],
    "return_type": "float",
    "return_description": "",
    "description": "Bellman-Ford variant to maximize product of probabilities.",
    "code": "def maxProbability(n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float:\n    prob[start] = 1.0  \n    for _ in range(n - 1):  \n        updated = False\n        for (u, v), p in zip(edges, succProb):\n            if prob[u] * p > prob[v]:  \n                prob[v] = prob[u] * p\n                updated = True\n            if prob[v] * p > prob[u]:  \n                prob[u] = prob[v] * p\n                updated = True\n        if not updated:\n            break  \n    return prob[end]",
    "links": [
      {
        "symbol": "i",
        "display": "[i]",
        "target": "i",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "i",
        "display": "[i]",
        "target": "i",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": []
  },
  "dijkstra": {
    "name": "dijkstra",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 4,
    "signature": "def dijkstra(graph: dict[str, dict[str, int]], s: str):",
    "parameters": [
      {
        "name": "graph",
        "type": "dict[(str, dict[(str, int)])]",
        "description": "A dictionary representing the graph.",
        "default": null
      },
      {
        "name": "s",
        "type": "str",
        "description": "The source vertex.",
        "default": null
      }
    ],
    "return_type": "",
    "return_description": "",
    "description": "Dijkstra's algorithm for finding the shortest path in a non-negative weighted graph.",
    "code": "def dijkstra(graph: dict[str, dict[str, int]], s: str):\n    d = {v: float('inf') for v in graph} | {s: 0}\n    p = {v: None for v in graph}\n    pq = [(0, s)]\n    while pq:\n        d_u, u = heapq.heappop(pq)\n        if d_u > d[u]:\n            continue\n        for v ,w in graph[u]:\n            if (weight := d_u + w) < d[v]:\n                d[v], p[v] = weight, u\n                heapq.heappush(pq, (weight, v))\n    return d, p",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "networkDelayTime2": {
    "name": "networkDelayTime2",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 34,
    "signature": "def networkDelayTime2(times: list[list[int]], n: int, k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def networkDelayTime2(times: list[list[int]], n: int, k: int) -> int:\n    graph = {v: [] for v in range(1, n + 1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n    d = {v: float(\"inf\") for v in graph} | {k: 0}\n    pq = [(0, k)]\n    while pq:\n        d_u, u = heapq.heappop(pq)\n        if d_u > d[u]:\n            continue\n        for v, w in graph[u]:\n            if (weight := d_u + w) < d[v]:\n                d[v] = weight\n                heapq.heappush(pq, (weight, v))\n    return m if (m := max(d.values())) != float(\"inf\") else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "networkDelayTime": {
    "name": "networkDelayTime",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 57,
    "signature": "def networkDelayTime(times: list[list[int]], n: int, k: int) -> int:",
    "parameters": [
      {
        "name": "times",
        "type": "list[list[int]]",
        "description": "list of lists of integers representing the edges and their weights",
        "default": null
      },
      {
        "name": "n",
        "type": "int",
        "description": "number of nodes",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "starting node",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum time for a signal starting at node `k` to reach *all* nodes or -1 if impossible",
    "description": "Given `n` nodes labeled `1` through `n` and directed travel times between them,",
    "code": "def networkDelayTime(times: list[list[int]], n: int, k: int) -> int:\n    adj = defaultdict(list)\n    for u, v, w in times:\n        adj[u].append((v, w))\n    pq, finalized, time = [(0, k)], set(), 0\n    while pq:\n        t, node = heapq.heappop(pq)\n        if node in finalized:\n            continue\n        finalized.add(node)\n        time = t\n        for neighbor, travel_time in adj[node]:\n            if neighbor not in finalized:\n                heapq.heappush(pq, (time + travel_time, neighbor))\n    return time if len(finalized) == n else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "minimumEffortPath": {
    "name": "minimumEffortPath",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 91,
    "signature": "def minimumEffortPath(heights: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "heights",
        "type": "list[list[int]]",
        "description": "2D list of integers representing the heights of the cells",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum effort to reach the bottom-right cell",
    "description": "Find a path from the top-left to the bottom-right of a height grid that minimizes the \"effort\".",
    "code": "def minimumEffortPath(heights: list[list[int]]) -> int:\n    R, C = len(heights), len(heights[0])\n    pq, resolved = [(0, 0, 0)], set()\n    while pq:\n        effort, r, c = heapq.heappop(pq)\n        if (r, c) in resolved: continue\n        if (r, c) == (R - 1, C - 1): return effort\n        resolved.add((r, c))\n        for nr, nc in [(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)]:\n            if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in resolved:\n                neighbor_effort = max(effort, abs(heights[nr][nc] - heights[r][c]))\n                heapq.heappush(pq, (neighbor_effort, nr, nc))",
    "links": [],
    "variables": [
      {
        "name": "pq",
        "description": "Priority queue stores (max_effort_on_path, r, c)",
        "type": "variable"
      },
      {
        "name": "resolved",
        "description": "set to store the positions that have been resolved",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "swimInWater": {
    "name": "swimInWater",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 120,
    "signature": "def swimInWater(grid: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[int]]",
        "description": "2D list of integers representing the elevations of the cells",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum time to travel from `(0, 0)` to `(N-1, N-1)`",
    "description": "You are given an `N x N` grid of elevations. Find the minimum \"time\" `t` to travel from `(0, 0)` to `(N-1, N-1)`.",
    "code": "def swimInWater(grid: list[list[int]]) -> int:\n    n=len(grid)\n    pq, resolved = [(grid[0][0], 0, 0)], set()\n    while pq:\n        time, r, c = heapq.heappop(pq)\n        if (r, c) in resolved:continue\n        if (r, c) == (n - 1, n - 1):return time\n        resolved.add((r, c))\n        for nr, nc in [(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)]:\n            if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in resolved:\n                bottleneck_time = max(time, grid[nr][nc])\n                heapq.heappush(pq, (bottleneck_time, nr, nc))",
    "links": [],
    "variables": [
      {
        "name": "pq",
        "description": "Priority queue stores (max_elevation_on_path, r, c)",
        "type": "variable"
      },
      {
        "name": "resolved",
        "description": "set to store the cells for which we have found the minimum time required to reach them",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "findCheapestPriceDijkstra": {
    "name": "findCheapestPriceDijkstra",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 152,
    "signature": "def findCheapestPriceDijkstra( flights: list[list[int]], src: int, dst: int, k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Variables:",
    "code": "def findCheapestPriceDijkstra( flights: list[list[int]], src: int, dst: int, k: int) -> int:\n    graph = defaultdict(list)\n    for u, v, price in flights:\n        graph[u].append((v, price))\n    pq, min_stops = [(0, src, 0)], {}\n    while pq:\n        cost, city, stops = heapq.heappop(pq)\n        if stops > min_stops.get(city, float(\"inf\")): continue\n        if city == dst: return cost\n        min_stops[city] = stops\n        if stops <= k:\n            for neighbor, price in graph[city]:\n                heapq.heappush(pq, (cost + price, neighbor, stops + 1))\n    return -1",
    "links": [],
    "variables": [
      {
        "name": "pq",
        "description": "Priority queue to store the state (cost, city, stops_taken)",
        "type": "variable"
      },
      {
        "name": "min_stops",
        "description": "Tracks the minimum stops to reach each city",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "dijkstraShortestPath": {
    "name": "dijkstraShortestPath",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/dijkstra.py",
    "line": 183,
    "signature": "def dijkstraShortestPath(grid: list[list[int]], k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Finds the shortest path using Dijkstra's algorithm.",
    "code": "def dijkstraShortestPath(grid: list[list[int]], k: int) -> int:\n    rows, cols = len(grid), len(grid[0])\n    if k >= rows + cols - 3:\n        return rows + cols - 2\n    pq = [(0, 0, 0, k)]\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n    while pq:\n        steps, r, c, k_rem = heapq.heappop(pq)\n        if (r, c) == (rows - 1, cols - 1):\n            return steps\n        if k_rem < max_k[r][c]:\n            continue\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if 0 <= (nr:= r + dr) < rows and 0 <= (nc:= c + dc) < cols:\n                if (new_k:= k_rem - grid[nr][nc]) > max_k[nr][nc]:\n                    max_k[nr][nc] = new_k\n                    heapq.heappush(pq, (steps + 1, nr, nc, new_k))\n    return -1",
    "links": [
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [
      {
        "name": "pq",
        "description": "(g_cost, r, c, k_rem), The priority uses g_cost (steps) itself. No heuristic is used.",
        "type": "variable"
      },
      {
        "name": "steps",
        "description": "The number of steps taken so far (g_cost)",
        "type": "variable"
      },
      {
        "name": "max_k",
        "description": "max_k[r][c] stores the max eliminations we have at cell (r,c)",
        "type": "variable"
      }
    ],
    "expressions": [
      {
        "expression": "heapq.heappush(pq, (steps + 1, nr, nc, new_k))",
        "description": "The priority is simply the new step count.No heuristic is added, which is the only difference from the A* implementation.",
        "type": "expression"
      },
      {
        "expression": "heapq.heappop(pq)",
        "description": "Pop the path with the lowest g_cost (steps) so far",
        "type": "expression"
      },
      {
        "expression": "k_rem < max_k[r][c]",
        "description": "Prune paths that are suboptimal for a given cell",
        "type": "expression"
      }
    ]
  },
  "searchInsert": {
    "name": "searchInsert",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 3,
    "signature": "def searchInsert(nums: list[int], target: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def searchInsert(nums: list[int], target: int) -> int:\n    return bisect_left(nums, target)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "simple_bisect_left": {
    "name": "simple_bisect_left",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 7,
    "signature": "def simple_bisect_left(a:list[int], x:int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Return the index where to insert item x in list a, assuming a is sorted.",
    "code": "def simple_bisect_left(a:list[int], x:int):\n    l, r = 0, len(a)\n    while l < r:\n        mid = (l + r) // 2\n        if x > a[mid]:\n            l = mid + 1\n        else:\n            r = mid\n    return l",
    "links": [
      {
        "symbol": "mid",
        "display": "[mid]",
        "target": "mid",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "mid",
        "display": "[mid]",
        "target": "mid",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": [
      {
        "expression": "l = mid + 1",
        "description": "If the target `x` is greater than the middle element `a[mid]`, the insertion point must be to the right of `mid`.",
        "type": "expression"
      },
      {
        "expression": "r = mid",
        "description": "If the target `x` is less than or equal to `a[mid]`, then `mid` is a potential answer, so we search the left half including `mid`.",
        "type": "expression"
      }
    ]
  },
  "simple_bisect_right": {
    "name": "simple_bisect_right",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 26,
    "signature": "def simple_bisect_right(a, x):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Return the index where to insert item x in list a, assuming a is sorted.",
    "code": "def simple_bisect_right(a, x):\n    l, r = 0, len(a)\n    while l < r:\n        mid = (l + r) // 2\n        if x < a[mid]:\n            r = mid\n        else: \n            l = mid + 1 \n    return l",
    "links": [],
    "variables": [],
    "expressions": [
      {
        "expression": "r = mid",
        "description": "If the x is less than the middle element, the insertion point could be `mid` or to its left. Shrink search space to the left half.",
        "type": "expression"
      },
      {
        "expression": "l = mid + 1",
        "description": "If the x is >= middle element, the insertion point must be to the right of `mid`.",
        "type": "expression"
      }
    ]
  },
  "searchRange": {
    "name": "searchRange",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 48,
    "signature": "def searchRange(nums: list[int], target: int) -> list[int]:",
    "parameters": [],
    "return_type": "list[int]",
    "return_description": "",
    "description": "",
    "code": "def searchRange(nums: list[int], target: int) -> list[int]:\n    start = bisect_left(nums, target)\n    if start < len(nums) and nums[start] == target:\n        return start, bisect_right(nums, target) - 1\n    return -1, -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "findMin": {
    "name": "findMin",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 55,
    "signature": "def findMin(nums: list[int]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Finds the minimum element in a rotated sorted array using binary search.",
    "code": "def findMin(nums: list[int]) -> int:\n    l, r = 0, len(nums) - 1\n    while l < r:\n        mid = (l + r) // 2\n        if nums[mid] < nums[r]:\n            r = mid\n        else:\n            l = mid + 1 \n    return nums[l]",
    "links": [
      {
        "symbol": "mid",
        "display": "[mid]",
        "target": "mid",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": [
      {
        "expression": "r = mid",
        "description": "If nums[mid] is less than nums[r], the minimum is in the left half (inclusive of mid).",
        "type": "expression"
      },
      {
        "expression": "l = mid + 1",
        "description": "the smallest is on the right",
        "type": "expression"
      }
    ]
  },
  "minEatingSpeed": {
    "name": "minEatingSpeed",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 76,
    "signature": "def minEatingSpeed(piles: list[int], h: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def minEatingSpeed(piles: list[int], h: int) -> int:\n    def hours(k:int) -> int:\n    l, r = 1, max(piles)\n    while l < r:\n        k = (l + r) // 2\n        if hours(k) <= h:\n            r = k\n        else:\n            l = k + 1\n    return l",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "minEatingSpeed.hours": {
    "name": "hours",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 78,
    "signature": "def hours(k:int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "computes total hours needed at speed k",
    "code": "def hours(k:int) -> int:",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "minEatingSpeed"
  },
  "shipWithinDays": {
    "name": "shipWithinDays",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 98,
    "signature": "def shipWithinDays(weights: list[int], days: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def shipWithinDays(weights: list[int], days: int) -> int:\n    def daysNeeded(capacity: int) -> int:\n        d, load = 1, 0\n        for w in weights:\n            if load + w <= capacity:\n                load += w\n            else:\n                d += 1\n                load = w\n        return d\n    l, r = max(weights), sum(weights)\n    while l < r:\n        capacity = (l + r) // 2\n        if daysNeeded(capacity) <= days:\n            r = capacity\n        else:\n            l = capacity + 1\n    return l",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "shipWithinDays.daysNeeded": {
    "name": "daysNeeded",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/binary_search.py",
    "line": 100,
    "signature": "def daysNeeded(capacity: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def daysNeeded(capacity: int) -> int:\n        d, load = 1, 0\n        for w in weights:\n            if load + w <= capacity:\n                load += w\n            else:\n                d += 1\n                load = w\n        return d",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "shipWithinDays"
  },
  "initial_state": {
    "name": "initial_state",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/tic-tac-toe.py",
    "line": 11,
    "signature": "def initial_state() -> tuple[str | None, ...]:",
    "parameters": [],
    "return_type": "tuple[(str | None, Ellipsis)]",
    "return_description": "",
    "description": "Return an empty 3×3 board as a flat 9-tuple.",
    "code": "def initial_state() -> tuple[str | None, ...]:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "player": {
    "name": "player",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/tic-tac-toe.py",
    "line": 15,
    "signature": "def player(state: tuple[str | None, ...]) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "Next player: X if X has ≤ moves than O, else O.",
    "code": "def player(state: tuple[str | None, ...]) -> str:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "actions": {
    "name": "actions",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/tic-tac-toe.py",
    "line": 19,
    "signature": "def actions(state: tuple[str | None, ...]) -> set[int]:",
    "parameters": [],
    "return_type": "set[int]",
    "return_description": "",
    "description": "All empty positions (0–8) available for play.",
    "code": "def actions(state: tuple[str | None, ...]) -> set[int]:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "result": {
    "name": "result",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/tic-tac-toe.py",
    "line": 23,
    "signature": "def result(state: tuple[str | None, ...], move: int) -> tuple[str | None, ...]:",
    "parameters": [],
    "return_type": "tuple[(str | None, Ellipsis)]",
    "return_description": "",
    "description": "Return new state after current player plays at index move.",
    "code": "def result(state: tuple[str | None, ...], move: int) -> tuple[str | None, ...]:\n    b[move] = player(state)\n    return tuple(b)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "winner": {
    "name": "winner",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/tic-tac-toe.py",
    "line": 29,
    "signature": "def winner(state: tuple[str | None, ...]) -> str | None:",
    "parameters": [],
    "return_type": "str | None",
    "return_description": "",
    "description": "Check for a winner. Uses _winner_cache to avoid re-scanning the same board.",
    "code": "def winner(state: tuple[str | None, ...]) -> str | None:\n        return _winner_cache[state]\n    for i, j, k in WIN:\n        v = state[i]\n        if v and v == state[j] == state[k]:\n            _winner_cache[state] = v\n            return v\n    _winner_cache[state] = None\n    return None",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "terminal": {
    "name": "terminal",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/tic-tac-toe.py",
    "line": 46,
    "signature": "def terminal(state: tuple[str | None, ...]) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "Game over if someone won or no empty cells remain.",
    "code": "def terminal(state: tuple[str | None, ...]) -> bool:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "utility": {
    "name": "utility",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/tic-tac-toe.py",
    "line": 50,
    "signature": "def utility(state: tuple[str | None, ...]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Score: +1 if X wins, -1 if O wins, else 0.",
    "code": "def utility(state: tuple[str | None, ...]) -> int:\n    return 1 if w == \"X\" else -1 if w == \"O\" else 0",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "minimax": {
    "name": "minimax",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/tic-tac-toe.py",
    "line": 55,
    "signature": "def minimax(state: tuple[str | None, ...]) -> int | None:",
    "parameters": [],
    "return_type": "int | None",
    "return_description": "",
    "description": "Return the optimal move index for the current player.",
    "code": "def minimax(state: tuple[str | None, ...]) -> int | None:\n        return None\n    turn = player(state)\n    best_val = -INF if turn == \"X\" else INF\n    best_move: int | None = None\n    for m in actions(state):\n        val = (_min_value if turn == \"X\" else _max_value)(result(state, m), -INF, INF)\n        if (turn == \"X\" and val > best_val) or (turn == \"O\" and val < best_val):\n            best_val, best_move = val, m\n    return best_move",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "_max_value": {
    "name": "_max_value",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/tic-tac-toe.py",
    "line": 76,
    "signature": "def _max_value(state: tuple[str | None, ...], α: float, β: float) -> float:",
    "parameters": [],
    "return_type": "float",
    "return_description": "",
    "description": "Maximizer’s step: try to increase v, prune when α ≥ β.",
    "code": "def _max_value(state: tuple[str | None, ...], α: float, β: float) -> float:\n        return utility(state)\n    v = -INF\n    for m in actions(state):\n        v = max(v, _min_value(result(state, m), α, β))\n        α = max(α, v)\n        if α >= β:  \n            break\n    return v",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "_min_value": {
    "name": "_min_value",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/tic-tac-toe.py",
    "line": 88,
    "signature": "def _min_value(state: tuple[str | None, ...], α: float, β: float) -> float:",
    "parameters": [],
    "return_type": "float",
    "return_description": "",
    "description": "Minimizer’s step: try to decrease v, prune when α ≥ β.",
    "code": "def _min_value(state: tuple[str | None, ...], α: float, β: float) -> float:\n        return utility(state)\n    v = INF\n    for m in actions(state):\n        v = min(v, _max_value(result(state, m), α, β))\n        β = min(β, v)\n        if α >= β:  \n            break\n    return v",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "DP": {
    "name": "DP",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 3,
    "signature": "class DP:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class DP:\n    def minimumTotal(self, triangle: list[list[int]]) -> int:\n        memo, n = {}, len(triangle)\n        def dp(r, c):\n            if r >= n or c > r:\n                return 0\n            if (r, c) not in memo:\n                memo[(r, c)] = min(\n                    triangle[r][c] + dp(r + 1, c), \n                    triangle[r][c] + dp(r + 1, c + 1)\n                )\n            return memo[(r, c)]\n        return dp(0, 0)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "DP.minimumTotal": {
    "name": "minimumTotal",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 4,
    "signature": "def minimumTotal(self, triangle: list[list[int]]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def minimumTotal(self, triangle: list[list[int]]) -> int:\n        memo, n = {}, len(triangle)\n        def dp(r, c):\n            if r >= n or c > r:\n                return 0\n            if (r, c) not in memo:\n                memo[(r, c)] = min(\n                    triangle[r][c] + dp(r + 1, c), \n                    triangle[r][c] + dp(r + 1, c + 1)\n                )\n            return memo[(r, c)]\n        return dp(0, 0)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "DP"
  },
  "DP.minimumTotal.dp": {
    "name": "dp",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/dp.py",
    "line": 8,
    "signature": "def dp(r, c):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def dp(r, c):\n            if r >= n or c > r:\n                return 0\n            if (r, c) not in memo:\n                memo[(r, c)] = min(\n                    triangle[r][c] + dp(r + 1, c), \n                    triangle[r][c] + dp(r + 1, c + 1)\n                )\n            return memo[(r, c)]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "DP.minimumTotal"
  },
  "LRUCache": {
    "name": "LRUCache",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 4,
    "signature": "class LRUCache:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "The LRU system is simple. It tracks *when* a book was last used.",
    "code": "class LRUCache:\n        self.cache: OrderedDict[int, int] = OrderedDict()\n        self.capacity = capacity\n    def get(self, key: int) -> int:\n            return -1\n        self.cache.move_to_end(key)\n        return val\n    def put(self, key: int, value: int) -> None:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "LRUCache.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 8,
    "signature": "def __init__(self, capacity: int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, capacity: int):\n        self.cache: OrderedDict[int, int] = OrderedDict()\n        self.capacity = capacity",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LRUCache"
  },
  "LRUCache.get": {
    "name": "get",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 12,
    "signature": "def get(self, key: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "When an item is accessed, it becomes the most recently used. We fetch the item and move it to the end of the `OrderedDict`.",
    "code": "def get(self, key: int) -> int:\n            return -1\n        self.cache.move_to_end(key)\n        return val",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LRUCache"
  },
  "LRUCache.put": {
    "name": "put",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 21,
    "signature": "def put(self, key: int, value: int) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "When an item is added or updated, it's also considered the most recently used and is moved to the end. If the cache exceeds its capacity, the item at the front of the OrderedDict (the least recently used) is removed.",
    "code": "def put(self, key: int, value: int) -> None:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LRUCache"
  },
  "LFUCache": {
    "name": "LFUCache",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 33,
    "signature": "class LFUCache:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "The LFU system is more sophisticated. It tracks not just *when* a book was last used, but also *how often* it has been used.",
    "code": "class LFUCache:\n        self.capacity    = capacity\n        self.cache       = {}  \n        self.freq        = {}  \n        self.buckets     = defaultdict(OrderedDict)  \n        self.minfreq     = 0\n    def _bump(self, key: int):\n        del self.buckets[f][key]\n        if not self.buckets[f]:\n            del self.buckets[f]\n            if self.minfreq == f:\n                self.minfreq += 1\n        self.freq[key] +=1 \n        self.buckets[f + 1][key] = None\n    def get(self, key: int) -> int:\n            return -1\n        self._bump(key)\n        return self.cache[key]\n    def put(self, key: int, value: int) -> None:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._bump(key)\n            return\n        if len(self.cache) >= self.capacity:\n            old_key, _ = self.buckets[self.minfreq].popitem(last=False)\n            del self.cache[old_key]\n            del self.freq[old_key]\n        self.cache[key] = value\n        self.freq[key] = 1\n        self.buckets[1][key] = None\n        self.minfreq = 1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "LFUCache.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 37,
    "signature": "def __init__(self, capacity: int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, capacity: int):\n        self.capacity    = capacity\n        self.cache       = {}  \n        self.freq        = {}  \n        self.buckets     = defaultdict(OrderedDict)  \n        self.minfreq     = 0",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "LFUCache._bump": {
    "name": "_bump",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 44,
    "signature": "def _bump(self, key: int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Move key from freq f to f+1.",
    "code": "def _bump(self, key: int):\n        del self.buckets[f][key]\n        if not self.buckets[f]:\n            del self.buckets[f]\n            if self.minfreq == f:\n                self.minfreq += 1\n        self.freq[key] +=1 \n        self.buckets[f + 1][key] = None",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "LFUCache.get": {
    "name": "get",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 58,
    "signature": "def get(self, key: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "When an item is accessed (get or put), its frequency count is incremented, and it moves from its current frequency bucket to the next, becoming the most recent item in that new bucket. For eviction, we remove the least recently used item from the lowest frequency bucket.",
    "code": "def get(self, key: int) -> int:\n            return -1\n        self._bump(key)\n        return self.cache[key]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "LFUCache.put": {
    "name": "put",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/cache.py",
    "line": 67,
    "signature": "def put(self, key: int, value: int) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "When an item is added or updated, its frequency count is set to 1, and it's added to the lowest frequency bucket. If the cache exceeds its capacity, the least recently used item from the lowest frequency bucket is removed.",
    "code": "def put(self, key: int, value: int) -> None:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._bump(key)\n            return\n        if len(self.cache) >= self.capacity:\n            old_key, _ = self.buckets[self.minfreq].popitem(last=False)\n            del self.cache[old_key]\n            del self.freq[old_key]\n        self.cache[key] = value\n        self.freq[key] = 1\n        self.buckets[1][key] = None\n        self.minfreq = 1",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "Solution": {
    "name": "Solution",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/stack.py",
    "line": 1,
    "signature": "class Solution:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class Solution:\n    def decodeString(self, s: str) -> str:\n        stack, s = [], \"1[\" + s + \"]\"\n        for c in s:\n            if c == \"]\":\n                curr = []\n                while stack[-1] != \"[\":\n                    curr.append(stack.pop())\n                stack.pop()  \n                num = []\n                while stack and stack[-1].isdigit():\n                    num.append(stack.pop())\n                stack.append(\"\".join(reversed(curr)) * int(\"\".join(reversed(num))))\n            else:\n                stack.append(c)\n        return stack[0]",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Solution.decodeString": {
    "name": "decodeString",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/stack.py",
    "line": 2,
    "signature": "def decodeString(self, s: str) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "",
    "code": "def decodeString(self, s: str) -> str:\n        stack, s = [], \"1[\" + s + \"]\"\n        for c in s:\n            if c == \"]\":\n                curr = []\n                while stack[-1] != \"[\":\n                    curr.append(stack.pop())\n                stack.pop()  \n                num = []\n                while stack and stack[-1].isdigit():\n                    num.append(stack.pop())\n                stack.append(\"\".join(reversed(curr)) * int(\"\".join(reversed(num))))\n            else:\n                stack.append(c)\n        return stack[0]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Solution"
  },
  "TreeNode": {
    "name": "TreeNode",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 4,
    "signature": "class TreeNode:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "TreeNode.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 5,
    "signature": "def __init__(self, val=0, left=None, right=None):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TreeNode"
  },
  "levelOrder": {
    "name": "levelOrder",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 11,
    "signature": "def levelOrder(root: TreeNode | None) -> list[list[int]]:",
    "parameters": [],
    "return_type": "list[list[int]]",
    "return_description": "",
    "description": "",
    "code": "def levelOrder(root: TreeNode | None) -> list[list[int]]:\n    if not root:\n        return []\n    queue, result = deque([root]), []\n    while queue:\n        level = [] \n        for _ in range(len(queue)):  \n            node = queue.popleft()\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level)\n    return result",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "numIslands": {
    "name": "numIslands",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 29,
    "signature": "def numIslands(grid: list[list[str]]) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[str]]",
        "description": "`m x n` 2D grid of `1`s (land) and `0`s (water), assume all four edges of the grid are all surrounded by water.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "number of islands",
    "description": "Args:",
    "code": "def numIslands(grid: list[list[str]]) -> int:\n        return 0\n    m, n = len(grid), len(grid[0])\n    dirs = ((1,0),(-1,0),(0,1),(0,-1))\n    islands = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                islands += 1\n                grid[i][j] = \"0\" \n                q = deque([(i, j)])\n                while q:\n                    r, c = q.popleft()\n                    for dr, dc in dirs:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == \"1\":\n                            grid[nr][nc] = \"0\" \n                            q.append((nr, nc)) \n    return islands",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "orangesRotting": {
    "name": "orangesRotting",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 60,
    "signature": "def orangesRotting(grid: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[int]]",
        "description": "`m x n` 2D grid of $0_{(empty)}$ , $1_{(fresh)}$ , $2_{(rotten)}$",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minutes required until no fresh oranges remain. If it's impossible, return -1.",
    "description": "Args:",
    "code": "def orangesRotting(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    q, fresh = deque(), 0\n    dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append((i, j))\n            elif grid[i][j] == 1:\n                fresh += 1\n    if fresh == 0:\n        return 0\n    minutes = 0\n    while q and fresh:\n        minutes += 1\n        for _ in range(len(q)):\n            x, y = q.popleft()\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh -= 1\n                    q.append((nx, ny))\n    return minutes if fresh == 0 else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Node": {
    "name": "Node",
    "type": "class",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 97,
    "signature": "class Node:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Node.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 98,
    "signature": "def __init__(self, val=0, neighbors=None):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Node"
  },
  "cloneGraph": {
    "name": "cloneGraph",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 103,
    "signature": "def cloneGraph(node: Node | None) -> Node | None:",
    "parameters": [
      {
        "name": "node",
        "type": "Node | None",
        "description": "reference to a node in a connected undirected graph",
        "default": null
      }
    ],
    "return_type": "Node | None",
    "return_description": "deep copy of the graph",
    "description": "Args:",
    "code": "def cloneGraph(node: Node | None) -> Node | None:\n        return None\n    cloned = {node: Node(node.val)}\n    queue = deque([node])\n    while queue:\n        cur = queue.popleft()\n        for n in cur.neighbors:\n            if n not in cloned:\n                cloned[n] = Node(n.val)\n                queue.append(n)\n            cloned[cur].neighbors.append(cloned[n])\n    return cloned[node]",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "snakesAndLadders": {
    "name": "snakesAndLadders",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 127,
    "signature": "def snakesAndLadders(board: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "board",
        "type": "list[list[int]]",
        "description": "`n x n` 2D grid of `-1`s (normal squares) or [`1` , `n*n`] (snake/ladder)",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum number of moves to reach the final square `n*n`",
    "description": "Args:",
    "code": "def snakesAndLadders(board: list[list[int]]) -> int:\n    flat_board =  [0] \n    for r, row in enumerate(reversed(board)):\n        flat_board.extend(row[::1 if r % 2 == 0 else -1])\n    target =(n:= len(board)) * n \n    moves, queue =  {1: 0}, deque([1])\n    while queue:\n        current = queue.popleft()\n        for roll in range(1, 7):\n            nxt = current + roll\n            if nxt > target:\n                break\n            landing = flat_board[nxt] if flat_board[nxt] != -1 else nxt\n            if landing not in moves:\n                moves[landing] = moves[current] + 1\n                if landing == target:\n                    return moves[landing]\n                queue.append(landing)\n    return -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "updateMatrix": {
    "name": "updateMatrix",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 157,
    "signature": "def updateMatrix(mat : list[list[int]]) -> list[list[int]]:",
    "parameters": [],
    "return_type": "list[list[int]]",
    "return_description": "",
    "description": "",
    "code": "def updateMatrix(mat : list[list[int]]) -> list[list[int]]:\n    m, n = len(mat), len(mat[0])\n    dist = [[-1] * n for _ in range(m)]\n    q = deque()\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and dist[ni][nj] < 0:\n                dist[ni][nj] = dist[i][j] + 1\n                q.append((ni, nj))\n    return dist",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "shortestPath": {
    "name": "shortestPath",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 180,
    "signature": "def shortestPath(grid: list[list[int]], k: int) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[int]]",
        "description": "`m x n` 2D grid of `0`s (empty) and `1`s (obstacle)",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "maximum number of eliminations allowed",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum number of steps to reach the bottom-right corner, or -1 if it's impossible",
    "description": "Args:",
    "code": "def shortestPath(grid: list[list[int]], k: int) -> int:\n    rows, cols = len(grid), len(grid[0])\n    min_steps = rows + cols - 3 \n    if k >= min_steps:\n        return min_steps\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n    q = deque([(0, 0, 0, k)])\n    while q:\n        r, c, steps, remaining_k = q.popleft()\n        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                new_remaining_k = remaining_k - grid[nr][nc]\n                if new_remaining_k > max_k[nr][nc]:\n                    if (nr, nc) == (rows - 1, cols - 1):\n                        return steps + 1\n                    max_k[nr][nc] = new_remaining_k\n                    q.append((nr, nc, steps + 1, new_remaining_k))\n    return -1",
    "links": [
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [
      {
        "name": "max_k",
        "description": "max_k[r][c] = maximum eliminations remaining when visiting (r,c)",
        "type": "variable"
      },
      {
        "name": "q",
        "description": "(row, col, steps, remaining_k)",
        "type": "variable"
      },
      {
        "name": "min_steps",
        "description": "Manhattan distance lower bound",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "ladderLength": {
    "name": "ladderLength",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/bfs.py",
    "line": 224,
    "signature": "def ladderLength(beginWord: str, endWord: str, wordList: list[str]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def ladderLength(beginWord: str, endWord: str, wordList: list[str]) -> int:\n    if endWord not in wordList:\n        return 0\n    L = len(beginWord)\n    combos: dict[str, list[str]] = defaultdict(list)\n    for w in wordList:\n        for i in range(L):\n            combos[w[:i] + \"*\" + w[i+1:]].append(w)\n    front, back = {beginWord}, {endWord}\n    dist_front, dist_back = {beginWord: 1}, {endWord: 1}\n    while front and back:\n        if len(front) > len(back):\n            front, back = back, front\n            dist_front, dist_back = dist_back, dist_front\n        next_front = set()\n        for word in front:\n            for i in range(L):\n                for n in combos[word[:i] + \"*\" + word[i+1:]]: \n                    if n in dist_back:\n                        return dist_front[word] + dist_back[n]\n                    if n not in dist_front:\n                        dist_front[n] = dist_front[word] + 1\n                        next_front.add(n)\n        front = next_front\n    return 0",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "mod": {
    "name": "mod",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/modular-arithmetic.py",
    "line": 1,
    "signature": "def mod(a: int, b: int) -> int:",
    "parameters": [
      {
        "name": "a",
        "type": "int",
        "description": "the first number1",
        "default": null
      },
      {
        "name": "b",
        "type": "int",
        "description": "the second number",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "int",
    "description": "a mod b",
    "code": "def mod(a: int, b: int) -> int:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "congruent1": {
    "name": "congruent1",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/modular-arithmetic.py",
    "line": 14,
    "signature": "def congruent1(a: int, b: int, n: int) -> bool:",
    "parameters": [
      {
        "name": "a",
        "type": "int",
        "description": "the first number2",
        "default": null
      },
      {
        "name": "b",
        "type": "int",
        "description": "the second number",
        "default": null
      },
      {
        "name": "n",
        "type": "int",
        "description": "the modulus, the number by which we are dividing",
        "default": null
      }
    ],
    "return_type": "bool",
    "return_description": "bool",
    "description": "a ≡ b (mod n)",
    "code": "def congruent1(a: int, b: int, n: int) -> bool:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "congruent2": {
    "name": "congruent2",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/modular-arithmetic.py",
    "line": 27,
    "signature": "def congruent2(a: int, b: int, n: int) -> bool:",
    "parameters": [
      {
        "name": "a",
        "type": "int",
        "description": "the first number3",
        "default": null
      },
      {
        "name": "b",
        "type": "int",
        "description": "the second number",
        "default": null
      },
      {
        "name": "n",
        "type": "int",
        "description": "the modulus, the number by which we are dividing",
        "default": null
      }
    ],
    "return_type": "bool",
    "return_description": "bool",
    "description": "a ≡ b (mod n)",
    "code": "def congruent2(a: int, b: int, n: int) -> bool:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "maxSubArrayLen": {
    "name": "maxSubArrayLen",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 3,
    "signature": "def maxSubArrayLen(segments: list[int], k: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "Target sum.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The length of the longest subarray with sum == k.",
    "description": "Find the maximum length of a subarray that sums to exactly k.",
    "code": "def maxSubArrayLen(segments: list[int], k: int) -> int:\n    marker_idx = {0: -1}\n    prefix_sum = max_length = 0\n    for i, segment in enumerate(segments):\n        prefix_sum += segment\n        if (target_marker := prefix_sum - k) in marker_idx:\n            max_length = max(max_length, i - marker_idx[target_marker])\n        if prefix_sum not in marker_idx:\n            marker_idx[prefix_sum] = i\n    return max_length",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "subarraySum": {
    "name": "subarraySum",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 30,
    "signature": "def subarraySum(segments: list[int], k: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "Target sum.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The count of subarrays with sum == k.",
    "description": "Count the number of subarrays that sum to exactly k.",
    "code": "def subarraySum(segments: list[int], k: int) -> int:\n    marker_frequency = defaultdict(int, {0: 1})\n    prefix_sum = count = 0\n    for segment in segments:\n        prefix_sum += segment\n        count += marker_frequency[prefix_sum - k]\n        marker_frequency[prefix_sum] += 1\n    return count",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "findMaxLength": {
    "name": "findMaxLength",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 52,
    "signature": "def findMaxLength(segments: list[int]) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers (positive for forward, negative/zero for backward).",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The length of the longest balanced subarray.",
    "description": "Find the maximum length of a contiguous subarray with an equal number of positive and negative values.",
    "code": "def findMaxLength(segments: list[int]) -> int:\n    return maxSubArrayLen(normalized_segments, 0)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "checkSubarraySum": {
    "name": "checkSubarraySum",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 65,
    "signature": "def checkSubarraySum(segments: list[int], k: int) -> bool:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "The divisor.",
        "default": null
      }
    ],
    "return_type": "bool",
    "return_description": "True if such a subarray exists, False otherwise.",
    "description": "Check if the array contains a subarray of at least length 2 whose sum is a multiple of k.",
    "code": "def checkSubarraySum(segments: list[int], k: int) -> bool:\n    remainder_idx = {0: -1}\n    prefix_remainder = 0\n    for i, segment in enumerate(segments):\n        prefix_remainder = (prefix_remainder + segment) % k\n        if prefix_remainder in remainder_idx:\n            if i - remainder_idx[prefix_remainder] > 1:\n                return True\n        else:\n            remainder_idx[prefix_remainder] = i\n    return False",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "subarraysDivByK": {
    "name": "subarraysDivByK",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 89,
    "signature": "def subarraysDivByK(segments: list[int], k: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "The divisor.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The count of subarrays with sum divisible by k.",
    "description": "Count the number of subarrays whose sum is divisible by k.",
    "code": "def subarraysDivByK(segments: list[int], k: int) -> int:\n    remainder_frequency = defaultdict(int, {0: 1})\n    prefix_remainder = count = 0\n    for segment in segments:\n        prefix_remainder = (prefix_remainder + segment) % k\n        count += remainder_frequency[prefix_remainder]\n        remainder_frequency[prefix_remainder] += 1\n    return count",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "minSubarray": {
    "name": "minSubarray",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 110,
    "signature": "def minSubarray(segments: list[int], p: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "p",
        "type": "int",
        "description": "The divisor.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The length of the shortest subarray to remove, or -1 if not possible.",
    "description": "Find the length of the shortest subarray to remove so that the sum of the remaining elements is divisible by p.",
    "code": "def minSubarray(segments: list[int], p: int) -> int:\n    total_remainder = sum(segments) % p\n    if total_remainder == 0:\n        return 0\n    remainder_idx = {0: -1}\n    prefix_remainder, min_length = 0, len(segments)\n    for i, segment in enumerate(segments):\n        prefix_remainder = (prefix_remainder + segment) % p\n        need = (prefix_remainder - total_remainder + p) % p\n        if need in remainder_idx:\n            min_length = min(min_length, i - remainder_idx[need])\n        remainder_idx[prefix_remainder] = i\n    return min_length if min_length < len(segments) else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "getModifiedArray": {
    "name": "getModifiedArray",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 138,
    "signature": "def getModifiedArray(length: int, updates: list[list[int]]) -> list[int]:",
    "parameters": [
      {
        "name": "length",
        "type": "int",
        "description": "The number of days in the itinerary.",
        "default": null
      },
      {
        "name": "updates",
        "type": "list[list[int]]",
        "description": "List of [start_day, end_day, change_in_km] updates.",
        "default": null
      }
    ],
    "return_type": "list[int]",
    "return_description": "The final daily travel plan after all updates.",
    "description": "Apply a list of range updates to an array and return the modified array.",
    "code": "def getModifiedArray(length: int, updates: list[list[int]]) -> list[int]:\n    delta = [0] * (length + 1)\n    for start_day, end_day, change_in_km in updates:\n        delta[start_day] += change_in_km\n        delta[end_day + 1] -= change_in_km\n    prefix_sum = 0\n    return [prefix_sum := prefix_sum + change for change in delta[:-1]]",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "numberOfArrays": {
    "name": "numberOfArrays",
    "type": "function",
    "language": "python",
    "file": "backend/algorithms/prefix_sum.py",
    "line": 159,
    "signature": "def numberOfArrays(differences: list[int], lower: int, upper: int) -> int:",
    "parameters": [
      {
        "name": "differences",
        "type": "list[int]",
        "description": "List of daily changes (trip segments).",
        "default": null
      },
      {
        "name": "lower",
        "type": "int",
        "description": "Lower bound for any marker on the highway.",
        "default": null
      },
      {
        "name": "upper",
        "type": "int",
        "description": "Upper bound for any marker on the highway.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The number of valid starting values.",
    "description": "Count the number of valid starting values for a hidden sequence given the differences and bounds.",
    "code": "def numberOfArrays(differences: list[int], lower: int, upper: int) -> int:\n    prefix_sum = min_marker = max_marker = 0\n    for diff in differences:\n        prefix_sum += diff\n        min_marker = min(min_marker, prefix_sum)\n        max_marker = max(max_marker, prefix_sum)\n    return max(0, (upper - max_marker) - (lower - min_marker) + 1)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "TicTacToeGame": {
    "name": "TicTacToeGame",
    "type": "class",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 9,
    "signature": "class TicTacToeGame:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Professional tic-tac-toe game implementation.",
    "code": "class TicTacToeGame:\n    EMPTY_BOARD: List[List[Optional[str]]] = [[None] * 3 for _ in range(3)]\n    PLAYERS = ('X', 'O')\n    WIN_PATTERNS = [\n        [(0, 0), (0, 1), (0, 2)],\n        [(1, 0), (1, 1), (1, 2)],\n        [(2, 0), (2, 1), (2, 2)],\n        [(0, 0), (1, 0), (2, 0)],\n        [(0, 1), (1, 1), (2, 1)],\n        [(0, 2), (1, 2), (2, 2)],\n        [(0, 0), (1, 1), (2, 2)],\n        [(0, 2), (1, 1), (2, 0)],\n    ]\n    def __init__(self, board: Optional[List[List[Optional[str]]]] = None) -> None:\n        self._validate_board()\n    def _validate_board(self) -> None:\n            raise ValueError(\"Board must be 3x3\")\n        for row in self.board:\n            for cell in row:\n                if cell is not None and cell not in self.PLAYERS:\n                    raise ValueError(f\"Invalid cell value: {cell}\")\n        x_count = sum(row.count('X') for row in self.board)\n        o_count = sum(row.count('O') for row in self.board)\n        if abs(x_count - o_count) > 1:\n            raise ValueError(\"Invalid board state: turn logic violated\")\n    @property\n    def current_player(self) -> str:\n        o_count = sum(row.count('O') for row in self.board)\n        return 'X' if x_count <= o_count else 'O'\n    @property\n    def winner(self) -> Optional[str]:\n            cells = [self.board[row][col] for row, col in pattern]\n            if cells[0] and all(cell == cells[0] for cell in cells):\n                return cells[0]\n        return None\n    @property\n    def is_terminal(self) -> bool:\n            cell is not None for row in self.board for cell in row\n        )\n    @property\n    def is_draw(self) -> bool:\n        pass\n    def make_move(self, row: int, col: int) -> bool:\n            return False\n        if self.board[row][col] is not None or self.is_terminal:\n            return False\n        self.board[row][col] = self.current_player\n        return True\n    def get_available_moves(self) -> List[Tuple[int, int]]:\n            (row, col) \n            for row in range(3) \n            for col in range(3) \n            if self.board[row][col] is None\n        ]\n    def get_ai_move(self) -> Tuple[Optional[Tuple[int, int]], dict]:\n        if not available_moves:\n            return None, {}\n        move, analysis = self._get_minimax_move_with_analysis()\n        return move, analysis\n    def _get_minimax_move_with_analysis(self) -> Tuple[Optional[Tuple[int, int]], dict]:\n        start_time = time.time()\n        analysis = {\n            'states_evaluated': 0,\n            'max_depth_reached': 0,\n            'move_evaluations': {},\n            'best_move_reasoning': '',\n            'game_tree_size': 0,\n            'algorithm': 'minimax',\n            'pruning_efficiency': 0\n        }\n        available_moves = self.get_available_moves()\n        best_move = None\n        if self.current_player == 'X':\n            best_score = float('-inf')\n            for row, col in available_moves:\n                self.board[row][col] = 'X'\n                score, _ = self._minimax_with_analysis(depth=0, is_maximizing=False, analysis=analysis)\n                self.board[row][col] = None\n                analysis['move_evaluations'][f\"({row},{col})\"] = {\n                    'score': score,\n                    'evaluation': self._get_move_evaluation(score, 'X')\n                }\n                if score > best_score:\n                    best_score = score\n                    best_move = (row, col)\n                    analysis['best_move_reasoning'] = self._get_move_reasoning(score, row, col, 'X')\n        else:\n            best_score = float('inf')\n            for row, col in available_moves:\n                self.board[row][col] = 'O'\n                score, _ = self._minimax_with_analysis(depth=0, is_maximizing=True, analysis=analysis)\n                self.board[row][col] = None\n                analysis['move_evaluations'][f\"({row},{col})\"] = {\n                    'score': score,\n                    'evaluation': self._get_move_evaluation(score, 'O')\n                }\n                if score < best_score:\n                    best_score = score\n                    best_move = (row, col)\n                    analysis['best_move_reasoning'] = self._get_move_reasoning(score, row, col, 'O')\n        computation_time = (time.time() - start_time) * 1000\n        analysis.update({\n            'computation_time_ms': round(computation_time, 2),\n            'possible_moves': len(available_moves),\n            'difficulty': 'impossible',\n            'best_score': best_score,\n            'best_move': f\"({best_move[0]},{best_move[1]})\" if best_move else None,\n            'total_positions': len(available_moves),\n        })\n        return best_move, analysis\n    def _minimax_with_analysis(self, depth: int, is_maximizing: bool, analysis: dict) -> Tuple[int, dict]:\n        analysis['max_depth_reached'] = max(analysis['max_depth_reached'], depth)\n        winner = self.winner\n        if winner == 'X':\n            return 10 - depth, {}\n        elif winner == 'O':\n            return -10 + depth, {}\n        elif self.is_terminal:\n            return 0, {}\n        if is_maximizing:\n            best_score = float('-inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'X'\n                score, _ = self._minimax_with_analysis(depth + 1, False, analysis)\n                self.board[row][col] = None\n                best_score = max(score, best_score)\n            return best_score, {}\n        else:\n            best_score = float('inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'O'\n                score, _ = self._minimax_with_analysis(depth + 1, True, analysis)\n                self.board[row][col] = None\n                best_score = min(score, best_score)\n            return best_score, {}\n    def _get_move_evaluation(self, score: int, player: str) -> str:\n            return \"Winning move\" if player == 'X' else \"Losing move\"\n        elif score < -5:\n            return \"Losing move\" if player == 'X' else \"Winning move\"\n        elif score > 0:\n            return \"Advantageous\" if player == 'X' else \"Disadvantageous\"\n        elif score < 0:\n            return \"Disadvantageous\" if player == 'X' else \"Advantageous\"\n        else:\n            return \"Neutral\"\n    def _get_move_reasoning(self, score: int, row: int, col: int, player: str) -> str:\n            (0,0): \"top-left corner\", (0,1): \"top center\", (0,2): \"top-right corner\",\n            (1,0): \"middle left\", (1,1): \"center\", (1,2): \"middle right\", \n            (2,0): \"bottom-left corner\", (2,1): \"bottom center\", (2,2): \"bottom-right corner\"\n        }\n        position = position_names.get((row, col), f\"position ({row},{col})\")\n        if score > 5:\n            return f\"Playing {position} guarantees a win for {player}\"\n        elif score == 0:\n            return f\"Playing {position} leads to optimal play (draw with perfect opponent)\"\n        elif score > 0:\n            return f\"Playing {position} gives {player} a slight advantage\"\n        elif score < 0:\n            return f\"Playing {position} is defensive, preventing opponent advantage\"\n        else:\n            return f\"Playing {position} maintains balance\"\n    def _get_minimax_move(self) -> Optional[Tuple[int, int]]:\n        if self.current_player == 'X':\n            best_score = float('-inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'X'\n                score = self._minimax(depth=0, is_maximizing=False)  \n                self.board[row][col] = None\n                if score > best_score:\n                    best_score = score\n                    best_move = (row, col)\n        else:\n            best_score = float('inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'O'\n                score = self._minimax(depth=0, is_maximizing=True)  \n                self.board[row][col] = None\n                if score < best_score:\n                    best_score = score\n                    best_move = (row, col)\n        return best_move\n    def _minimax(self, depth: int, is_maximizing: bool) -> int:\n        winner = self.winner\n        if winner == 'X':\n            return 10 - depth\n        elif winner == 'O':\n            return -10 + depth\n        elif self.is_terminal:\n            return 0\n        if is_maximizing:\n            best_score = float('-inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'X'\n                score = self._minimax(depth + 1, False)\n                self.board[row][col] = None\n                best_score = max(score, best_score)\n            return best_score\n        else:\n            best_score = float('inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'O'\n                score = self._minimax(depth + 1, True)\n                self.board[row][col] = None\n                best_score = min(score, best_score)\n            return best_score\n    def copy(self) -> 'TicTacToeGame':\n        pass\n    def __repr__(self) -> str:\n        for row in self.board:\n            line = \"|\".join(cell or \" \" for cell in row)\n            lines.append(f\"|{line}|\")\n        return \"\\n\".join(lines)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "TicTacToeGame.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 36,
    "signature": "def __init__(self, board: Optional[List[List[Optional[str]]]] = None) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "Initialize game with optional board state.",
    "code": "def __init__(self, board: Optional[List[List[Optional[str]]]] = None) -> None:\n        self._validate_board()",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame._validate_board": {
    "name": "_validate_board",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 41,
    "signature": "def _validate_board(self) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "Validate board state and structure.",
    "code": "def _validate_board(self) -> None:\n            raise ValueError(\"Board must be 3x3\")\n        for row in self.board:\n            for cell in row:\n                if cell is not None and cell not in self.PLAYERS:\n                    raise ValueError(f\"Invalid cell value: {cell}\")\n        x_count = sum(row.count('X') for row in self.board)\n        o_count = sum(row.count('O') for row in self.board)\n        if abs(x_count - o_count) > 1:\n            raise ValueError(\"Invalid board state: turn logic violated\")",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame.current_player": {
    "name": "current_player",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 59,
    "signature": "def current_player(self) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "Return current player based on move count.",
    "code": "def current_player(self) -> str:\n        o_count = sum(row.count('O') for row in self.board)\n        return 'X' if x_count <= o_count else 'O'",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame.winner": {
    "name": "winner",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 66,
    "signature": "def winner(self) -> Optional[str]:",
    "parameters": [],
    "return_type": "Optional[str]",
    "return_description": "",
    "description": "Check for game winner using win patterns.",
    "code": "def winner(self) -> Optional[str]:\n            cells = [self.board[row][col] for row, col in pattern]\n            if cells[0] and all(cell == cells[0] for cell in cells):\n                return cells[0]\n        return None",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame.is_terminal": {
    "name": "is_terminal",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 75,
    "signature": "def is_terminal(self) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "Check if game has ended (winner or draw).",
    "code": "def is_terminal(self) -> bool:\n            cell is not None for row in self.board for cell in row\n        )",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame.is_draw": {
    "name": "is_draw",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 82,
    "signature": "def is_draw(self) -> bool:",
    "parameters": [],
    "return_type": "bool",
    "return_description": "",
    "description": "Check if game is a draw.",
    "code": "def is_draw(self) -> bool:",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame.make_move": {
    "name": "make_move",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 86,
    "signature": "def make_move(self, row: int, col: int) -> bool:",
    "parameters": [
      {
        "name": "row",
        "type": "int",
        "description": "Row index (0-2)",
        "default": null
      },
      {
        "name": "col",
        "type": "int",
        "description": "Column index (0-2)",
        "default": null
      }
    ],
    "return_type": "bool",
    "return_description": "True if move was successful, False otherwise",
    "description": "Make a move at specified position.",
    "code": "def make_move(self, row: int, col: int) -> bool:\n            return False\n        if self.board[row][col] is not None or self.is_terminal:\n            return False\n        self.board[row][col] = self.current_player\n        return True",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame.get_available_moves": {
    "name": "get_available_moves",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 106,
    "signature": "def get_available_moves(self) -> List[Tuple[int, int]]:",
    "parameters": [],
    "return_type": "List[Tuple[(int, int)]]",
    "return_description": "",
    "description": "Get list of all available moves.",
    "code": "def get_available_moves(self) -> List[Tuple[int, int]]:\n            (row, col) \n            for row in range(3) \n            for col in range(3) \n            if self.board[row][col] is None\n        ]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame.get_ai_move": {
    "name": "get_ai_move",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 115,
    "signature": "def get_ai_move(self) -> Tuple[Optional[Tuple[int, int]], dict]:",
    "parameters": [],
    "return_type": "Tuple[(Optional[Tuple[(int, int)]], dict)]",
    "return_description": "",
    "description": "Get optimal AI move with detailed analysis.",
    "code": "def get_ai_move(self) -> Tuple[Optional[Tuple[int, int]], dict]:\n        if not available_moves:\n            return None, {}\n        move, analysis = self._get_minimax_move_with_analysis()\n        return move, analysis",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame._get_minimax_move_with_analysis": {
    "name": "_get_minimax_move_with_analysis",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 124,
    "signature": "def _get_minimax_move_with_analysis(self) -> Tuple[Optional[Tuple[int, int]], dict]:",
    "parameters": [],
    "return_type": "Tuple[(Optional[Tuple[(int, int)]], dict)]",
    "return_description": "",
    "description": "Get optimal move with detailed analysis for educational purposes.",
    "code": "def _get_minimax_move_with_analysis(self) -> Tuple[Optional[Tuple[int, int]], dict]:\n        start_time = time.time()\n        analysis = {\n            'states_evaluated': 0,\n            'max_depth_reached': 0,\n            'move_evaluations': {},\n            'best_move_reasoning': '',\n            'game_tree_size': 0,\n            'algorithm': 'minimax',\n            'pruning_efficiency': 0\n        }\n        available_moves = self.get_available_moves()\n        best_move = None\n        if self.current_player == 'X':\n            best_score = float('-inf')\n            for row, col in available_moves:\n                self.board[row][col] = 'X'\n                score, _ = self._minimax_with_analysis(depth=0, is_maximizing=False, analysis=analysis)\n                self.board[row][col] = None\n                analysis['move_evaluations'][f\"({row},{col})\"] = {\n                    'score': score,\n                    'evaluation': self._get_move_evaluation(score, 'X')\n                }\n                if score > best_score:\n                    best_score = score\n                    best_move = (row, col)\n                    analysis['best_move_reasoning'] = self._get_move_reasoning(score, row, col, 'X')\n        else:\n            best_score = float('inf')\n            for row, col in available_moves:\n                self.board[row][col] = 'O'\n                score, _ = self._minimax_with_analysis(depth=0, is_maximizing=True, analysis=analysis)\n                self.board[row][col] = None\n                analysis['move_evaluations'][f\"({row},{col})\"] = {\n                    'score': score,\n                    'evaluation': self._get_move_evaluation(score, 'O')\n                }\n                if score < best_score:\n                    best_score = score\n                    best_move = (row, col)\n                    analysis['best_move_reasoning'] = self._get_move_reasoning(score, row, col, 'O')\n        computation_time = (time.time() - start_time) * 1000\n        analysis.update({\n            'computation_time_ms': round(computation_time, 2),\n            'possible_moves': len(available_moves),\n            'difficulty': 'impossible',\n            'best_score': best_score,\n            'best_move': f\"({best_move[0]},{best_move[1]})\" if best_move else None,\n            'total_positions': len(available_moves),\n        })\n        return best_move, analysis",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame._minimax_with_analysis": {
    "name": "_minimax_with_analysis",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 188,
    "signature": "def _minimax_with_analysis(self, depth: int, is_maximizing: bool, analysis: dict) -> Tuple[int, dict]:",
    "parameters": [],
    "return_type": "Tuple[(int, dict)]",
    "return_description": "",
    "description": "Minimax with analysis tracking.",
    "code": "def _minimax_with_analysis(self, depth: int, is_maximizing: bool, analysis: dict) -> Tuple[int, dict]:\n        analysis['max_depth_reached'] = max(analysis['max_depth_reached'], depth)\n        winner = self.winner\n        if winner == 'X':\n            return 10 - depth, {}\n        elif winner == 'O':\n            return -10 + depth, {}\n        elif self.is_terminal:\n            return 0, {}\n        if is_maximizing:\n            best_score = float('-inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'X'\n                score, _ = self._minimax_with_analysis(depth + 1, False, analysis)\n                self.board[row][col] = None\n                best_score = max(score, best_score)\n            return best_score, {}\n        else:\n            best_score = float('inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'O'\n                score, _ = self._minimax_with_analysis(depth + 1, True, analysis)\n                self.board[row][col] = None\n                best_score = min(score, best_score)\n            return best_score, {}",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame._get_move_evaluation": {
    "name": "_get_move_evaluation",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 219,
    "signature": "def _get_move_evaluation(self, score: int, player: str) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "Get human-readable evaluation of move.",
    "code": "def _get_move_evaluation(self, score: int, player: str) -> str:\n            return \"Winning move\" if player == 'X' else \"Losing move\"\n        elif score < -5:\n            return \"Losing move\" if player == 'X' else \"Winning move\"\n        elif score > 0:\n            return \"Advantageous\" if player == 'X' else \"Disadvantageous\"\n        elif score < 0:\n            return \"Disadvantageous\" if player == 'X' else \"Advantageous\"\n        else:\n            return \"Neutral\"",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame._get_move_reasoning": {
    "name": "_get_move_reasoning",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 232,
    "signature": "def _get_move_reasoning(self, score: int, row: int, col: int, player: str) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "Get reasoning for why this move was chosen.",
    "code": "def _get_move_reasoning(self, score: int, row: int, col: int, player: str) -> str:\n            (0,0): \"top-left corner\", (0,1): \"top center\", (0,2): \"top-right corner\",\n            (1,0): \"middle left\", (1,1): \"center\", (1,2): \"middle right\", \n            (2,0): \"bottom-left corner\", (2,1): \"bottom center\", (2,2): \"bottom-right corner\"\n        }\n        position = position_names.get((row, col), f\"position ({row},{col})\")\n        if score > 5:\n            return f\"Playing {position} guarantees a win for {player}\"\n        elif score == 0:\n            return f\"Playing {position} leads to optimal play (draw with perfect opponent)\"\n        elif score > 0:\n            return f\"Playing {position} gives {player} a slight advantage\"\n        elif score < 0:\n            return f\"Playing {position} is defensive, preventing opponent advantage\"\n        else:\n            return f\"Playing {position} maintains balance\"",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame._get_minimax_move": {
    "name": "_get_minimax_move",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 253,
    "signature": "def _get_minimax_move(self) -> Optional[Tuple[int, int]]:",
    "parameters": [],
    "return_type": "Optional[Tuple[(int, int)]]",
    "return_description": "",
    "description": "Get optimal move using minimax algorithm.",
    "code": "def _get_minimax_move(self) -> Optional[Tuple[int, int]]:\n        if self.current_player == 'X':\n            best_score = float('-inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'X'\n                score = self._minimax(depth=0, is_maximizing=False)  \n                self.board[row][col] = None\n                if score > best_score:\n                    best_score = score\n                    best_move = (row, col)\n        else:\n            best_score = float('inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'O'\n                score = self._minimax(depth=0, is_maximizing=True)  \n                self.board[row][col] = None\n                if score < best_score:\n                    best_score = score\n                    best_move = (row, col)\n        return best_move",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame._minimax": {
    "name": "_minimax",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 280,
    "signature": "def _minimax(self, depth: int, is_maximizing: bool) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Standard minimax: X=maximizing player, O=minimizing player",
    "code": "def _minimax(self, depth: int, is_maximizing: bool) -> int:\n        winner = self.winner\n        if winner == 'X':\n            return 10 - depth\n        elif winner == 'O':\n            return -10 + depth\n        elif self.is_terminal:\n            return 0\n        if is_maximizing:\n            best_score = float('-inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'X'\n                score = self._minimax(depth + 1, False)\n                self.board[row][col] = None\n                best_score = max(score, best_score)\n            return best_score\n        else:\n            best_score = float('inf')\n            for row, col in self.get_available_moves():\n                self.board[row][col] = 'O'\n                score = self._minimax(depth + 1, True)\n                self.board[row][col] = None\n                best_score = min(score, best_score)\n            return best_score",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame.copy": {
    "name": "copy",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 313,
    "signature": "def copy(self) -> 'TicTacToeGame':",
    "parameters": [],
    "return_type": "'TicTacToeGame'",
    "return_description": "",
    "description": "Create a copy of the current game state.",
    "code": "def copy(self) -> 'TicTacToeGame':",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  },
  "TicTacToeGame.__repr__": {
    "name": "__repr__",
    "type": "method",
    "language": "python",
    "file": "backend/games/tic_tac_toe.py",
    "line": 317,
    "signature": "def __repr__(self) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "String representation for debugging.",
    "code": "def __repr__(self) -> str:\n        for row in self.board:\n            line = \"|\".join(cell or \" \" for cell in row)\n            lines.append(f\"|{line}|\")\n        return \"\\n\".join(lines)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TicTacToeGame"
  }
}