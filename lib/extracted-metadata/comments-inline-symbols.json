{
  "more/tictactoe/tictactoe_no_player_in_state.py:comment-line:77": "1 if X won, -1 if O won, 0 draw",
  "more/tictactoe/tictactoe_no_player_in_state.py:comment-line:89": "O to move → minimize X’s outcome",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:4": "preorder iterator that yields subtree roots in the exact order recursive calls are made",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:5": "map each value to its inorder index so we can split subtrees in O(1) time",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:8": "when the inorder slice is empty there is no subtree to build",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:9": "return None to signal an empty child",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:11": "consume exactly one preorder value which is the root of the current inorder slice [l, r]",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:12": "locate that root in inorder to determine how the preorder stream must be split between left and right subtrees",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:14": "construct the current subtree node and recursively attach its children",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:15": "assign the root value that preorder selected for this subtree",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:16": "recursively build the left subtree which consumes the next preorder values belonging to inorder[l..m-1]",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:17": "recursively build the right subtree which consumes the remaining preorder values belonging to inorder[m+1..r]",
  "problems/105-construct-binary-tree-from-preorder-and-inorder-traversal/solution.py:comment-line:20": "start recursion with the full inorder range to build the entire tree",
  "problems/909-snakes-and-ladders/solution.py:comment-line:4": "Dummy 0 for 1-based indexing",
  "problems/297-serialize-and-deserialize-binary-tree/solution.py:comment-line:7": "Preorder serialization: node -> left -> right , Use \"^\" as a delimiter and \"#\" as a null marker",
  "problems/297-serialize-and-deserialize-binary-tree/solution.py:comment-line:17": "left subtree (comes next in preorder)",
  "problems/297-serialize-and-deserialize-binary-tree/solution.py:comment-line:18": "right subtree",
  "problems/297-serialize-and-deserialize-binary-tree/solution.py:comment-line:22": "Rebuild the entire tree from the preorder stream",
  "problems/94-binary-tree-inorder-traversal/solution.py:comment-line:2": "TreeNode is only used in type hints, not at runtime",
  "problems/1584-min-cost-to-connect-all-points/array-based-prim.py:comment-line:2": "nodes already in the MST",
  "problems/1584-min-cost-to-connect-all-points/array-based-prim.py:comment-line:3": "dist[v] = cheapest edge from MST to v",
  "problems/1584-min-cost-to-connect-all-points/array-based-prim.py:comment-line:4": "start MST from node 0 (cost 0)",
  "problems/1584-min-cost-to-connect-all-points/array-based-prim.py:comment-line:7": "pick the non-MST node with the smallest connection cost",
  "problems/1584-min-cost-to-connect-all-points/array-based-prim.py:comment-line:8": "permanently add u to the MST",
  "problems/1584-min-cost-to-connect-all-points/array-based-prim.py:comment-line:9": "pay the edge cost that connects u",
  "problems/1584-min-cost-to-connect-all-points/heap-based-prim.py:comment-line:4": "nodes already fixed in the MST",
  "problems/1584-min-cost-to-connect-all-points/heap-based-prim.py:comment-line:5": "(edge_weight, node)",
  "problems/1584-min-cost-to-connect-all-points/heap-based-prim.py:comment-line:9": "cheapest available edge",
  "problems/1584-min-cost-to-connect-all-points/heap-based-prim.py:comment-line:10": "stale entry → ignore",
  "problems/1584-min-cost-to-connect-all-points/heap-based-prim.py:comment-line:12": "fix u in the MST",
  "problems/1584-min-cost-to-connect-all-points/heap-based-prim.py:comment-line:13": "pay the edge cost",
  "problems/1584-min-cost-to-connect-all-points/heap-based-prim.py:comment-line:19": "Without a true decrease-key heap, extra pushes are unavoidable in heap-Prim. Using dist[v] (or a decrease-key heap) reduces constants, not asymptotic complexity, so we keep the code simpler.",
  "problems/394-decode-string/solution.py:comment-line:7": "remove \"[\"",
  "problems/145-binary-tree-postorder-traversal/solution.py:comment-line:2": "TreeNode is only used in type hints, not at runtime",
  "problems/145-binary-tree-postorder-traversal/solution.py:comment-line:12": "same as `return [*self.postorderTraversal(node.left), *self.postorderTraversal(node.right),node.val] if node else []`",
  "problems/710-random-pick-with-blacklist/solution.py:comment-line:9": "start of the tail range [m, n): next candidate replacement",
  "problems/710-random-pick-with-blacklist/solution.py:comment-line:10": "iterate over all blacklisted values",
  "problems/710-random-pick-with-blacklist/solution.py:comment-line:11": "only blacklisted values in [0, m) can be sampled",
  "problems/710-random-pick-with-blacklist/solution.py:comment-line:12": "skip tail values that are themselves blacklisted",
  "problems/710-random-pick-with-blacklist/solution.py:comment-line:14": "remap b to the next valid tail value",
  "problems/710-random-pick-with-blacklist/solution.py:comment-line:15": "advance so each remapping uses a unique value",
  "problems/300-longest-increasing-subsequence/bottom-up.py:comment-line:1": "dp[i] = LIS length starting at i",
  "problems/300-longest-increasing-subsequence/binary_search.py:comment-line:5": "strict increasing; use bisect_right for non-decreasing",
  "problems/1143-longest-common-subsequence/bottom-up-prefix-1d.py:comment-line:1": "keep b the shorter to save space",
  "problems/460-lfu-cache/solution.py:comment-line:5": "key → value",
  "problems/460-lfu-cache/solution.py:comment-line:6": "key → freq",
  "problems/460-lfu-cache/solution.py:comment-line:7": "freq → keys in LRU order",
  "problems/460-lfu-cache/solution.py:comment-line:18": "self.freq[key] = f + 1",
  "problems/410-split-array-largest-sum/binary_search_on_answer_space.py:comment-line:6": "must start a new subarray",
  "problems/410-split-array-largest-sum/binary_search_on_answer_space.py:comment-line:9": "+1 for the final subarray",
  "problems/410-split-array-largest-sum/binary_search_on_answer_space.py:comment-line:11": "answer bounds",
  "problems/410-split-array-largest-sum/binary_search_on_answer_space.py:comment-line:15": "mid is feasible; try smaller maximum",
  "problems/410-split-array-largest-sum/binary_search_on_answer_space.py:comment-line:17": "mid is too small; increase lower bound",
  "problems/1235-maximum-profit-in-job-scheduling/top_down.py:comment-line:10": "max profit starting from job i",
  "problems/1235-maximum-profit-in-job-scheduling/bottom_up.py:comment-line:6": "Sort jobs by end time to ensure optimal substructure (DP on end times)",
  "problems/1235-maximum-profit-in-job-scheduling/bottom_up.py:comment-line:8": "ends[i] = end time of the i-th chosen job; dp[i] = max profit up to ends[i]",
  "problems/1235-maximum-profit-in-job-scheduling/bottom_up.py:comment-line:12": "Find the latest job that finishes before current start time",
  "problems/1235-maximum-profit-in-job-scheduling/bottom_up.py:comment-line:13": "profit if we include this job",
  "problems/1235-maximum-profit-in-job-scheduling/bottom_up.py:comment-line:15": "Only append if this job improves the total profit",
  "problems/1235-maximum-profit-in-job-scheduling/bottom_up.py:comment-line:19": "dp[-1] holds the maximum total profit",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/recursive.py:comment-line:4": "preorder stream: each recursive call consumes its subtree root next",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/recursive.py:comment-line:5": "postorder pointer: advances when a subtree is fully completed",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/recursive.py:comment-line:9": "take next preorder value as the root of *this* subtree",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/recursive.py:comment-line:11": "if post[j] isn't root yet, this subtree still has children",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/recursive.py:comment-line:12": "build a left child first (any valid choice; ambiguity is here)",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/recursive.py:comment-line:14": "if still not closed, there must also be a right child",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/recursive.py:comment-line:15": "build the right child",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/recursive.py:comment-line:17": "now post[j] == root.val → close this subtree and move past it",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/recursive.py:comment-line:20": "empty input → empty tree",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:5": "No nodes → empty tree",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:7": "First preorder value is always the root",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:8": "Stack = path of open nodes, j = postorder index",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:10": "Process remaining preorder values",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:11": "Create the next node to attach",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:12": "While the top subtree is complete (postorder says so)",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:13": "Close that subtree",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:14": "Advance postorder pointer",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:16": "Current open node to attach a child to",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:18": "Preorder guarantees left child is filled first",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:20": "If left exists, attach as right child",
  "problems/889-construct-binary-tree-from-preorder-and-postorder-traversal/iterative.py:comment-line:22": "New node may receive children next",
  "problems/837-new-21-game/solution.py:comment-line:6": "start with score 0 at probability 1",
  "problems/837-new-21-game/solution.py:comment-line:9": "landing on i = average of reachable previous states",
  "problems/837-new-21-game/solution.py:comment-line:10": "`i<k` means game is still active → `dp[i]` enters window",
  "problems/837-new-21-game/solution.py:comment-line:12": "if oldest index was in window, remove it",
  "problems/837-new-21-game/solution.py:comment-line:14": "sum probabilities of all stopping scores (i≥k)",
  "problems/363-max-sum-of-rectangle-no-larger-than-k/solution.py:comment-line:11": "Kadane \"extend or restart\"",
  "problems/363-max-sum-of-rectangle-no-larger-than-k/solution.py:comment-line:14": "[Early Exit] cannot beat K",
  "problems/363-max-sum-of-rectangle-no-larger-than-k/solution.py:comment-line:29": "[Early Exit]",
  "problems/363-max-sum-of-rectangle-no-larger-than-k/solution.py:comment-line:35": "find smallest prefix ≥ s-k",
  "problems/363-max-sum-of-rectangle-no-larger-than-k/solution.py:comment-line:39": "[Early Exit]",
  "problems/363-max-sum-of-rectangle-no-larger-than-k/solution.py:comment-line:40": "keep prefixes sorted for future queries",
  "problems/616-add-bold-tag-in-string/trie.py:comment-line:7": "store lengths",
  "problems/498-diagonal-traverse/solution.py:comment-line:3": "each diagonal is all (r,c) with r+c=d",
  "problems/498-diagonal-traverse/solution.py:comment-line:4": "even d → traverse up-right",
  "problems/498-diagonal-traverse/solution.py:comment-line:5": "largest r allowed: `r≤m−1` (bottom) and `r≤d` (else `c=d−r<0`)",
  "problems/498-diagonal-traverse/solution.py:comment-line:6": "c forced by r+c=d",
  "problems/498-diagonal-traverse/solution.py:comment-line:7": "valid while inside top/bottom + left/right",
  "problems/498-diagonal-traverse/solution.py:comment-line:9": "move up",
  "problems/498-diagonal-traverse/solution.py:comment-line:10": "move right",
  "problems/498-diagonal-traverse/solution.py:comment-line:11": "odd d → traverse down-left",
  "problems/498-diagonal-traverse/solution.py:comment-line:12": "largest c allowed: `c≤n−1` (right edge) and `c≤d` (else `r=d−c<0`)",
  "problems/498-diagonal-traverse/solution.py:comment-line:13": "r forced by r+c=d",
  "problems/498-diagonal-traverse/solution.py:comment-line:14": "valid while inside bounds",
  "problems/498-diagonal-traverse/solution.py:comment-line:16": "move down",
  "problems/498-diagonal-traverse/solution.py:comment-line:17": "move left",
  "problems/498-diagonal-traverse/solution.py:comment-line:18": "final zig-zag order",
  "problems/191-number-of-1-bits/brian-kernighan.py:comment-line:3": "drop the lowest set bit",
  "problems/918-maximum-sum-of-circular-subarray/solution.py:comment-line:6": "Kadane (max)",
  "problems/918-maximum-sum-of-circular-subarray/solution.py:comment-line:8": "Kadane (min)",
  "problems/162-find-peak-element/solution.py:comment-line:5": "uphill → peak on right",
  "problems/162-find-peak-element/solution.py:comment-line:7": "downhill or peak → left incl. m",
  "problems/102-binary-tree-level-order-traversal/solution.py:comment-line:10": "Process nodes at the current level",
  "problems/102-binary-tree-level-order-traversal/similar.py:comment-line:7": "queue for BFS traversal",
  "problems/102-binary-tree-level-order-traversal/similar.py:comment-line:9": "collect current level values",
  "problems/102-binary-tree-level-order-traversal/similar.py:comment-line:10": "process all nodes at this level",
  "problems/69-sqrt/newtons-method.py:comment-line:4": "Stops once r is small enough that its square fits under x",
  "problems/69-sqrt/newtons-method.py:comment-line:5": "Replace r with a refined, closer guess",
  "problems/311-sparse-matrix-multiplication/_optimized.py:comment-line:15": "C[i][j] += A[i][k] * B[k][j]",
  "problems/311-sparse-matrix-multiplication/optimized.py:comment-line:3": "Output matrix m x n",
  "problems/311-sparse-matrix-multiplication/optimized.py:comment-line:5": "For each row of A, keep only (c, v) where (v:=A[r][c]) != 0",
  "problems/311-sparse-matrix-multiplication/optimized.py:comment-line:6": "For each row of B, keep only (c, v) where (v:=B[r][c]) != 0",
  "problems/311-sparse-matrix-multiplication/optimized.py:comment-line:8": "For each nonzero A[i][k] and each nonzero B[k][j], accumulate A[i][k] * B[k][j]",
  "problems/311-sparse-matrix-multiplication/optimized.py:comment-line:11": "C[i][j]+=A[i][k]⋅B[k][j]",
  "problems/1563-stone-game-v/bottom-up.py:comment-line:5": "sum of single element",
  "problems/1563-stone-game-v/bottom-up.py:comment-line:19": "equal → can pick better side",
  "problems/1563-stone-game-v/bottom-up.py:comment-line:21": "pick left side",
  "problems/1563-stone-game-v/bottom-up.py:comment-line:23": "pick right side",
  "problems/1563-stone-game-v/bottom-up.py:comment-line:27": "forward cache",
  "problems/1563-stone-game-v/bottom-up.py:comment-line:28": "backward cache",
  "problems/1563-stone-game-v/top-down.py:comment-line:7": "score on single stone",
  "problems/1563-stone-game-v/top-down.py:comment-line:8": "score+sum on single stone",
  "problems/1563-stone-game-v/top-down.py:comment-line:14": "ensure smaller cols ready",
  "problems/1563-stone-game-v/top-down.py:comment-line:18": "sum(i..j)",
  "problems/1563-stone-game-v/top-down.py:comment-line:29": "equal → can take better side",
  "problems/1563-stone-game-v/top-down.py:comment-line:31": "take left part",
  "problems/1563-stone-game-v/top-down.py:comment-line:33": "take right part",
  "problems/1514-path-with-maximum-probability/bellman-ford.py:comment-line:2": "rob[i] stores max probability to reach node i",
  "problems/1514-path-with-maximum-probability/bellman-ford.py:comment-line:3": "Start with full certainty",
  "problems/1514-path-with-maximum-probability/bellman-ford.py:comment-line:5": "Perform up to n-1 rounds of relaxation",
  "problems/1514-path-with-maximum-probability/bellman-ford.py:comment-line:8": "Try to improve v through u",
  "problems/1514-path-with-maximum-probability/bellman-ford.py:comment-line:11": "Try to improve u through v (undirected graph)",
  "problems/1514-path-with-maximum-probability/bellman-ford.py:comment-line:15": "Early exit if no updates in this round",
  "problems/1514-path-with-maximum-probability/dijkstra.py:comment-line:18": "reached with max probability",
  "problems/435-non-overlapping-intervals/solution.py:comment-line:2": "Sort intervals by their end time (earliest finishing first)",
  "problems/435-non-overlapping-intervals/solution.py:comment-line:3": "`end` tracks last kept interval's end, `count` counts removals",
  "problems/435-non-overlapping-intervals/solution.py:comment-line:6": "Overlaps with the previous interval → remove one",
  "problems/435-non-overlapping-intervals/solution.py:comment-line:8": "No overlap → keep it and update `end`",
  "problems/435-non-overlapping-intervals/solution.py:comment-line:10": "Minimum number of intervals to remove",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:5": "automatically creates child nodes on access",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:6": "stores top-3 sentences for this prefix",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:15": "insert initial (sentence, frequency) pairs",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:19": "update global frequency",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:21": "walk prefix path for the sentence",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:22": "defaultdict creates node if missing",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:27": "add sentence if not present",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:28": "reorder by ranking rules",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:29": "keep only top-3",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:33": "end of sentence",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:35": "insert the completed sentence",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:36": "reset buffer",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:37": "reset traversal",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:40": "extend current prefix",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:41": "advance in trie (auto-creates missing nodes)",
  "problems/642-design-search-autocomplete-system/solution.py:comment-line:42": "return top-3 for this prefix",
  "problems/642-design-search-autocomplete-system/__init__.py:comment-line:5": ", treats the typed string as a full sentence, stores it, and resets.",
  "problems/57-insert-interval/solution.py:comment-line:5": "1) keep all before",
  "problems/57-insert-interval/solution.py:comment-line:9": "2) merge overlaps",
  "problems/57-insert-interval/solution.py:comment-line:15": "3) append rest",
  "problems/252-meeting-rooms/Interval-sort-and-scan.py:comment-line:1": "sorting by start times (`x[0]`) is more conventional when checking for sequential conflicts. but sorting by end times (`intervals.sort(key=lambda x: x[1])`) is correct as well",
  "problems/144-binary-tree-preorder-traversal/solution.py:comment-line:2": "TreeNode is only used in type hints, not at runtime",
  "problems/144-binary-tree-preorder-traversal/solution.py:comment-line:12": "same as `return [node.val, *self.preorderTraversal(node.left), *self.preorderTraversal(node.right)] if node else []`",
  "problems/15-3sum/solution.py:comment-line:2": "O(n log n)",
  "problems/15-3sum/solution.py:comment-line:6": "skip duplicate anchors",
  "problems/15-3sum/solution.py:comment-line:10": "need a larger sum → move left pointer right",
  "problems/15-3sum/solution.py:comment-line:11": "need a smaller sum → move right pointer left",
  "problems/15-3sum/solution.py:comment-line:15": "skip duplicate second elements to avoid repeated triplets",
  "problems/54-spiral-matrix/solution.py:comment-line:2": "current layer boundaries",
  "problems/54-spiral-matrix/solution.py:comment-line:4": "stop when boundaries cross",
  "problems/54-spiral-matrix/solution.py:comment-line:6": "`→` top row: left → right",
  "problems/54-spiral-matrix/solution.py:comment-line:7": "move boundary down",
  "problems/54-spiral-matrix/solution.py:comment-line:9": "`↓` right column: top `↓` bottom",
  "problems/54-spiral-matrix/solution.py:comment-line:11": "move boundary left",
  "problems/54-spiral-matrix/solution.py:comment-line:14": "`←` bottom row: right → left",
  "problems/54-spiral-matrix/solution.py:comment-line:15": "move boundary up",
  "problems/54-spiral-matrix/solution.py:comment-line:18": "`↑` left column: bottom `↑` top",
  "problems/54-spiral-matrix/solution.py:comment-line:20": "move boundary right",
  "problems/54-spiral-matrix/solution.py:comment-line:22": "final spiral order",
  "problems/743-network-delay-time/dijkstra.py:comment-line:16": "Skip outdated entries",
  "problems/743-network-delay-time/dijkstra-b.py:comment-line:14": "skip if already finalized",
  "problems/743-network-delay-time/dijkstra-b.py:comment-line:17": "current shortest time to reach this node",
  "problems/127-word-ladder/solution.py:comment-line:23": "Use pre-computed neighbors",
  "core/Tree/binary_tree_node.py:comment-line:0": "postpone evaluation of annotations",
  "core/Tree/binary_tree_node.py:comment-line:2": "minimal container for tree nodes",
  "core/Tree/binary_tree_node.py:comment-line:4": "slots reduce memory and speed attribute access",
  "core/Tree/binary_tree_node.py:comment-line:6": "value stored at this node",
  "core/Tree/binary_tree_node.py:comment-line:7": "reference to left subtree",
  "core/bellman-ford/layered_dag.py:comment-line:9": "k = 0…V-1",
  "core/bellman-ford/layered_dag.py:comment-line:10": "snapshot of $\\delta_k$",
  "core/bellman-ford/layered_dag.py:comment-line:14": "now holds $\\delta_{k+1}$"
}