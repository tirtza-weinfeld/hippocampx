{
  "trie": {
    "title": "Trie (Prefix Tree)",
    "route": "/notes/trie",
    "filePath": "app/notes/trie/page.mdx",
    "headings": [
      "Trie (Prefix Tree)",
      "Resizable table of contents",
      "Problems",
      "1. Implement Trie (Prefix Tree)",
      "2. Design Add and Search Words Data Structure",
      "3. Replace Words",
      "4. Word Search II"
    ],
    "text": "Design a Trie with  insert ,  search , and  startsWith  methods. Support only lowercase English letters.  208. Implement Trie (Prefix Tree)   [!insight:collapse]  One Node per Character  A Trie is a tree where each node maps a character to its child. Every word is stored by following or creating one node per character. A  is_end  flag marks the end of a valid word. Prefix queries traverse as far as possible; search only succeeds if  is_end  is true at the last node.  [!timecomplexity:collapse]  $O(L)$  ,where  $L$  is the length of the word.  All operations ‚Äî insert, search, and startsWith ‚Äî take time proportional to the word's length.  Implement a Trie that supports adding words and searching with  .  as a wildcard matching any single letter. \n [19:]There will be at most 2 dots in word for search queries.  211. Design Add and Search Words   [!insight:collapse]  DFS on Wildcards  .  addWord  is identical to  insert  in a normal Trie. The key difference is in  search : when encountering a  . , explore all children recursively. This naturally requires DFS. A match is valid only if any path leads to a terminal  is_end = True .  [!timecomplexity:collapse]  addWord(word) :  $O(n)$ , where  $n$  = word length  search(word) :  $O(26·µè ¬∑ n)$ , where  $k$  = number of wildcards  .  in the query  If  $k = 0$  ‚áí  $O(n)$  Worst‚Äêcase  $k = n$  ‚áí  $O(26^n ¬∑ n)$  Since  $k ‚â§ 2$  by problem constraints, this is effectively  $O(n)$  Given a dictionary of root words, replace all words in a sentence with the shortest root that is a prefix of the word.  648. Replace Words   [!insight:collapse]  Shortest Prefix Wins  Build a Trie from all root words. For each word in the sentence, scan its prefix in the Trie. Stop as soon as you hit a node with  is_end = True  ‚Äî that‚Äôs the shortest valid replacement.  [!timecomplexity:collapse]  O(D + S)  where  $D$  = total characters in dictionary,  $S$  = total characters in sentence.  Build trie:  $O(\\sum_{r\\in\\text{dictionary}}|r|)$  ‚Äî you walk each root‚Äôs characters, stopping early if you hit a terminal.  Search & replace:  $O(\\sum_{w\\in\\text{sentence}}|w|)$  ‚Äî for each word, you scan until you hit  is_end = True  or exhaust the word.  Overall:  $O(\\sum_{r\\in\\text{dictionary}}|r|\\;+\\;\\sum_{w\\in\\text{sentence}}|w|)$  Find all words in a 2D board that exist in a given word list.  212. Word Search II   [!insight:collapse] Prefix rails  The trie lays down ‚Äúprefix rails‚Äù across the grid: you only move where a rail continues; off‚Äërail steps end instantly.  A terminal is a station: record the word once, close that spur, and drop empty rails as you pass. In one walk, a cell is used at most once.  [!example:collapse] Quick example  Board:  o a a n\ne t a e\ni h k r\ni f l v Words:  oath ,  eat ,  rain  Rails start at root letters  o ,  e ,  r .  From  o : o‚Üía‚Üít‚Üíh forms ‚Äúoath‚Äù (station) ‚Üí collect once, close that spur.  From  e : e‚Üía‚Üít forms ‚Äúeat‚Äù ‚Üí collect once, close that spur.  From  r :  ra  has no continuing rail nearby ‚Üí that walk ends immediately.  [!timecomplexity:collapse]  $O(m n \\cdot 4^{L})$  Symbols:   $m\\times n$  board,  $W=\\sum_{w\\in\\text{dict}}|w|$ ,  $L=\\max|w|$ .  Build trie:   $O(W)$ .  DFS (worst case):  first step ‚â§ 4 choices, then ‚â§ 3 per step ‚áí  $O(m n \\cdot 4 \\cdot 3^{L-1})$ . Coarse bound:  $O(m n \\cdot 4^{L})$ .  Space:  trie  $O(W)$ ; recursion/visited path  $O(L)$ .",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/trie.py#class:Trie",
        "fileSource": "backend/algorithms/trie.py"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/trie.py#class:WordDictionary",
        "fileSource": "backend/algorithms/trie.py"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/trie.py#func:replaceWords",
        "fileSource": "backend/algorithms/trie.py",
        "functionName": "replaceWords"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/trie.py#func:findWords",
        "fileSource": "backend/algorithms/trie.py",
        "functionName": "findWords"
      },
      {
        "language": "text",
        "content": "o a a n\ne t a e\ni h k r\ni f l v"
      }
    ],
    "keyTerms": [
      "across",
      "adding",
      "addword",
      "board",
      "bound",
      "build",
      "case",
      "cdot",
      "cell",
      "character",
      "characters",
      "child",
      "children",
      "choices",
      "close",
      "coarse",
      "collapse",
      "collect",
      "constraints",
      "contents",
      "continues",
      "continuing",
      "creating",
      "data",
      "design",
      "dfs",
      "dict",
      "dictionary",
      "difference",
      "dots",
      "down",
      "drop",
      "each",
      "early",
      "eat",
      "effectively",
      "empty",
      "encountering",
      "ends",
      "english",
      "every",
      "example",
      "exhaust",
      "exist",
      "explore",
      "far",
      "find",
      "first",
      "flag",
      "following",
      "forms",
      "from",
      "given",
      "grid",
      "hit",
      "identical",
      "immediately",
      "implement",
      "insert",
      "insight",
      "instantly",
      "is_end",
      "key",
      "l-1",
      "last",
      "lays",
      "leads",
      "length",
      "letter",
      "letters",
      "list",
      "lowercase",
      "maps",
      "marks",
      "match",
      "matching",
      "max",
      "methods",
      "most",
      "move",
      "naturally",
      "nearby",
      "node",
      "normal",
      "number",
      "o",
      "oath",
      "once",
      "only",
      "operations",
      "overall",
      "pass",
      "path",
      "possible",
      "prefix",
      "problem",
      "problems",
      "proportional",
      "queries",
      "query",
      "quick",
      "rail",
      "rails",
      "rain",
      "record",
      "recursion",
      "recursively",
      "replace",
      "replacement",
      "requires",
      "resizable",
      "root",
      "scan",
      "search",
      "searching",
      "sentence",
      "shortest",
      "since",
      "single",
      "soon",
      "space",
      "spur",
      "start",
      "startswith",
      "station",
      "step",
      "steps",
      "stop",
      "stopping",
      "stored",
      "structure",
      "succeeds",
      "sum_",
      "support",
      "supports",
      "symbols",
      "table",
      "take",
      "terminal",
      "text",
      "that",
      "then",
      "there",
      "time",
      "timecomplexity",
      "times",
      "total",
      "traverse",
      "tree",
      "trie",
      "true",
      "until",
      "used",
      "valid",
      "visited",
      "walk",
      "when",
      "where",
      "wildcard",
      "wildcards",
      "will",
      "wins",
      "with",
      "word",
      "words",
      "worst"
    ],
    "notations": [
      "(26^n ¬∑ n)",
      "(26·µè ¬∑ n)",
      "(D + S)",
      "(L)",
      "(Prefix Tree)",
      "(W)",
      "(\\sum_{r\\in\\text{dictionary}}|r|)",
      "(\\sum_{r\\in\\text{dictionary}}|r|\\;+\\;\\sum_{w\\in\\text{sentence}}|w|)",
      "(\\sum_{w\\in\\text{sentence}}|w|)",
      "(m n \\cdot 4 \\cdot 3^{L-1})",
      "(m n \\cdot 4^{L})",
      "(n)",
      "(station)",
      "(word)",
      "(worst case)",
      "D$",
      "L$",
      "L=\\max|w|$",
      "O(26^n ¬∑ n)$",
      "O(26·µè ¬∑ n)$",
      "O(L)$",
      "O(W)$",
      "O(\\sum_{r\\in\\text{dictionary}}|r|)$",
      "O(\\sum_{r\\in\\text{dictionary}}|r|\\;+\\;\\sum_{w\\in\\text{sentence}}|w|)$",
      "O(\\sum_{w\\in\\text{sentence}}|w|)$",
      "O(m n \\cdot 4 \\cdot 3^{L-1})$",
      "O(m n \\cdot 4^{L})$",
      "O(n)$",
      "S$",
      "W=\\sum_{w\\in\\text{dict}}|w|$",
      "k = 0$",
      "k = n$",
      "k ‚â§ 2$",
      "k$",
      "m\\times n$",
      "n$"
    ],
    "categories": [
      "trie"
    ],
    "leetcodeProblems": [
      {
        "number": "208",
        "name": "Implement Trie (Prefix Tree)",
        "url": "https://leetcode.com/problems/implement-trie-prefix-tree/",
        "section": "1. Implement Trie (Prefix Tree)"
      },
      {
        "number": "211",
        "name": "Design Add and Search Words",
        "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/",
        "section": "2. Design Add and Search Words Data Structure"
      },
      {
        "number": "648",
        "name": "Replace Words",
        "url": "https://leetcode.com/problems/replace-words/",
        "section": "3. Replace Words"
      },
      {
        "number": "212",
        "name": "Word Search II",
        "url": "https://leetcode.com/problems/word-search-ii/",
        "section": "4. Word Search II"
      }
    ]
  },
  "tailwind": {
    "title": "Tailwind CSS v4.1: CSS-First Configuration & Theme Mastery",
    "route": "/notes/tailwind",
    "filePath": "app/notes/tailwind/page.mdx",
    "headings": [
      "Tailwind CSS v4.1: CSS-First Configuration & Theme Mastery",
      "Resizable Table Of Contents",
      "üéØ The Big Picture",
      "üèóÔ∏è Perfect globals.css Structure",
      "üè¢ CSS Cascade Layers - The Foundation",
      "Layer Priority Rules",
      "üîß Theme Variables Deep Dive",
      "The  @theme  Directive - Your Design System",
      "Advanced Theme Techniques",
      "üì± Container Queries Revolution",
      "Basic Container Query Setup",
      "Advanced Container Techniques",
      "Real-World Container Examples",
      "üÜï Revolutionary v4.1 Features",
      "Text Shadows (Finally!)",
      "CSS Masking for Creative Effects",
      "Pointer Device Variants",
      "Safe Alignment",
      "Improved Text Wrapping",
      "Last Baseline Alignment",
      "üé® New Visual Utilities",
      "Colored Drop Shadows",
      "New Variants",
      "üîß Custom Utilities & Variants",
      "Creating Custom Utilities",
      "Custom Variants",
      "üìã Complete Namespace Reference",
      "Core Design Token Namespaces",
      "Layout & Spacing Namespaces",
      "Visual Effect Namespaces",
      "Animation & Interaction Namespaces",
      "üí° Best Practices & Guidelines",
      "‚úÖ Recommended Patterns",
      "‚ùå Anti-Patterns to Avoid",
      "üîÑ CSS Variables Integration",
      "üöÄ Migration & Quick Start",
      "Upgrading from v3 to v4.1",
      "New Project Setup",
      "üèÅ Summary"
    ],
    "text": "Revolutionary Change : Tailwind v4.1 introduces CSS-first configuration, eliminating the need for  tailwind.config.js  in most projects. Everything happens directly in CSS using the new  @theme  directive and native CSS cascade layers.  Tailwind CSS v4.1 represents a fundamental shift from JavaScript configuration to  CSS-first configuration , leveraging cutting-edge CSS features:  ‚úÖ  CSS-first configuration  - No more  tailwind.config.js  for most projects  ‚úÖ  Native cascade layers  - Predictable style precedence with  @layer  ‚úÖ  Built-in container queries  - Component-level responsiveness without plugins  ‚úÖ  OKLCH colors & P3 gamut  - More vivid colors for modern displays  ‚úÖ  Text shadows & masks  - Long-awaited visual utilities finally here  ‚úÖ  Modern CSS transpilation  - Built-in vendor prefixing and optimization  ‚úÖ  Performance boost  - Up to 5x faster builds, 100x faster incremental builds  Your main CSS file should follow this battle-tested structure:  /* Import Tailwind CSS with modern syntax */\n@import \"tailwindcss\";\n/* 1. Theme Configuration - Your Design System Foundation */\n@theme {\n  /* Typography System */\n  /* Custom Breakpoints */\n  /* OKLCH Colors for Modern Displays */\n  /* Dynamic Spacing Scale */\n  /* Custom Animations & Timing */\n  /* Visual Effects */\n}\n/* 2. Base Layer - HTML Element Defaults */\n@layer base {\n  html {\n    @apply antialiased scroll-smooth;\n    color-scheme: light dark; /* Proper scrollbar colors */\n  }\n  body {\n    @apply font-sans text-gray-900 dark:text-gray-100;\n    @apply bg-white dark:bg-gray-900;\n  }\n  h1, h2, h3, h4, h5, h6 {\n    @apply font-display;\n  }\n  /* Better focus styles */\n  *:focus-visible {\n    @apply outline-2 outline-blue-500 outline-offset-2;\n  }\n}\n/* 3. Components Layer - Reusable UI Patterns */\n@layer components {\n  .btn {\n    @apply inline-flex items-center px-4 py-2;\n    @apply font-medium rounded-md transition-all duration-200;\n    @apply focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-blue-500;\n  }\n  .btn-primary {\n    @apply bg-brand-500 text-white;\n    @apply hover:bg-brand-600 active:bg-brand-700;\n  }\n  .card {\n    @apply bg-white dark:bg-gray-800 rounded-lg shadow-md p-6;\n    @apply border border-gray-200 dark:border-gray-700;\n  }\n  /* Container Query Components */\n  .responsive-grid {\n    @apply @container grid grid-cols-1;\n    @apply @md:grid-cols-2 @lg:grid-cols-3 @xl:grid-cols-4;\n  }\n}\n/* 4. Utilities Layer - Custom Utilities (Highest Priority) */\n@layer utilities {\n  .text-shadow-soft {\n    text-shadow: var(--text-shadow-soft);\n  }\n  .scrollbar-hidden {\n    scrollbar-width: none;\n    &::-webkit-scrollbar {\n      display: none;\n    }\n  }\n  .glass {\n    backdrop-filter: blur(12px) saturate(190%);\n    background: rgba(255, 255, 255, 0.09);\n    border: 1px solid rgba(255, 255, 255, 0.2);\n  }\n}\n/* 5. Custom Utilities & Variants */\n@utility focus-ring {\n  &:focus-visible {\n    outline: 2px solid theme(--color-blue-500);\n    outline-offset: 2px;\n  }\n}\n@variant pointer-coarse (@media (pointer: coarse));\n@variant reduced-motion (@media (prefers-reduced-motion: reduce));\n@variant high-contrast (@media (prefers-contrast: high)); Tailwind v4.1 uses  native CSS cascade layers  for bulletproof style organization:  /* Layer declaration order determines priority */\n@layer theme, base, components, utilities;\n@layer theme {\n  /* Design tokens and CSS variables */\n  :root {\n  }\n}\n@layer base {\n  /* HTML element defaults and resets */\n  body {\n    @apply font-sans text-gray-900 bg-white;\n  }\n}\n@layer components {\n  /* Reusable component classes */\n  .btn {\n    @apply px-4 py-2 rounded font-medium;\n  }\n}\n@layer utilities {\n  /* Utility classes - highest priority */\n  .text-shadow-sm {\n    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n  }\n} Critical Understanding:  utilities  always beats  components  beats  base  beats  theme  Later layers win regardless of CSS specificity  Within same layer, normal specificity rules apply  Use  !important  utilities when needed:  bg-red-500!  Example:  <!-- This element will be red, even though .card sets blue background -->\n<div class=\"card bg-red-500\">\n  <!-- utilities layer beats components layer -->\n</div> Every CSS variable in  @theme  automatically generates corresponding utilities:  @theme {\n  /* Typography */\n  /* Colors with OKLCH for wider gamut */\n  /* Spacing */\n  /* Breakpoints */\n  /* Animations */\n  @keyframes wiggle {\n    0%, 100% { transform: rotate(-3deg); }\n    50% { transform: rotate(3deg); }\n  }\n} Override entire namespaces:  @theme {\n  /* Remove all default fonts */\n} Variable references and cascading:  @theme {\n} Dynamic values with calc():  @theme {\n} Container queries are  built into core  v4.1 - no plugins needed:  <!-- 1. Mark element as container -->\n<div class=\"@container\">\n  <!-- 2. Children respond to container size, not viewport -->\n  <div class=\"grid grid-cols-1 @md:grid-cols-2 @lg:grid-cols-3\">\n    <div class=\"p-4 @sm:p-6\">\n      Content adapts to container width!\n    </div>\n  </div>\n</div> Named containers for precision:  <!-- Multiple containers with different purposes -->\n<aside class=\"@container/sidebar w-64 xl:w-80\">\n  <nav class=\"@lg/sidebar:flex @lg/sidebar:flex-col space-y-2\">\n    <!-- Only responds to sidebar container -->\n    <a class=\"@md/sidebar:text-sm @lg/sidebar:text-base\">Dashboard</a>\n    <a class=\"@md/sidebar:text-sm @lg/sidebar:text-base\">Settings</a>\n  </nav>\n</aside>\n<main class=\"@container/content flex-1\">\n  <article class=\"@xl/content:prose-xl @lg/content:prose-lg prose\">\n    <!-- Only responds to main content container -->\n    <h1>Article adapts to available space</h1>\n  </article>\n</main> Range queries and max-width:  <div class=\"@container\">\n  <!-- Hide in small containers -->\n  <div class=\"@max-sm:hidden\">Desktop-only widget</div>\n  <!-- Show only in specific range -->\n  <div class=\"@min-md:@max-lg:block hidden\">\n    Medium container only\n  </div>\n  <!-- Complex responsive grid -->\n  <div class=\"grid @sm:grid-cols-2 @lg:grid-cols-3 @xl:grid-cols-4 gap-4\">\n    <!-- Grid adapts to container, not viewport -->\n  </div>\n</div> Container query units for fluid scaling:  @layer components {\n  .fluid-card {\n    /* 5% of container inline size */\n    padding: 5cqi;\n    /* Font scales with container */\n    font-size: clamp(1rem, 4cqi, 3rem);\n    /* Height based on container block size */\n    min-height: 30cqb;\n  }\n} Dashboard sidebar that reshapes:  <aside class=\"@container/sidebar bg-gray-50 dark:bg-gray-800\">\n  <!-- User profile adapts to sidebar width -->\n  <div class=\"p-4 @lg/sidebar:p-6\">\n    <div class=\"@sm/sidebar:flex @sm/sidebar:items-center @sm/sidebar:space-x-3\">\n      <img class=\"@sm/sidebar:w-12 @sm/sidebar:h-12 w-16 h-16 rounded-full\" \n           src=\"/avatar.jpg\" alt=\"User\" />\n      <div class=\"@sm/sidebar:mt-0 mt-3 text-center @sm/sidebar:text-left\">\n        <h3 class=\"@lg/sidebar:text-lg font-medium\">John Doe</h3>\n        <p class=\"@md/sidebar:block hidden text-sm text-gray-600\">Admin</p>\n      </div>\n    </div>\n    <!-- Actions appear based on available space -->\n    <div class=\"@lg/sidebar:flex @lg/sidebar:space-x-2 @lg/sidebar:mt-4 hidden\">\n      <button class=\"btn btn-sm flex-1\">Profile</button>\n      <button class=\"btn btn-sm flex-1\">Settings</button>\n    </div>\n  </div>\n</aside> Product card that reorganizes:  <div class=\"@container max-w-sm mx-auto\">\n  <div class=\"card\">\n    <!-- Layout switches based on card width -->\n    <div class=\"@lg:flex @lg:space-x-4\">\n      <img class=\"@lg:w-32 @lg:h-32 w-full h-48 object-cover rounded-md\" \n           src=\"/product.jpg\" alt=\"Product\" />\n      <div class=\"@lg:flex-1 @lg:mt-0 mt-4\">\n        <h3 class=\"@xl:text-xl @lg:text-lg text-base font-semibold\">\n          Product Name\n        </h3>\n        <p class=\"@lg:text-sm text-xs text-gray-600 @lg:mt-1 mt-2\">\n          Product description that adapts to available space\n        </p>\n        <div class=\"@lg:mt-3 mt-4 @lg:flex @lg:space-x-2\">\n          <button class=\"btn btn-primary @lg:text-sm @lg:px-3 w-full @lg:w-auto\">\n            Buy Now\n          </button>\n          <button class=\"btn @lg:text-sm @lg:px-3 @lg:mt-0 mt-2 w-full @lg:w-auto\">\n            Details\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div> After years of requests, text shadows are here with full color control:  <!-- Size variants -->\n<h1 class=\"text-shadow-2xs\">Subtle shadow</h1>\n<h1 class=\"text-shadow-xs\">Small shadow</h1>\n<h1 class=\"text-shadow-sm\">Small shadow</h1>\n<h1 class=\"text-shadow-md\">Medium shadow</h1>\n<h1 class=\"text-shadow-lg\">Large shadow</h1>\n<!-- Colored shadows -->\n<h1 class=\"text-shadow-lg text-shadow-blue-500/30\">Blue glow effect</h1>\n<h1 class=\"text-shadow-md text-shadow-white/70\">Subtle white highlight</h1>\n<!-- Embossed effect -->\n<button class=\"text-gray-900 text-shadow-sm text-shadow-white/60 bg-gray-100\">\n  Embossed Button\n</button>\n<!-- Opacity modifiers -->\n<h1 class=\"text-shadow-xl/20\">20% opacity shadow</h1>\n<h1 class=\"text-shadow-lg/50\">50% opacity shadow</h1> Powerful composable masking utilities for stunning visual effects:  <!-- Fade image edges -->\n<img src=\"hero.jpg\" \n     class=\"mask-t-from-50% mask-b-to-0% w-full h-64 object-cover\" \n     alt=\"Fading hero image\" />\n<!-- Radial spotlight effect -->\n<div class=\"mask-radial-from-70% mask-radial-to-90% \n            bg-gradient-to-r from-purple-500 to-blue-500 \n            p-12 text-center text-white\">\n  <h2 class=\"text-3xl font-bold\">Spotlight Content</h2>\n</div>\n<!-- Complex combined masks -->\n<div class=\"mask-b-from-80% mask-r-from-80% \n            mask-radial-from-60% mask-radial-to-85%\n            bg-cover bg-center h-96\"\n     style=\"background-image: url('/landscape.jpg')\">\n  <div class=\"p-8 text-white\">\n    Content with multiple mask layers\n  </div>\n</div>\n<!-- Linear gradient masks -->\n<div class=\"mask-l-from-50% mask-l-to-90% mask-r-from-30%\">\n  Masked on left and right edges\n</div> Design specifically for different input methods:  <!-- Touch-optimized controls -->\n<button class=\"px-3 py-2 text-sm\n               pointer-coarse:px-6 pointer-coarse:py-4 pointer-coarse:text-base\">\n  Larger touch targets on mobile devices\n</button>\n<!-- Precision hover effects for mouse users -->\n<div class=\"transition-all duration-200\n            pointer-fine:hover:scale-105 pointer-fine:hover:shadow-lg\n            pointer-coarse:active:scale-95\">\n  Hover effects only for precise pointing devices\n</div>\n<!-- Different layouts for different input types -->\n<nav class=\"flex space-x-2\n            pointer-coarse:flex-col pointer-coarse:space-x-0 pointer-coarse:space-y-3\n            pointer-coarse:p-4\">\n  <a href=\"#\" class=\"nav-link pointer-coarse:text-lg pointer-coarse:py-3\">Home</a>\n  <a href=\"#\" class=\"nav-link pointer-coarse:text-lg pointer-coarse:py-3\">About</a>\n</nav>\n<!-- Hybrid device support with any-pointer */\n<div class=\"any-pointer-coarse:pb-safe-area-inset-bottom\">\n  Adapts to any touch capability\n</div> Keep content visible when it overflows:  <!-- Navigation that stays accessible -->\n<nav class=\"flex justify-center-safe gap-6 px-4 py-2\">\n  <a href=\"#\" class=\"nav-link\">Home</a>\n  <a href=\"#\" class=\"nav-link\">Products</a>\n  <a href=\"#\" class=\"nav-link\">Services</a>\n  <a href=\"#\" class=\"nav-link\">About</a>\n  <a href=\"#\" class=\"nav-link\">Contact</a>\n  <!-- On narrow screens, aligns left instead of hiding content -->\n</nav>\n<!-- Centered dialog that remains visible -->\n<div class=\"fixed inset-0 flex items-center-safe justify-center-safe p-4\">\n  <div class=\"bg-white rounded-lg shadow-xl max-w-md w-full p-6\">\n    <h2>Modal content always visible</h2>\n    <p>Even when content is larger than viewport</p>\n  </div>\n</div>\n<!-- Safe grid alignment */\n<div class=\"grid place-items-center-safe min-h-screen p-4\">\n  <div class=\"content-box\">\n    Content stays visible even when overflowing\n  </div>\n</div> Better control over text overflow and breaking:  <!-- Prevent layout breaking from long words -->\n<div class=\"wrap-break-word max-w-sm p-4 bg-gray-100\">\n  supercalifragilisticexpialidocioussupercalifragilisticexpialidocious\n</div>\n<!-- More aggressive wrapping for flex containers -->\n<div class=\"flex items-center space-x-3\">\n  <img src=\"/avatar.jpg\" class=\"w-12 h-12 rounded-full flex-shrink-0\" />\n  <div class=\"wrap-anywhere flex-1 min-w-0\">\n    <h3 class=\"font-medium\">Very Long Name That Might Break Layout</h3>\n    <p class=\"text-sm text-gray-600\">\n      verylongemailaddress@verylongcompanyname.com\n    </p>\n  </div>\n</div> Align items to the last line of text:  <div class=\"flex items-baseline-last gap-4\">\n  <div>\n    <h4 class=\"font-semibold text-lg\">Spencer Sharp</h4>\n    <p class=\"text-sm text-gray-600\">\n      Working on the future of astronaut recruitment at Space Recruit.\n      Building amazing experiences for space exploration teams.\n    </p>\n  </div>\n  <a href=\"#\" class=\"text-blue-600 text-sm\">\n    Visit Profile\n  </a>\n</div> <!-- Colored filter shadows -->\n<svg class=\"w-16 h-16 fill-cyan-500 drop-shadow-xl drop-shadow-cyan-500/50\">\n  <!-- SVG content -->\n</svg>\n<img src=\"/icon.png\" \n     class=\"w-20 h-20 drop-shadow-lg drop-shadow-purple-500/40\" \n     alt=\"Glowing icon\" /> <!-- No JavaScript fallback -->\n<div class=\"hidden noscript:block p-4 bg-yellow-50 border border-yellow-200\">\n  <p>Please enable JavaScript for the best experience.</p>\n</div>\n<!-- Better form validation states -->\n<input type=\"email\" \n       required \n       class=\"border border-gray-300 \n              user-invalid:border-red-500 user-invalid:ring-1 user-invalid:ring-red-500\n              user-valid:border-green-500 user-valid:ring-1 user-valid:ring-green-500\" />\n<!-- Inverted colors support -->\n<div class=\"shadow-xl inverted-colors:shadow-none bg-white inverted-colors:bg-transparent\">\n  Content that adapts to inverted color schemes\n</div>\n<!-- Details/summary content styling -->\n<details class=\"border rounded-lg p-4 details-content:pt-4 details-content:border-t\">\n  <summary class=\"font-medium cursor-pointer\">Click to expand</summary>\n  <div class=\"mt-3 text-gray-600\">\n    Content area that can be styled independently\n  </div>\n</details> @import \"tailwindcss\";\n/* Simple custom utility */\n@utility scrollbar-hidden {\n  scrollbar-width: none;\n  &::-webkit-scrollbar {\n    display: none;\n  }\n}\n/* Complex glass morphism utility */\n@utility glass {\n  backdrop-filter: blur(12px) saturate(190%) contrast(70%) brightness(80%);\n  background: rgba(255, 255, 255, 0.09);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px;\n}\n/* Utility with pseudo-elements */\n@utility focus-ring {\n  &:focus-visible {\n    outline: 2px solid theme(--color-blue-500);\n    outline-offset: 2px;\n    border-radius: theme(--radius-md);\n  }\n}\n/* Animation utility */\n@utility animate-wiggle {\n  animation: wiggle 1s ease-in-out infinite;\n  @keyframes wiggle {\n    0%, 100% { transform: rotate(-3deg); }\n    50% { transform: rotate(3deg); }\n  }\n} /* Media query variants */\n@variant reduced-motion (@media (prefers-reduced-motion: reduce));\n@variant high-contrast (@media (prefers-contrast: high));\n@variant portrait (@media (orientation: portrait));\n@variant print (@media print);\n/* Selector-based variants */\n@variant theme-dark (&:where([data-theme=\"dark\"] *));\n@variant loading (&[data-loading=\"true\"]);\n@variant invalid (&:invalid);\n/* Combined complex variants */\n@variant group-focus-within (&:where(.group:focus-within *));\n@variant peer-checked (&:where(.peer:checked ~ *)); 1. Use CSS-first configuration:  @import \"tailwindcss\";\n@theme {\n  /* Centralized design system */\n} 2. Organize with proper layers:  @layer base {\n  /* HTML element defaults */\n  body { @apply font-sans; }\n}\n@layer components {\n  /* Reusable patterns */\n  .btn { @apply px-4 py-2 rounded; }\n}\n@layer utilities {\n  /* Custom utilities */\n  .text-shadow-glow { text-shadow: 0 0 10px currentColor; }\n} 3. Use container queries for true responsiveness:  <div class=\"@container\">\n  <div class=\"@md:flex @md:items-center\">\n    <!-- Responds to container, not viewport -->\n  </div>\n</div> 4. Leverage modern CSS features:  @theme {\n  /* OKLCH for vivid colors */\n  /* CSS variables for runtime flexibility */\n} 1. Don't mix v3 and v4 syntax:  /* ‚ùå Old v3 syntax */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n/* ‚úÖ New v4.1 syntax */\n@import \"tailwindcss\"; 2. Don't bypass the layer system:  /* ‚ùå Unclear precedence */\n.my-component {\n  background: blue !important;\n}\n/* ‚úÖ Use layers properly */\n@layer components {\n  .my-component {\n    @apply bg-blue-500;\n  }\n} 3. Don't ignore container queries:  <!-- ‚ùå Viewport-only thinking -->\n<div class=\"md:flex\">\n  <!-- Always responds to viewport -->\n</div>\n<!-- ‚úÖ Container-aware design -->\n<div class=\"@container\">\n  <div class=\"@md:flex\">\n    <!-- Responds to available space -->\n  </div>\n</div> All theme variables become CSS variables you can use anywhere:  /* In custom CSS */\n.custom-component {\n  background: var(--color-brand-500);\n  font-family: var(--font-display);\n  border-radius: var(--radius-lg);\n  box-shadow: var(--shadow-glow);\n  animation: var(--animate-slide);\n}\n/* With calc() for dynamic values */\n.responsive-spacing {\n  padding: calc(var(--spacing) * 4);\n  margin: calc(var(--spacing) * 2);\n} function ThemedComponent() {\n  return (\n    <div \n      style={{\n        backgroundColor: 'var(--color-brand-500)',\n        borderRadius: 'var(--radius-lg)',\n        padding: 'calc(var(--spacing) * 4)'\n      }}\n    >\n      Runtime theming with CSS variables!\n    </div>\n  );\n} 1. Update dependencies:  npm install tailwindcss@latest @tailwindcss/postcss@latest\nnpm install tailwindcss@latest @tailwindcss/vite@latest\nnpm install tailwindcss@latest @tailwindcss/cli@latest 2. Use the automatic upgrade tool:  npx @tailwindcss/upgrade@latest 3. Update your CSS file:  /* Replace this v3 syntax */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n/* With this v4.1 syntax */\n@import \"tailwindcss\";\n@theme {\n  /* Move your theme config here */\n} 4. Organize with layers:  @layer base {\n  /* Move base styles here */\n}\n@layer components {\n  /* Move component styles here */\n}\n@layer utilities {\n  /* Move custom utilities here */\n} 1. Install Tailwind CSS v4.1:  npm create tailwindcss@latest my-project\ncd my-project 2. Set up your CSS foundation:  @import \"tailwindcss\";\n@theme {\n  /* Your design system */\n}\n@layer base {\n  html {\n    @apply antialiased scroll-smooth;\n  }\n}\n@layer components {\n  .btn {\n    @apply px-4 py-2 rounded font-medium transition-colors;\n  }\n} 3. Start building with modern features:  <div class=\"@container\">\n  <div class=\"@md:flex @md:items-center space-y-4 @md:space-y-0 @md:space-x-6\">\n    <h1 class=\"text-3xl @lg:text-4xl font-display text-shadow-sm\">\n      Modern Tailwind v4.1!\n    </h1>\n    <button class=\"btn bg-brand-500 text-white pointer-coarse:px-6 pointer-coarse:py-4\">\n      Get Started\n    </button>\n  </div>\n</div> Tailwind CSS v4.1 represents the future of utility-first styling:  CSS-first configuration  eliminates JavaScript config complexity  Native cascade layers  provide bulletproof style organization  Container queries  enable true component-level responsiveness  Modern CSS features  like OKLCH colors and text shadows  Performance improvements  up to 100x faster incremental builds  Better developer experience  with cleaner, more intuitive APIs  This comprehensive guide gives you everything needed to master Tailwind CSS v4.1's revolutionary approach and build better, more maintainable web interfaces!",
    "sections": [],
    "codeBlocks": [
      {
        "language": "css",
        "content": "/* Import Tailwind CSS with modern syntax */\n@import \"tailwindcss\";\n\n/* 1. Theme Configuration - Your Design System Foundation */\n@theme {\n  /* Typography System */\n  --font-display: \"Satoshi\", \"sans-serif\";\n  --font-mono: \"JetBrains Mono\", monospace;\n  \n  /* Custom Breakpoints */\n  --breakpoint-3xl: 1920px;\n  --breakpoint-4xl: 2560px;\n  \n  /* OKLCH Colors for Modern Displays */\n  --color-brand-50: oklch(0.98 0.02 220);\n  --color-brand-500: oklch(0.64 0.24 220);\n  --color-brand-950: oklch(0.15 0.05 220);\n  \n  /* Dynamic Spacing Scale */\n  --spacing: 0.25rem; /* Enables mt-17, w-23, etc. automatically */\n  \n  /* Custom Animations & Timing */\n  --ease-fluid: cubic-bezier(0.3, 0, 0, 1);\n  --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);\n  --animate-slide: slide 0.3s var(--ease-fluid);\n  \n  /* Visual Effects */\n  --shadow-glow: 0 0 20px rgba(59, 130, 246, 0.5);\n  --text-shadow-soft: 0 1px 3px rgba(0, 0, 0, 0.12);\n}\n\n/* 2. Base Layer - HTML Element Defaults */\n@layer base {\n  html {\n    @apply antialiased scroll-smooth;\n    color-scheme: light dark; /* Proper scrollbar colors */\n  }\n  \n  body {\n    @apply font-sans text-gray-900 dark:text-gray-100;\n    @apply bg-white dark:bg-gray-900;\n  }\n  \n  h1, h2, h3, h4, h5, h6 {\n    @apply font-display;\n  }\n  \n  /* Better focus styles */\n  *:focus-visible {\n    @apply outline-2 outline-blue-500 outline-offset-2;\n  }\n}\n\n/* 3. Components Layer - Reusable UI Patterns */\n@layer components {\n  .btn {\n    @apply inline-flex items-center px-4 py-2;\n    @apply font-medium rounded-md transition-all duration-200;\n    @apply focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-blue-500;\n  }\n  \n  .btn-primary {\n    @apply bg-brand-500 text-white;\n    @apply hover:bg-brand-600 active:bg-brand-700;\n  }\n  \n  .card {\n    @apply bg-white dark:bg-gray-800 rounded-lg shadow-md p-6;\n    @apply border border-gray-200 dark:border-gray-700;\n  }\n  \n  /* Container Query Components */\n  .responsive-grid {\n    @apply @container grid grid-cols-1;\n    @apply @md:grid-cols-2 @lg:grid-cols-3 @xl:grid-cols-4;\n  }\n}\n\n/* 4. Utilities Layer - Custom Utilities (Highest Priority) */\n@layer utilities {\n  .text-shadow-soft {\n    text-shadow: var(--text-shadow-soft);\n  }\n  \n  .scrollbar-hidden {\n    scrollbar-width: none;\n    &::-webkit-scrollbar {\n      display: none;\n    }\n  }\n  \n  .glass {\n    backdrop-filter: blur(12px) saturate(190%);\n    background: rgba(255, 255, 255, 0.09);\n    border: 1px solid rgba(255, 255, 255, 0.2);\n  }\n}\n\n/* 5. Custom Utilities & Variants */\n@utility focus-ring {\n  &:focus-visible {\n    outline: 2px solid theme(--color-blue-500);\n    outline-offset: 2px;\n  }\n}\n\n@variant pointer-coarse (@media (pointer: coarse));\n@variant reduced-motion (@media (prefers-reduced-motion: reduce));\n@variant high-contrast (@media (prefers-contrast: high));"
      },
      {
        "language": "css",
        "content": "/* Layer declaration order determines priority */\n@layer theme, base, components, utilities;\n\n@layer theme {\n  /* Design tokens and CSS variables */\n  :root {\n    --color-brand: oklch(0.64 0.24 220);\n    --font-display: \"Inter\", sans-serif;\n  }\n}\n\n@layer base {\n  /* HTML element defaults and resets */\n  body {\n    @apply font-sans text-gray-900 bg-white;\n  }\n}\n\n@layer components {\n  /* Reusable component classes */\n  .btn {\n    @apply px-4 py-2 rounded font-medium;\n  }\n}\n\n@layer utilities {\n  /* Utility classes - highest priority */\n  .text-shadow-sm {\n    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n  }\n}"
      },
      {
        "language": "html",
        "content": "<!-- This element will be red, even though .card sets blue background -->\n<div class=\"card bg-red-500\">\n  <!-- utilities layer beats components layer -->\n</div>"
      },
      {
        "language": "css",
        "content": "@theme {\n  /* Typography */\n  --font-display: \"Inter\", sans-serif;      /* ‚Üí font-display */\n  --text-hero: 4rem;                        /* ‚Üí text-hero */\n  --text-hero--line-height: 1.1;           /* ‚Üí Default line-height for text-hero */\n  --text-hero--font-weight: 800;           /* ‚Üí Default font-weight for text-hero */\n  \n  /* Colors with OKLCH for wider gamut */\n  --color-brand-50: oklch(0.98 0.02 220);  /* ‚Üí bg-brand-50, text-brand-50, etc. */\n  --color-brand-500: oklch(0.64 0.24 220); /* ‚Üí bg-brand-500, text-brand-500, etc. */\n  --color-brand-950: oklch(0.15 0.05 220); /* ‚Üí bg-brand-950, text-brand-950, etc. */\n  \n  /* Spacing */\n  --spacing: 0.25rem;                       /* ‚Üí Dynamic scale: mt-1 to mt-999 */\n  --spacing-tight: 0.125rem;               /* ‚Üí p-tight, m-tight, w-tight */\n  \n  /* Breakpoints */\n  --breakpoint-3xl: 1920px;                /* ‚Üí 3xl:* variants */\n  --breakpoint-4xl: 2560px;                /* ‚Üí 4xl:* variants */\n  \n  /* Animations */\n  --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);\n  --animate-wiggle: wiggle 1s ease-in-out infinite;\n  \n  @keyframes wiggle {\n    0%, 100% { transform: rotate(-3deg); }\n    50% { transform: rotate(3deg); }\n  }\n}"
      },
      {
        "language": "css",
        "content": "@theme {\n  /* Remove all default fonts */\n  --font-*: initial;\n  --font-sans: \"Your Brand Font\", system-ui;\n  --font-display: \"Your Display Font\", serif;\n}"
      },
      {
        "language": "css",
        "content": "@theme {\n  --color-primary: var(--color-blue-600);\n  --color-accent: var(--color-primary);\n  --color-interactive: var(--color-accent);\n}"
      },
      {
        "language": "css",
        "content": "@theme {\n  --spacing-golden: calc(var(--spacing) * 1.618);\n  --text-responsive: clamp(1rem, 4vw, 3rem);\n}"
      },
      {
        "language": "html",
        "content": "<!-- 1. Mark element as container -->\n<div class=\"@container\">\n  <!-- 2. Children respond to container size, not viewport -->\n  <div class=\"grid grid-cols-1 @md:grid-cols-2 @lg:grid-cols-3\">\n    <div class=\"p-4 @sm:p-6\">\n      Content adapts to container width!\n    </div>\n  </div>\n</div>"
      },
      {
        "language": "html",
        "content": "<!-- Multiple containers with different purposes -->\n<aside class=\"@container/sidebar w-64 xl:w-80\">\n  <nav class=\"@lg/sidebar:flex @lg/sidebar:flex-col space-y-2\">\n    <!-- Only responds to sidebar container -->\n    <a class=\"@md/sidebar:text-sm @lg/sidebar:text-base\">Dashboard</a>\n    <a class=\"@md/sidebar:text-sm @lg/sidebar:text-base\">Settings</a>\n  </nav>\n</aside>\n\n<main class=\"@container/content flex-1\">\n  <article class=\"@xl/content:prose-xl @lg/content:prose-lg prose\">\n    <!-- Only responds to main content container -->\n    <h1>Article adapts to available space</h1>\n  </article>\n</main>"
      },
      {
        "language": "html",
        "content": "<div class=\"@container\">\n  <!-- Hide in small containers -->\n  <div class=\"@max-sm:hidden\">Desktop-only widget</div>\n  \n  <!-- Show only in specific range -->\n  <div class=\"@min-md:@max-lg:block hidden\">\n    Medium container only\n  </div>\n  \n  <!-- Complex responsive grid -->\n  <div class=\"grid @sm:grid-cols-2 @lg:grid-cols-3 @xl:grid-cols-4 gap-4\">\n    <!-- Grid adapts to container, not viewport -->\n  </div>\n</div>"
      },
      {
        "language": "css",
        "content": "@layer components {\n  .fluid-card {\n    /* 5% of container inline size */\n    padding: 5cqi;\n    /* Font scales with container */\n    font-size: clamp(1rem, 4cqi, 3rem);\n    /* Height based on container block size */\n    min-height: 30cqb;\n  }\n}"
      },
      {
        "language": "html",
        "content": "<aside class=\"@container/sidebar bg-gray-50 dark:bg-gray-800\">\n  <!-- User profile adapts to sidebar width -->\n  <div class=\"p-4 @lg/sidebar:p-6\">\n    <div class=\"@sm/sidebar:flex @sm/sidebar:items-center @sm/sidebar:space-x-3\">\n      <img class=\"@sm/sidebar:w-12 @sm/sidebar:h-12 w-16 h-16 rounded-full\" \n           src=\"/avatar.jpg\" alt=\"User\" />\n      <div class=\"@sm/sidebar:mt-0 mt-3 text-center @sm/sidebar:text-left\">\n        <h3 class=\"@lg/sidebar:text-lg font-medium\">John Doe</h3>\n        <p class=\"@md/sidebar:block hidden text-sm text-gray-600\">Admin</p>\n      </div>\n    </div>\n    \n    <!-- Actions appear based on available space -->\n    <div class=\"@lg/sidebar:flex @lg/sidebar:space-x-2 @lg/sidebar:mt-4 hidden\">\n      <button class=\"btn btn-sm flex-1\">Profile</button>\n      <button class=\"btn btn-sm flex-1\">Settings</button>\n    </div>\n  </div>\n</aside>"
      },
      {
        "language": "html",
        "content": "<div class=\"@container max-w-sm mx-auto\">\n  <div class=\"card\">\n    <!-- Layout switches based on card width -->\n    <div class=\"@lg:flex @lg:space-x-4\">\n      <img class=\"@lg:w-32 @lg:h-32 w-full h-48 object-cover rounded-md\" \n           src=\"/product.jpg\" alt=\"Product\" />\n      <div class=\"@lg:flex-1 @lg:mt-0 mt-4\">\n        <h3 class=\"@xl:text-xl @lg:text-lg text-base font-semibold\">\n          Product Name\n        </h3>\n        <p class=\"@lg:text-sm text-xs text-gray-600 @lg:mt-1 mt-2\">\n          Product description that adapts to available space\n        </p>\n        <div class=\"@lg:mt-3 mt-4 @lg:flex @lg:space-x-2\">\n          <button class=\"btn btn-primary @lg:text-sm @lg:px-3 w-full @lg:w-auto\">\n            Buy Now\n          </button>\n          <button class=\"btn @lg:text-sm @lg:px-3 @lg:mt-0 mt-2 w-full @lg:w-auto\">\n            Details\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>"
      },
      {
        "language": "html",
        "content": "<!-- Size variants -->\n<h1 class=\"text-shadow-2xs\">Subtle shadow</h1>\n<h1 class=\"text-shadow-xs\">Small shadow</h1>\n<h1 class=\"text-shadow-sm\">Small shadow</h1>\n<h1 class=\"text-shadow-md\">Medium shadow</h1>\n<h1 class=\"text-shadow-lg\">Large shadow</h1>\n\n<!-- Colored shadows -->\n<h1 class=\"text-shadow-lg text-shadow-blue-500/30\">Blue glow effect</h1>\n<h1 class=\"text-shadow-md text-shadow-white/70\">Subtle white highlight</h1>\n\n<!-- Embossed effect -->\n<button class=\"text-gray-900 text-shadow-sm text-shadow-white/60 bg-gray-100\">\n  Embossed Button\n</button>\n\n<!-- Opacity modifiers -->\n<h1 class=\"text-shadow-xl/20\">20% opacity shadow</h1>\n<h1 class=\"text-shadow-lg/50\">50% opacity shadow</h1>"
      },
      {
        "language": "html",
        "content": "<!-- Fade image edges -->\n<img src=\"hero.jpg\" \n     class=\"mask-t-from-50% mask-b-to-0% w-full h-64 object-cover\" \n     alt=\"Fading hero image\" />\n\n<!-- Radial spotlight effect -->\n<div class=\"mask-radial-from-70% mask-radial-to-90% \n            bg-gradient-to-r from-purple-500 to-blue-500 \n            p-12 text-center text-white\">\n  <h2 class=\"text-3xl font-bold\">Spotlight Content</h2>\n</div>\n\n<!-- Complex combined masks -->\n<div class=\"mask-b-from-80% mask-r-from-80% \n            mask-radial-from-60% mask-radial-to-85%\n            bg-cover bg-center h-96\"\n     style=\"background-image: url('/landscape.jpg')\">\n  <div class=\"p-8 text-white\">\n    Content with multiple mask layers\n  </div>\n</div>\n\n<!-- Linear gradient masks -->\n<div class=\"mask-l-from-50% mask-l-to-90% mask-r-from-30%\">\n  Masked on left and right edges\n</div>"
      },
      {
        "language": "html",
        "content": "<!-- Touch-optimized controls -->\n<button class=\"px-3 py-2 text-sm\n               pointer-coarse:px-6 pointer-coarse:py-4 pointer-coarse:text-base\">\n  Larger touch targets on mobile devices\n</button>\n\n<!-- Precision hover effects for mouse users -->\n<div class=\"transition-all duration-200\n            pointer-fine:hover:scale-105 pointer-fine:hover:shadow-lg\n            pointer-coarse:active:scale-95\">\n  Hover effects only for precise pointing devices\n</div>\n\n<!-- Different layouts for different input types -->\n<nav class=\"flex space-x-2\n            pointer-coarse:flex-col pointer-coarse:space-x-0 pointer-coarse:space-y-3\n            pointer-coarse:p-4\">\n  <a href=\"#\" class=\"nav-link pointer-coarse:text-lg pointer-coarse:py-3\">Home</a>\n  <a href=\"#\" class=\"nav-link pointer-coarse:text-lg pointer-coarse:py-3\">About</a>\n</nav>\n\n<!-- Hybrid device support with any-pointer */\n<div class=\"any-pointer-coarse:pb-safe-area-inset-bottom\">\n  Adapts to any touch capability\n</div>"
      },
      {
        "language": "html",
        "content": "<!-- Navigation that stays accessible -->\n<nav class=\"flex justify-center-safe gap-6 px-4 py-2\">\n  <a href=\"#\" class=\"nav-link\">Home</a>\n  <a href=\"#\" class=\"nav-link\">Products</a>\n  <a href=\"#\" class=\"nav-link\">Services</a>\n  <a href=\"#\" class=\"nav-link\">About</a>\n  <a href=\"#\" class=\"nav-link\">Contact</a>\n  <!-- On narrow screens, aligns left instead of hiding content -->\n</nav>\n\n<!-- Centered dialog that remains visible -->\n<div class=\"fixed inset-0 flex items-center-safe justify-center-safe p-4\">\n  <div class=\"bg-white rounded-lg shadow-xl max-w-md w-full p-6\">\n    <h2>Modal content always visible</h2>\n    <p>Even when content is larger than viewport</p>\n  </div>\n</div>\n\n<!-- Safe grid alignment */\n<div class=\"grid place-items-center-safe min-h-screen p-4\">\n  <div class=\"content-box\">\n    Content stays visible even when overflowing\n  </div>\n</div>"
      },
      {
        "language": "html",
        "content": "<!-- Prevent layout breaking from long words -->\n<div class=\"wrap-break-word max-w-sm p-4 bg-gray-100\">\n  supercalifragilisticexpialidocioussupercalifragilisticexpialidocious\n</div>\n\n<!-- More aggressive wrapping for flex containers -->\n<div class=\"flex items-center space-x-3\">\n  <img src=\"/avatar.jpg\" class=\"w-12 h-12 rounded-full flex-shrink-0\" />\n  <div class=\"wrap-anywhere flex-1 min-w-0\">\n    <h3 class=\"font-medium\">Very Long Name That Might Break Layout</h3>\n    <p class=\"text-sm text-gray-600\">\n      verylongemailaddress@verylongcompanyname.com\n    </p>\n  </div>\n</div>"
      },
      {
        "language": "html",
        "content": "<div class=\"flex items-baseline-last gap-4\">\n  <div>\n    <h4 class=\"font-semibold text-lg\">Spencer Sharp</h4>\n    <p class=\"text-sm text-gray-600\">\n      Working on the future of astronaut recruitment at Space Recruit.\n      Building amazing experiences for space exploration teams.\n    </p>\n  </div>\n  <a href=\"#\" class=\"text-blue-600 text-sm\">\n    Visit Profile\n  </a>\n</div>"
      },
      {
        "language": "html",
        "content": "<!-- Colored filter shadows -->\n<svg class=\"w-16 h-16 fill-cyan-500 drop-shadow-xl drop-shadow-cyan-500/50\">\n  <!-- SVG content -->\n</svg>\n\n<img src=\"/icon.png\" \n     class=\"w-20 h-20 drop-shadow-lg drop-shadow-purple-500/40\" \n     alt=\"Glowing icon\" />"
      },
      {
        "language": "html",
        "content": "<!-- No JavaScript fallback -->\n<div class=\"hidden noscript:block p-4 bg-yellow-50 border border-yellow-200\">\n  <p>Please enable JavaScript for the best experience.</p>\n</div>\n\n<!-- Better form validation states -->\n<input type=\"email\" \n       required \n       class=\"border border-gray-300 \n              user-invalid:border-red-500 user-invalid:ring-1 user-invalid:ring-red-500\n              user-valid:border-green-500 user-valid:ring-1 user-valid:ring-green-500\" />\n\n<!-- Inverted colors support -->\n<div class=\"shadow-xl inverted-colors:shadow-none bg-white inverted-colors:bg-transparent\">\n  Content that adapts to inverted color schemes\n</div>\n\n<!-- Details/summary content styling -->\n<details class=\"border rounded-lg p-4 details-content:pt-4 details-content:border-t\">\n  <summary class=\"font-medium cursor-pointer\">Click to expand</summary>\n  <div class=\"mt-3 text-gray-600\">\n    Content area that can be styled independently\n  </div>\n</details>"
      },
      {
        "language": "css",
        "content": "@import \"tailwindcss\";\n\n/* Simple custom utility */\n@utility scrollbar-hidden {\n  scrollbar-width: none;\n  &::-webkit-scrollbar {\n    display: none;\n  }\n}\n\n/* Complex glass morphism utility */\n@utility glass {\n  backdrop-filter: blur(12px) saturate(190%) contrast(70%) brightness(80%);\n  background: rgba(255, 255, 255, 0.09);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px;\n}\n\n/* Utility with pseudo-elements */\n@utility focus-ring {\n  &:focus-visible {\n    outline: 2px solid theme(--color-blue-500);\n    outline-offset: 2px;\n    border-radius: theme(--radius-md);\n  }\n}\n\n/* Animation utility */\n@utility animate-wiggle {\n  animation: wiggle 1s ease-in-out infinite;\n  \n  @keyframes wiggle {\n    0%, 100% { transform: rotate(-3deg); }\n    50% { transform: rotate(3deg); }\n  }\n}"
      },
      {
        "language": "css",
        "content": "/* Media query variants */\n@variant reduced-motion (@media (prefers-reduced-motion: reduce));\n@variant high-contrast (@media (prefers-contrast: high));\n@variant portrait (@media (orientation: portrait));\n@variant print (@media print);\n\n/* Selector-based variants */\n@variant theme-dark (&:where([data-theme=\"dark\"] *));\n@variant loading (&[data-loading=\"true\"]);\n@variant invalid (&:invalid);\n\n/* Combined complex variants */\n@variant group-focus-within (&:where(.group:focus-within *));\n@variant peer-checked (&:where(.peer:checked ~ *));"
      },
      {
        "language": "css",
        "content": "@import \"tailwindcss\";\n\n@theme {\n  /* Centralized design system */\n  --color-brand: oklch(0.64 0.24 220);\n  --font-display: \"Inter\", sans-serif;\n  --spacing: 0.25rem;\n}"
      },
      {
        "language": "css",
        "content": "@layer base {\n  /* HTML element defaults */\n  body { @apply font-sans; }\n}\n\n@layer components {\n  /* Reusable patterns */\n  .btn { @apply px-4 py-2 rounded; }\n}\n\n@layer utilities {\n  /* Custom utilities */\n  .text-shadow-glow { text-shadow: 0 0 10px currentColor; }\n}"
      },
      {
        "language": "html",
        "content": "<div class=\"@container\">\n  <div class=\"@md:flex @md:items-center\">\n    <!-- Responds to container, not viewport -->\n  </div>\n</div>"
      },
      {
        "language": "css",
        "content": "@theme {\n  /* OKLCH for vivid colors */\n  --color-electric: oklch(0.72 0.25 320);\n  /* CSS variables for runtime flexibility */\n  --color-primary: var(--color-brand);\n}"
      },
      {
        "language": "css",
        "content": "/* ‚ùå Old v3 syntax */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n/* ‚úÖ New v4.1 syntax */\n@import \"tailwindcss\";"
      },
      {
        "language": "css",
        "content": "/* ‚ùå Unclear precedence */\n.my-component {\n  background: blue !important;\n}\n\n/* ‚úÖ Use layers properly */\n@layer components {\n  .my-component {\n    @apply bg-blue-500;\n  }\n}"
      },
      {
        "language": "html",
        "content": "<!-- ‚ùå Viewport-only thinking -->\n<div class=\"md:flex\">\n  <!-- Always responds to viewport -->\n</div>\n\n<!-- ‚úÖ Container-aware design -->\n<div class=\"@container\">\n  <div class=\"@md:flex\">\n    <!-- Responds to available space -->\n  </div>\n</div>"
      },
      {
        "language": "css",
        "content": "/* In custom CSS */\n.custom-component {\n  background: var(--color-brand-500);\n  font-family: var(--font-display);\n  border-radius: var(--radius-lg);\n  box-shadow: var(--shadow-glow);\n  animation: var(--animate-slide);\n}\n\n/* With calc() for dynamic values */\n.responsive-spacing {\n  padding: calc(var(--spacing) * 4);\n  margin: calc(var(--spacing) * 2);\n}"
      },
      {
        "language": "jsx",
        "content": "// In React/JavaScript\nfunction ThemedComponent() {\n  return (\n    <div \n      style={{\n        backgroundColor: 'var(--color-brand-500)',\n        borderRadius: 'var(--radius-lg)',\n        padding: 'calc(var(--spacing) * 4)'\n      }}\n    >\n      Runtime theming with CSS variables!\n    </div>\n  );\n}"
      },
      {
        "language": "bash",
        "content": "# For PostCSS users\nnpm install tailwindcss@latest @tailwindcss/postcss@latest\n\n# For Vite users  \nnpm install tailwindcss@latest @tailwindcss/vite@latest\n\n# For CLI users\nnpm install tailwindcss@latest @tailwindcss/cli@latest"
      },
      {
        "language": "bash",
        "content": "npx @tailwindcss/upgrade@latest"
      },
      {
        "language": "css",
        "content": "/* Replace this v3 syntax */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n/* With this v4.1 syntax */\n@import \"tailwindcss\";\n\n@theme {\n  /* Move your theme config here */\n  --color-brand: #3b82f6;\n  --font-display: \"Inter\", sans-serif;\n}"
      },
      {
        "language": "css",
        "content": "@layer base {\n  /* Move base styles here */\n}\n\n@layer components {\n  /* Move component styles here */\n}\n\n@layer utilities {\n  /* Move custom utilities here */\n}"
      },
      {
        "language": "bash",
        "content": "npm create tailwindcss@latest my-project\ncd my-project"
      },
      {
        "language": "css",
        "content": "@import \"tailwindcss\";\n\n@theme {\n  /* Your design system */\n  --color-brand: oklch(0.64 0.24 220);\n  --font-display: \"Inter\", sans-serif;\n  --spacing: 0.25rem;\n  --breakpoint-3xl: 1920px;\n}\n\n@layer base {\n  html {\n    @apply antialiased scroll-smooth;\n  }\n}\n\n@layer components {\n  .btn {\n    @apply px-4 py-2 rounded font-medium transition-colors;\n  }\n}"
      },
      {
        "language": "html",
        "content": "<div class=\"@container\">\n  <div class=\"@md:flex @md:items-center space-y-4 @md:space-y-0 @md:space-x-6\">\n    <h1 class=\"text-3xl @lg:text-4xl font-display text-shadow-sm\">\n      Modern Tailwind v4.1!\n    </h1>\n    <button class=\"btn bg-brand-500 text-white pointer-coarse:px-6 pointer-coarse:py-4\">\n      Get Started\n    </button>\n  </div>\n</div>"
      }
    ],
    "keyTerms": [
      "about",
      "accessible",
      "actions",
      "active",
      "adapts",
      "admin",
      "advanced",
      "after",
      "aggressive",
      "align",
      "alignment",
      "aligns",
      "alt",
      "always",
      "amazing",
      "animate-slide",
      "animate-wiggle",
      "animation",
      "animations",
      "anti-patterns",
      "antialiased",
      "any-pointer",
      "any-pointer-coarse",
      "anywhere",
      "apis",
      "appear",
      "apply",
      "approach",
      "area",
      "article",
      "aside",
      "astronaut",
      "automatic",
      "automatically",
      "available",
      "avatar",
      "avoid",
      "backdrop-filter",
      "background",
      "background-image",
      "backgroundcolor",
      "base",
      "based",
      "baseline",
      "basic",
      "battle-tested",
      "beats",
      "become",
      "best",
      "better",
      "bg-blue-500",
      "bg-brand-500",
      "bg-brand-600",
      "bg-brand-700",
      "bg-center",
      "bg-cover",
      "bg-gradient-to-r",
      "bg-gray-100",
      "bg-gray-50",
      "bg-gray-800",
      "bg-gray-900",
      "bg-red-500",
      "bg-transparent",
      "bg-white",
      "bg-yellow-50",
      "block",
      "blue",
      "blur",
      "body",
      "boost",
      "border",
      "border-gray-200",
      "border-gray-300",
      "border-gray-700",
      "border-green-500",
      "border-radius",
      "border-red-500",
      "border-t",
      "border-yellow-200",
      "borderradius",
      "box-shadow",
      "break",
      "breaking",
      "breakpoints",
      "brightness",
      "btn",
      "btn-primary",
      "btn-sm",
      "build",
      "building",
      "builds",
      "built",
      "built-in",
      "bulletproof",
      "button",
      "buy",
      "bypass",
      "calc",
      "capability",
      "card",
      "cascade",
      "cascading",
      "centered",
      "centralized",
      "change",
      "checked",
      "children",
      "clamp",
      "class",
      "classes",
      "cleaner",
      "cli",
      "click",
      "coarse",
      "color",
      "color-blue-500",
      "color-brand-500",
      "color-scheme",
      "colored",
      "colors",
      "com",
      "combined",
      "complete",
      "complex",
      "complexity",
      "component",
      "component-level",
      "components",
      "composable",
      "comprehensive",
      "config",
      "configuration",
      "contact",
      "container",
      "container-aware",
      "containers",
      "content",
      "content-box",
      "contents",
      "contrast",
      "control",
      "controls",
      "core",
      "corresponding",
      "create",
      "creating",
      "creative",
      "critical",
      "css",
      "css-first",
      "currentcolor",
      "cursor-pointer",
      "custom",
      "custom-component",
      "cutting-edge",
      "dark",
      "dashboard",
      "data-loading",
      "data-theme",
      "declaration",
      "deep",
      "default",
      "defaults",
      "dependencies",
      "description",
      "design",
      "desktop-only",
      "details",
      "details-content",
      "determines",
      "developer",
      "device",
      "devices",
      "dialog",
      "different",
      "directive",
      "directly",
      "display",
      "displays",
      "div",
      "dive",
      "doe",
      "don",
      "drop",
      "drop-shadow-cyan-500",
      "drop-shadow-lg",
      "drop-shadow-purple-500",
      "drop-shadow-xl",
      "duration-200",
      "dynamic",
      "ease-in-out",
      "edges",
      "effect",
      "effects",
      "element",
      "eliminates",
      "eliminating",
      "email",
      "embossed",
      "enable",
      "entire",
      "even",
      "every",
      "everything",
      "example",
      "examples",
      "expand",
      "experience",
      "experiences",
      "exploration",
      "fade",
      "fading",
      "fallback",
      "faster",
      "features",
      "file",
      "fill-cyan-500",
      "filter",
      "finally",
      "fixed",
      "flex",
      "flex-1",
      "flex-col",
      "flex-shrink-0",
      "flexibility",
      "fluid",
      "fluid-card",
      "focus",
      "focus-ring",
      "focus-visible",
      "focus-within",
      "follow",
      "font",
      "font-bold",
      "font-display",
      "font-family",
      "font-medium",
      "font-sans",
      "font-semibold",
      "font-size",
      "fonts",
      "form",
      "foundation",
      "from",
      "from-purple-500",
      "full",
      "function",
      "fundamental",
      "future",
      "gamut",
      "gap-4",
      "gap-6",
      "generates",
      "gives",
      "glass",
      "globals",
      "glow",
      "glowing",
      "gradient",
      "grid",
      "grid-cols-1",
      "grid-cols-2",
      "grid-cols-3",
      "grid-cols-4",
      "group",
      "group-focus-within",
      "guide",
      "guidelines",
      "h-12",
      "h-16",
      "h-20",
      "h-32",
      "h-48",
      "h-64",
      "h-96",
      "happens",
      "height",
      "here",
      "hero",
      "hidden",
      "hide",
      "hiding",
      "high",
      "high-contrast",
      "highest",
      "highlight",
      "home",
      "hover",
      "href",
      "html",
      "hybrid",
      "icon",
      "ignore",
      "image",
      "img",
      "import",
      "important",
      "improved",
      "improvements",
      "incremental",
      "independently",
      "infinite",
      "inline",
      "inline-flex",
      "input",
      "inset-0",
      "install",
      "instead",
      "integration",
      "interaction",
      "interfaces",
      "into",
      "introduces",
      "intuitive",
      "invalid",
      "inverted",
      "inverted-colors",
      "items",
      "items-baseline-last",
      "items-center",
      "items-center-safe",
      "javascript",
      "john",
      "jpg",
      "justify-center-safe",
      "keep",
      "keyframes",
      "landscape",
      "large",
      "larger",
      "last",
      "later",
      "latest",
      "layer",
      "layers",
      "layout",
      "layouts",
      "left",
      "leverage",
      "leveraging",
      "light",
      "like",
      "line",
      "linear",
      "loading",
      "long",
      "long-awaited",
      "main",
      "maintainable",
      "margin",
      "mark",
      "mask",
      "mask-b-from-80",
      "mask-b-to-0",
      "mask-l-from-50",
      "mask-l-to-90",
      "mask-r-from-30",
      "mask-r-from-80",
      "mask-radial-from-60",
      "mask-radial-from-70",
      "mask-radial-to-85",
      "mask-radial-to-90",
      "mask-t-from-50",
      "masked",
      "masking",
      "masks",
      "master",
      "mastery",
      "max-lg",
      "max-sm",
      "max-w-md",
      "max-w-sm",
      "max-width",
      "media",
      "medium",
      "methods",
      "might",
      "migration",
      "min-h-screen",
      "min-height",
      "min-md",
      "min-w-0",
      "mix",
      "mobile",
      "modal",
      "modern",
      "modifiers",
      "more",
      "morphism",
      "most",
      "mouse",
      "move",
      "mt-0",
      "mt-1",
      "mt-2",
      "mt-3",
      "mt-4",
      "multiple",
      "mx-auto",
      "my-component",
      "my-project",
      "name",
      "named",
      "namespace",
      "namespaces",
      "narrow",
      "native",
      "nav",
      "nav-link",
      "navigation",
      "need",
      "needed",
      "none",
      "normal",
      "noscript",
      "npm",
      "npx",
      "object-cover",
      "oklch",
      "only",
      "opacity",
      "optimization",
      "order",
      "organization",
      "organize",
      "orientation",
      "outline",
      "outline-2",
      "outline-blue-500",
      "outline-hidden",
      "outline-offset",
      "outline-offset-2",
      "over",
      "overflow",
      "overflowing",
      "overflows",
      "override",
      "p-12",
      "p-4",
      "p-6",
      "p-8",
      "padding",
      "patterns",
      "pb-safe-area-inset-bottom",
      "peer",
      "peer-checked",
      "perfect",
      "performance",
      "picture",
      "place-items-center-safe",
      "please",
      "plugins",
      "png",
      "pointer",
      "pointer-coarse",
      "pointer-fine",
      "pointing",
      "portrait",
      "postcss",
      "powerful",
      "practices",
      "precedence",
      "precise",
      "precision",
      "predictable",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefixing",
      "prevent",
      "print",
      "priority",
      "product",
      "products",
      "profile",
      "project",
      "projects",
      "proper",
      "properly",
      "prose",
      "prose-lg",
      "prose-xl",
      "provide",
      "pseudo-elements",
      "pt-4",
      "purposes",
      "px-3",
      "px-4",
      "px-6",
      "py-2",
      "py-3",
      "py-4",
      "queries",
      "query",
      "quick",
      "radial",
      "radius-lg",
      "radius-md",
      "range",
      "real-world",
      "recommended",
      "recruit",
      "recruitment",
      "red",
      "reduce",
      "reduced-motion",
      "reference",
      "references",
      "regardless",
      "remains",
      "remove",
      "reorganizes",
      "replace",
      "represents",
      "requests",
      "required",
      "resets",
      "reshapes",
      "resizable",
      "respond",
      "responds",
      "responsive",
      "responsive-grid",
      "responsive-spacing",
      "responsiveness",
      "return",
      "reusable",
      "revolution",
      "revolutionary",
      "rgba",
      "right",
      "ring-1",
      "ring-2",
      "ring-blue-500",
      "ring-green-500",
      "ring-red-500",
      "root",
      "rotate",
      "rounded",
      "rounded-full",
      "rounded-lg",
      "rounded-md",
      "rules",
      "runtime",
      "safe",
      "same",
      "saturate",
      "scale",
      "scale-105",
      "scale-95",
      "scales",
      "scaling",
      "schemes",
      "screens",
      "scroll-smooth",
      "scrollbar",
      "scrollbar-hidden",
      "scrollbar-width",
      "selector-based",
      "services",
      "sets",
      "settings",
      "setup",
      "shadow",
      "shadow-glow",
      "shadow-lg",
      "shadow-md",
      "shadow-none",
      "shadow-xl",
      "shadows",
      "sharp",
      "shift",
      "should",
      "show",
      "sidebar",
      "simple",
      "size",
      "small",
      "solid",
      "space",
      "space-x-0",
      "space-x-2",
      "space-x-3",
      "space-x-4",
      "space-x-6",
      "space-y-0",
      "space-y-2",
      "space-y-3",
      "space-y-4",
      "spacing",
      "specific",
      "specifically",
      "specificity",
      "spencer",
      "spotlight",
      "src",
      "start",
      "started",
      "states",
      "stays",
      "structure",
      "stunning",
      "style",
      "styled",
      "styles",
      "styling",
      "subtle",
      "summary",
      "supercalifragilisticexpialidocioussupercalifragilisticexpialidocious",
      "support",
      "svg",
      "switches",
      "syntax",
      "system",
      "table",
      "tailwind",
      "tailwindcss",
      "targets",
      "teams",
      "techniques",
      "text",
      "text-3xl",
      "text-4xl",
      "text-base",
      "text-blue-600",
      "text-center",
      "text-gray-100",
      "text-gray-600",
      "text-gray-900",
      "text-left",
      "text-lg",
      "text-shadow",
      "text-shadow-2xs",
      "text-shadow-blue-500",
      "text-shadow-glow",
      "text-shadow-lg",
      "text-shadow-md",
      "text-shadow-sm",
      "text-shadow-soft",
      "text-shadow-white",
      "text-shadow-xl",
      "text-shadow-xs",
      "text-sm",
      "text-white",
      "text-xl",
      "text-xs",
      "than",
      "that",
      "theme",
      "theme-dark",
      "themedcomponent",
      "theming",
      "thinking",
      "though",
      "timing",
      "to-blue-500",
      "token",
      "tokens",
      "tool",
      "touch",
      "touch-optimized",
      "transform",
      "transition-all",
      "transition-colors",
      "transpilation",
      "true",
      "type",
      "types",
      "typography",
      "unclear",
      "understanding",
      "units",
      "update",
      "upgrade",
      "upgrading",
      "url",
      "user",
      "user-invalid",
      "user-valid",
      "users",
      "uses",
      "using",
      "utilities",
      "utility",
      "utility-first",
      "validation",
      "values",
      "var",
      "variable",
      "variables",
      "variant",
      "variants",
      "vendor",
      "very",
      "verylongcompanyname",
      "verylongemailaddress",
      "viewport",
      "viewport-only",
      "visible",
      "visit",
      "visual",
      "vite",
      "vivid",
      "w-12",
      "w-16",
      "w-20",
      "w-32",
      "w-64",
      "w-80",
      "w-auto",
      "w-full",
      "web",
      "webkit-scrollbar",
      "when",
      "where",
      "white",
      "wider",
      "widget",
      "width",
      "wiggle",
      "will",
      "win",
      "with",
      "within",
      "without",
      "words",
      "working",
      "wrap-anywhere",
      "wrap-break-word",
      "wrapping",
      "years",
      "your"
    ],
    "notations": [
      "(\n    <div \n      style={{\n        backgroundColor: 'var(--color-brand-500)",
      "(&:invalid)",
      "(&:where(.group:focus-within *)",
      "(&:where(.peer:checked ~ *)",
      "(&:where([data-theme=\"dark\"] *)",
      "(&[data-loading=\"true\"])",
      "('/landscape.jpg')",
      "(--animate-slide)",
      "(--color-blue-500)",
      "(--color-brand-500)",
      "(--font-display)",
      "(--radius-lg)",
      "(--radius-md)",
      "(--shadow-glow)",
      "(--text-shadow-soft)",
      "(-3deg)",
      "(0, 0, 0, 0.1)",
      "(12px)",
      "(142, 142, 142, 0.19)",
      "(190%)",
      "(1rem, 4cqi, 3rem)",
      "(255, 255, 255, 0.09)",
      "(255, 255, 255, 0.2)",
      "(3deg)",
      "(70%)",
      "(80%)",
      "(@media (orientation: portrait)",
      "(@media (pointer: coarse)",
      "(@media (prefers-contrast: high)",
      "(@media (prefers-reduced-motion: reduce)",
      "(@media print)",
      "(Finally!)",
      "(Highest Priority)",
      "(var(--spacing)",
      "P3",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "v3",
      "v4"
    ],
    "categories": [
      "tailwind"
    ],
    "leetcodeProblems": []
  },
  "test": {
    "title": "Tic Tac Toe",
    "route": "/notes/test",
    "filePath": "app/notes/test/page.mdx",
    "headings": [
      "Tic Tac Toe",
      "Resizable Table Of Contents",
      "The Goal: Adversarial Search",
      "Minimax: Finding the Optimal Move",
      "How It Works",
      "Alpha-Beta Pruning: Making Minimax Smarter üß†",
      "The Pruning Logic",
      "Code Implementation"
    ],
    "text": "This tutorial will guide you through creating an unbeatable Tic-Tac-Toe AI. We'll start with the core logic called  Minimax  and then optimize it with a technique called  Alpha-Beta Pruning .  In a two-player game like Tic-Tac-Toe, each player's goal is contrary to their opponent's.\n $X$  wants to win, and  $O$  wants to win. This is an  adversarial  setting. Our goal is to write an AI that can look ahead at all possible moves and choose the one that leads to the best possible outcome for itself, assuming the opponent also plays perfectly. This process is called  adversarial search .  The provided Python code gives us all the tools we need:  [python:]initial_state() : Creates a new, empty board.  [python:]player(board) : Tells us whose turn it is ('X' or 'O').  [python:]actions(board) : Gives us all legal moves (empty squares).  [python:]result(board, action) : Shows the board  after  a move is made.  [python:]terminal(board) : Checks if the game is over (win, lose, or tie).  [python:]utility(board) : Assigns a score to a finished game:  1  for an X win,  -1  for an O win, and  0  for a tie. This function is crucial, as it defines what \"good\" and \"bad\" outcomes are for our AI.  The Minimax algorithm is a decision-making algorithm that explores every possible move to find the optimal one. It operates on two key principles:  The Maximizer:  Player  $X$  is the  maximizer . Their goal is to pick the move that leads to a game state with the highest possible  [python:utility(board):]utility  score.  The Minimizer:  Player  $O$  is the  minimizer . Their goal is to pick the move that leads to a game state with the lowest possible\n [tooltip:utility(board):]utility  score.  Imagine the game as a tree. The current board state is the root. Each possible action branches out to a new state (a child node). This continues until we reach terminal states (leaves), where the game is over.  The algorithm works by recursively calculating the \"minimax value\" of each state in the tree:  For a  terminal state , the value is simply its utility ( 1 ,  -1 , or  0 ).  For a state where it's  X's turn (Maximizer) , its value is the  maximum  value of all the states it can move to.  For a state where it's  O's turn (Minimizer) , its value is the  minimum  value of all the states it can move to.  The AI then simply chooses the action that leads to the state with the best value (max for X, min for O).  The problem? Exploring this entire tree, even for Tic-Tac-Toe, is computationally expensive. For more complex games like chess, it's impossible. This brings us to a much-needed optimization.  Alpha-Beta Pruning is an optimization technique for the Minimax algorithm that allows us to disregard, or  \"prune\" , large parts of the game tree. It returns the exact same move as Minimax but does so much faster by not exploring branches that it knows can't influence the final decision.  To do this, we introduce two new values:  Alpha ( ) : The best score (highest value) found so far\nfor the  Maximizer . The Maximizer will always aim for a score of  at least   . It starts at  .  Beta ( ) : The best score (lowest value) found so far for the  Minimizer .\nThe Minimizer will always aim for a score of  at most   . It starts at  .  As the algorithm explores the tree, it constantly updates   and  . The key insight is this:  We can stop evaluating a branch as soon as  .  Let's see why:  Maximizer's Pruning:  The Maximizer is exploring a move. If it finds that this path leads to a score that is greater than or equal to   (the best the Minimizer can currently hope for), the Maximizer can stop looking down this path. Why? Because the parent Minimizer (who is trying to get the  lowest  score) will never let the game proceed down this branch, as they already have a better option available that results in a score of   or less.  Minimizer's Pruning:  The same logic applies in reverse. If the Minimizer finds a path leading to a score less than or equal to  , it can stop. The parent Maximizer already has a better option guaranteeing them a score of   or more.  Now, let's analyze the provided  minimax  function, which brilliantly implements Alpha-Beta Pruning.  def minimax(board):\n    if terminal(board):\n        return None\n    def max_value(b, Œ±, Œ≤):\n        if terminal(b):\n            return utility(b), None\n        v, mv = float(\"-inf\"), None\n        for a in actions(b):\n            val, _ = min_value(result(b, a), Œ±, Œ≤)\n            if val > v:\n                v, mv = val, a\n                Œ± = max(Œ±, v)\n            if Œ± >= Œ≤:\n                break # Stop searching this branch\n        return v, mv\n    def min_value(b, Œ±, Œ≤):\n        if terminal(b):\n            return utility(b), None\n        v, mv = float(\"inf\"), None\n        for a in actions(b):\n            val, _ = max_value(result(b, a), Œ±, Œ≤)\n            if val < v:\n                v, mv = val, a\n                Œ≤ = min(Œ≤, v)\n            if Œ± >= Œ≤:\n                break # Stop searching this branch\n        return v, mv\n    _, move = (\n        max_value(board, float(\"-inf\"), float(\"inf\"))\n        if player(board) == X\n        else min_value(board, float(\"-inf\"), float(\"inf\"))\n    )\n    return move Key parts of the code:  max_value  and  min_value :  These two functions call each other recursively, simulating the alternating turns of the Maximizer and Minimizer.  Passing  Œ±  and  Œ≤ :  Notice how  Œ±  and  Œ≤  are passed down through each recursive call. This ensures that the \"best-so-far\" scores are known at every level of the tree.  Updating  Œ±  and  Œ≤ :  In  max_value ,  Œ±  is updated whenever a better move for the Maximizer is found ( Œ± = max(Œ±, v) ). In  min_value ,  Œ≤  is updated for the Minimizer ( Œ≤ = min(Œ≤, v) ).  The Pruning Condition:  The line  if Œ± >= Œ≤: break  is the heart of the optimization. It saves a massive amount of computation by cutting off branches that are guaranteed to be worse than a move that has already been found.  By using this algorithm, our Tic-Tac-Toe AI can quickly and efficiently determine the mathematically optimal move from any given board state, making it an unbeatable opponent.",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "def minimax(board):\n    \"\"\"\n    Returns the optimal action for the current player on the board.\n    \"\"\"\n    \n    # Base case: if game is over, no moves are possible\n    if terminal(board):\n        return None\n\n    # The Maximizer wants to find the action 'a' that maximizes the score\n    def max_value(b, Œ±, Œ≤):\n        if terminal(b):\n            return utility(b), None\n        \n        v, mv = float(\"-inf\"), None\n        for a in actions(b):\n            # Get the score from the minimizer's perspective\n            val, _ = min_value(result(b, a), Œ±, Œ≤)\n            if val > v:\n                v, mv = val, a\n                # Update alpha: we found a better path for the maximizer\n                Œ± = max(Œ±, v)\n            \n            # The Pruning Step!\n            if Œ± >= Œ≤:\n                break # Stop searching this branch\n        return v, mv\n\n    # The Minimizer wants to find the action 'a' that minimizes the score\n    def min_value(b, Œ±, Œ≤):\n        if terminal(b):\n            return utility(b), None\n\n        v, mv = float(\"inf\"), None\n        for a in actions(b):\n            # Get the score from the maximizer's perspective\n            val, _ = max_value(result(b, a), Œ±, Œ≤)\n            if val < v:\n                v, mv = val, a\n                # Update beta: we found a better path for the minimizer\n                Œ≤ = min(Œ≤, v)\n            \n            # The Pruning Step!\n            if Œ± >= Œ≤:\n                break # Stop searching this branch\n        return v, mv\n\n    # Initial call: determine if the current player is X or O\n    # and start the appropriate recursive chain with initial alpha and beta.\n    _, move = (\n        max_value(board, float(\"-inf\"), float(\"inf\"))\n        if player(board) == X\n        else min_value(board, float(\"-inf\"), float(\"inf\"))\n    )\n    return move"
      }
    ],
    "keyTerms": [
      "action",
      "actions",
      "adversarial",
      "after",
      "ahead",
      "aim",
      "algorithm",
      "allows",
      "alpha",
      "alpha-beta",
      "already",
      "also",
      "alternating",
      "always",
      "amount",
      "analyze",
      "applies",
      "assigns",
      "assuming",
      "available",
      "bad",
      "because",
      "been",
      "best",
      "best-so-far",
      "beta",
      "better",
      "board",
      "branch",
      "branches",
      "break",
      "brilliantly",
      "brings",
      "calculating",
      "call",
      "called",
      "checks",
      "chess",
      "child",
      "choose",
      "chooses",
      "code",
      "complex",
      "computation",
      "computationally",
      "condition",
      "constantly",
      "contents",
      "continues",
      "contrary",
      "core",
      "creates",
      "creating",
      "crucial",
      "current",
      "currently",
      "cutting",
      "decision",
      "decision-making",
      "def",
      "defines",
      "determine",
      "disregard",
      "does",
      "down",
      "each",
      "efficiently",
      "else",
      "empty",
      "ensures",
      "entire",
      "equal",
      "evaluating",
      "even",
      "every",
      "exact",
      "expensive",
      "explores",
      "exploring",
      "far",
      "faster",
      "final",
      "find",
      "finding",
      "finds",
      "finished",
      "float",
      "found",
      "from",
      "function",
      "functions",
      "game",
      "games",
      "given",
      "gives",
      "goal",
      "good",
      "greater",
      "guaranteed",
      "guaranteeing",
      "guide",
      "have",
      "heart",
      "highest",
      "hope",
      "imagine",
      "implementation",
      "implements",
      "impossible",
      "inf",
      "influence",
      "initial_state",
      "insight",
      "introduce",
      "itself",
      "key",
      "known",
      "knows",
      "large",
      "leading",
      "leads",
      "least",
      "leaves",
      "legal",
      "less",
      "level",
      "like",
      "line",
      "logic",
      "look",
      "looking",
      "lose",
      "lowest",
      "made",
      "making",
      "massive",
      "mathematically",
      "max",
      "max_value",
      "maximizer",
      "maximum",
      "min",
      "min_value",
      "minimax",
      "minimizer",
      "minimum",
      "more",
      "most",
      "move",
      "moves",
      "much",
      "much-needed",
      "need",
      "never",
      "node",
      "none",
      "notice",
      "operates",
      "opponent",
      "optimal",
      "optimization",
      "optimize",
      "option",
      "other",
      "outcome",
      "outcomes",
      "over",
      "parent",
      "parts",
      "passed",
      "passing",
      "path",
      "perfectly",
      "pick",
      "player",
      "plays",
      "possible",
      "principles",
      "problem",
      "proceed",
      "process",
      "provided",
      "prune",
      "pruning",
      "python",
      "quickly",
      "reach",
      "recursive",
      "recursively",
      "resizable",
      "result",
      "results",
      "return",
      "returns",
      "reverse",
      "root",
      "same",
      "saves",
      "score",
      "scores",
      "search",
      "searching",
      "setting",
      "shows",
      "simply",
      "simulating",
      "smarter",
      "soon",
      "squares",
      "start",
      "starts",
      "state",
      "states",
      "stop",
      "table",
      "tac",
      "technique",
      "tells",
      "terminal",
      "than",
      "that",
      "their",
      "them",
      "then",
      "these",
      "they",
      "through",
      "tic",
      "tic-tac-toe",
      "tie",
      "toe",
      "tools",
      "tooltip",
      "tree",
      "trying",
      "turn",
      "turns",
      "tutorial",
      "two-player",
      "unbeatable",
      "until",
      "updated",
      "updates",
      "updating",
      "using",
      "utility",
      "val",
      "value",
      "values",
      "wants",
      "what",
      "whenever",
      "where",
      "which",
      "whose",
      "will",
      "win",
      "with",
      "works",
      "worse",
      "write"
    ],
    "notations": [
      "(\n        max_value(board, float(\"-inf\")",
      "( )",
      "( 1 ,  -1 , or  0 )",
      "( Œ± = max(Œ±, v)",
      "( Œ≤ = min(Œ≤, v)",
      "(\"-inf\")",
      "(\"inf\")",
      "('X' or 'O')",
      "(Maximizer)",
      "(Minimizer)",
      "(a child node)",
      "(b)",
      "(b, Œ±, Œ≤)",
      "(board)",
      "(board, action)",
      "(board, float(\"-inf\")",
      "(empty squares)",
      "(highest value)",
      "(leaves)",
      "(lowest value)",
      "(max for X, min for O)",
      "(result(b, a)",
      "(the best the Minimizer can currently hope for)",
      "(who is trying to get the  lowest  score)",
      "(win, lose, or tie)",
      "(Œ±, v)",
      "(Œ≤, v)",
      "O$",
      "X$",
      "Œ±",
      "Œ≤"
    ],
    "categories": [
      "test"
    ],
    "leetcodeProblems": []
  },
  "stocks": {
    "title": "Stock",
    "route": "/notes/stocks",
    "filePath": "app/notes/stocks/page.mdx",
    "headings": [
      "Stock",
      "Resizable Table of Contents",
      "Problems",
      "1. Best Time to Buy and Sell Stock",
      "2. Best Time to Buy and Sell Stock II",
      "3. Best Time to Buy and Sell Stock III",
      "3.1 Cost/Profit Tracking",
      "3.2 Hold/Sell States",
      "4. Best Time to Buy and Sell Stock IV",
      "4.1 Reinvested Cost/Profit (DP)",
      "4.2 Buy/Sell State Machine"
    ],
    "text": "Given a list of daily stock prices  prices ; choose one day to buy and a later day to sell for maximum profit.\nReturn the max profit, or  0  if no profit is possible.  121. Best Time to Buy and Sell Stock   [!insight:collapse]  Greedy min-price tracking & correctness  ~ The best profit comes from buying at the lowest price before selling.\nTracking the running minimum ( cost ) ensures we always consider the optimal buy price so far.\nOn each day,  price - cost  is the best profit achievable if selling today;\ntaking  max(profit, price - cost)  checks all valid buy‚Äìsell pairs in one pass,\nguaranteeing correctness with a single scan.  ~  mental movie:  You‚Äôre a treasure hunter crossing a valley.\nAlong the way, you mark the  lowest pit  you‚Äôve descended into, then keep climbing until you find the  highest peak  that comes after it.\nThe tallest climb from that pit to that peak is your profit.  [!timecomplexity:collapse]   Given daily prices  prices ; you may complete multiple transactions (buy ‚Üí sell ‚Üí buy ‚Ä¶) but cannot hold more than one share at a time.\nReturn the maximum total profit.  122. Best Time to Buy and Sell Stock II   [!insight:collapse]  Greedy sum of positive deltas & correctness  Add every upward move: for each  i , if  prices[i] > prices[i-1]  add  prices[i] - prices[i-1]  to profit.\nAny optimal strategy over an increasing run  [low ‚Ä¶ high]  yields profit  high - low  , which equals the sum of daily increases in that run.\nSumming all positive deltas across the array therefore matches the maximum achievable profit in a single pass.  [!timecomplexity:collapse]   Given daily prices  prices ; at most  two  transactions are allowed (cannot overlap). Return the maximum total profit.  123. Best Time to Buy and Sell Stock III   [!insight:collapse]  One pass, two trades  Track the best first trade while also keeping the lowest price to start a second, factoring in the first profit. This links the trades without scanning the list twice.   [!insight:collapse]  State machine  Keep four running amounts:  After buying the first stock  After selling the first stock  After buying the second stock  After selling the second stock  At each price, decide whether to stay in the current state or make the trade that moves to the next. The last state is the answer.  Given daily prices  prices  and an integer  k  (max transactions), return the maximum profit.  188. Best Time to Buy and Sell Stock IV   [!insight:collapse]  DP Intuition ‚Äî Net Buy Cost  Net buy cost for trade  t :   net = price ‚àí profit[t‚àí1]  (your earlier profit can subsidize today‚Äôs buy).  Update per day, per  t=1..k :  first  cost[t] = min(cost[t], net) , then  profit[t] = max(profit[t], price ‚àí cost[t]) .  Why 1-based  t :  guarantees  profit[t‚àí1]  is already finalized when computing  net .  [!timecomplexity:collapse]  $O(nk)$  time,  $O(k)$  space   [!insight:collapse]  State Intuition ‚Äî k Laddered Trades  Maintain  buy[t]  (best cash if holding after  t -th buy) and  sell[t]  (best cash after  t -th sell).  Transitions:  buy[t]=max(buy[t], sell[t-1]-p) ,  sell[t]=max(sell[t], buy[t]+p) .  Answer is  sell[k] ‚Äîbest cash after up to  k  sells.  [!timecomplexity:collapse]  $O(nk)$  time,  $O(k)$  space",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/stocks.py#method:Stock.maxProfit",
        "fileSource": "backend/algorithms/stocks.py",
        "className": "Stock",
        "methodName": "maxProfit"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/stocks.py#method:Stock.maxProfitII",
        "fileSource": "backend/algorithms/stocks.py",
        "className": "Stock",
        "methodName": "maxProfitII"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/stocks.py#method:Stock.maxProfitIII_cost_profit_tracking",
        "fileSource": "backend/algorithms/stocks.py",
        "className": "Stock",
        "methodName": "maxProfitIII_cost_profit_tracking"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/stocks.py#method:Stock.maxProfitIII_hold_sell_states",
        "fileSource": "backend/algorithms/stocks.py",
        "className": "Stock",
        "methodName": "maxProfitIII_hold_sell_states"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/stocks.py#method:Stock.maxProfitIV_dp",
        "fileSource": "backend/algorithms/stocks.py",
        "className": "Stock",
        "methodName": "maxProfitIV_dp"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/stocks.py#method:Stock.maxProfitIV_states",
        "fileSource": "backend/algorithms/stocks.py",
        "className": "Stock",
        "methodName": "maxProfitIV_states"
      }
    ],
    "keyTerms": [
      "achievable",
      "across",
      "after",
      "allowed",
      "along",
      "already",
      "also",
      "always",
      "amounts",
      "answer",
      "array",
      "based",
      "before",
      "best",
      "buy",
      "buying",
      "cannot",
      "cash",
      "checks",
      "choose",
      "climb",
      "climbing",
      "collapse",
      "comes",
      "complete",
      "computing",
      "consider",
      "contents",
      "correctness",
      "cost",
      "crossing",
      "current",
      "daily",
      "decide",
      "deltas",
      "descended",
      "each",
      "earlier",
      "ensures",
      "equals",
      "every",
      "factoring",
      "far",
      "finalized",
      "find",
      "first",
      "four",
      "from",
      "given",
      "greedy",
      "guaranteeing",
      "guarantees",
      "high",
      "highest",
      "hold",
      "holding",
      "hunter",
      "i-1",
      "iii",
      "increases",
      "increasing",
      "insight",
      "integer",
      "into",
      "intuition",
      "keep",
      "keeping",
      "laddered",
      "last",
      "later",
      "links",
      "list",
      "low",
      "lowest",
      "machine",
      "maintain",
      "make",
      "mark",
      "matches",
      "max",
      "maximum",
      "mental",
      "min",
      "min-price",
      "minimum",
      "more",
      "most",
      "move",
      "moves",
      "movie",
      "multiple",
      "net",
      "next",
      "o",
      "optimal",
      "over",
      "overlap",
      "pairs",
      "pass",
      "peak",
      "pit",
      "positive",
      "possible",
      "price",
      "prices",
      "problems",
      "profit",
      "reinvested",
      "resizable",
      "return",
      "running",
      "scan",
      "scanning",
      "second",
      "sell",
      "selling",
      "sells",
      "share",
      "single",
      "space",
      "start",
      "state",
      "states",
      "stay",
      "stock",
      "strategy",
      "subsidize",
      "sum",
      "summing",
      "t-1",
      "table",
      "taking",
      "tallest",
      "than",
      "that",
      "then",
      "therefore",
      "time",
      "timecomplexity",
      "today",
      "total",
      "track",
      "tracking",
      "trade",
      "trades",
      "transactions",
      "transitions",
      "treasure",
      "twice",
      "until",
      "update",
      "upward",
      "valid",
      "valley",
      "when",
      "whether",
      "which",
      "while",
      "with",
      "without",
      "yields",
      "your"
    ],
    "notations": [
      "( cost )",
      "(DP)",
      "(best cash after  t -th sell)",
      "(best cash if holding after  t -th buy)",
      "(buy ‚Üí sell ‚Üí buy ‚Ä¶)",
      "(buy[t], sell[t-1]-p)",
      "(cannot overlap)",
      "(cost[t], net)",
      "(k)",
      "(max transactions)",
      "(nk)",
      "(profit, price - cost)",
      "(profit[t], price ‚àí cost[t])",
      "(sell[t], buy[t]+p)",
      "(your earlier profit can subsidize today‚Äôs buy)",
      "O(k)$",
      "O(nk)$"
    ],
    "categories": [
      "stocks"
    ],
    "leetcodeProblems": [
      {
        "number": "121",
        "name": "Best Time to Buy and Sell Stock",
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
        "section": "1. Best Time to Buy and Sell Stock"
      },
      {
        "number": "122",
        "name": "Best Time to Buy and Sell Stock II",
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/",
        "section": "2. Best Time to Buy and Sell Stock II"
      },
      {
        "number": "123",
        "name": "Best Time to Buy and Sell Stock III",
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/",
        "section": "3. Best Time to Buy and Sell Stock III"
      },
      {
        "number": "188",
        "name": "Best Time to Buy and Sell Stock IV",
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/",
        "section": "4. Best Time to Buy and Sell Stock IV"
      }
    ]
  },
  "tic-tac-toe": {
    "title": "Tic Tac Toe",
    "route": "/notes/tic-tac-toe",
    "filePath": "app/notes/tic-tac-toe/page.mdx",
    "headings": [
      "Tic Tac Toe",
      "Interactive Game",
      "How It Works",
      "Minimax Algorithm",
      "Player Roles",
      "Score Calculation",
      "How Scores Are Determined",
      "Game Tree Structure",
      "Tree Characteristics",
      "Alpha-Beta Pruning",
      "Key Concepts",
      "Example Pruning Scenario",
      "AI Implementation",
      "Algorithm Analysis",
      "Time Complexity",
      "Basic Minimax Algorithm",
      "Optimized Minimax with Alpha-Beta Pruning",
      "With Memoization",
      "Practical Performance Comparison",
      "Game Tree Complexity",
      "Optimization Impact",
      "Move Ordering",
      "Transposition Table (Memoization)",
      "Optimal Implementation",
      "Key Optimizations in the Code",
      "Resizable Table Of Contents"
    ],
    "text": "import TicTacToeGame from '@/components/artificial-intelligence/tic-tac-toe'  An educational implementation of the classic Tic-Tac-Toe game powered by minimax algorithm with alpha-beta pruning. This demonstrates key concepts in artificial intelligence and game theory.  Play against our AI or challenge a friend! The AI uses the minimax algorithm with alpha-beta pruning to make optimal decisions.  The AI implementation uses several key computer science concepts to create an unbeatable opponent:  The minimax algorithm is a recursive decision-making algorithm that explores all possible game outcomes. Here's how it works:  Game Tree Exploration : Starting from the current position, the algorithm simulates every possible move sequence until the game ends  Recursive Evaluation : At each node, the algorithm alternates between maximizing and minimizing players  Backpropagation : Scores bubble up from terminal nodes to help make the optimal decision at the root  Maximizing player (AI) : Tries to maximize the score (get the highest possible value)  Minimizing player (Human) : Assumed to play optimally, minimizing the AI's score  Alternating turns : Each level of the tree represents the opposite player's turn  The scoring system is simple but effective:  +1  = AI wins\n 0  = Draw/Tie\n-1  = Human wins Terminal positions : When the game ends, assign the final score  Recursive scoring : Non-terminal positions get their score from the best child node  Maximizing turn : Choose the child with the highest score  Minimizing turn : Choose the child with the lowest score  The game tree represents all possible game states:  Current Position (AI's turn)\n‚îú‚îÄ‚îÄ Move 1 ‚Üí Human's turn\n‚îÇ   ‚îú‚îÄ‚îÄ Human Move A ‚Üí AI's turn\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AI Move X ‚Üí Score: +1 (AI wins)\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AI Move Y ‚Üí Score: 0 (Draw)\n‚îÇ   ‚îî‚îÄ‚îÄ Human Move B ‚Üí AI's turn\n‚îÇ       ‚îî‚îÄ‚îÄ AI Move Z ‚Üí Score: -1 (Human wins)\n‚îî‚îÄ‚îÄ Move 2 ‚Üí Human's turn\n    ‚îî‚îÄ‚îÄ ... (more branches) Depth : Maximum of 9 moves (empty board to full)  Branching factor : Decreases each level (9, 8, 7, 6... available moves)  Leaves : Terminal game states (win, loss, or draw)  Internal nodes : Intermediate game positions  Alpha-beta pruning dramatically improves performance by cutting off branches that cannot affect the final decision:  Alpha (Œ±) : Best score the maximizing player can guarantee so far  Beta (Œ≤) : Best score the minimizing player can guarantee so far  Pruning condition : When Œ± ‚â• Œ≤, stop exploring this branch  Maximizing node (Œ± = -1, Œ≤ = +‚àû)\n‚îú‚îÄ‚îÄ Child 1 returns score: 0 (Œ± becomes 0)\n‚îú‚îÄ‚îÄ Child 2 \n‚îÇ   ‚îî‚îÄ‚îÄ Minimizing grandchild returns: -2\n‚îÇ   ‚îî‚îÄ‚îÄ Since -2 < Œ± (0), parent will never choose this\n‚îÇ   ‚îî‚îÄ‚îÄ PRUNE remaining grandchildren\n‚îî‚îÄ‚îÄ Child 3... (continue evaluation) This optimization typically reduces the search space by about 50% without affecting the result.  The AI combines minimax with alpha-beta pruning and memoization:  Optimal play : Always finds the best possible move  Efficiency : Pruning eliminates unnecessary calculations  Memoization : Caches previously computed positions  Result : Unbeatable AI that plays perfectly while maintaining good performance  Worst case : O(b^d) where b = branching factor, d = depth  Tic-Tac-Toe specific : O(9!) ‚âà O(362,880) operations  Explanation : Must explore all possible move sequences  Best case : O(b^(d/2)) ‚âà O(9^4.5) ‚âà O(19,683) operations  Average case : O(b^(3d/4)) ‚âà O(9^6.75) ‚âà O(134,217) operations  Worst case : Still O(b^d) when no pruning occurs  First calculation : O(b^(d/2)) for alpha-beta pruning  Subsequent lookups : O(1) for cached positions  Space tradeoff : O(3^9) = O(19,683) memory for position cache  Algorithm                    | Operations | Improvement\nBasic Minimax               | ~362,880   | Baseline\n+ Alpha-Beta Pruning        | ~134,217   | ~63% reduction\n+ Memoization              | ~19,683    | ~95% reduction (amortized) The complete analysis for Tic-Tac-Toe:  State space : 3^9 = 19,683 possible board configurations  Valid positions : ~5,478 (accounting for game rules)  Game tree nodes : ~255,168 in complete search  Average game length : 5-9 moves  Optimal play : Always results in a draw with perfect play  Alpha-beta improvement : Reduces search by ~50-70% on average  Best-first search : Examining likely good moves first improves pruning  Improvement : Up to 90% pruning in best cases  Heuristics : Center moves, corners, then edges for Tic-Tac-Toe  Cache hit rate : ~85% for mid-game positions  Memory usage : ~156KB for full position cache  Speed improvement : 10x faster for repeated positions  Here's the complete optimized minimax implementation with alpha-beta pruning and memoization:  from typing import List, Tuple, Dict, Optional\nfrom enum import Enum\nclass Player(Enum):\n    X = \"X\"\n    O = \"O\"\n    EMPTY = \" \"\nclass TicTacToe:\n    def __init__(self):\n        self.board: List[List[Player]] = [[Player.EMPTY for _ in range(3)] for _ in range(3)]\n        self.memo: Dict[str, int] = {}\n        self.nodes_evaluated = 0\n    def get_board_key(self) -> str:\n        return ''.join(''.join(row) for row in self.board)\n    def is_winner(self, player: Player) -> bool:\n        for i in range(3):\n            if all(self.board[i][j] == player for j in range(3)):\n                return True\n            if all(self.board[j][i] == player for j in range(3)):\n                return True\n        if all(self.board[i][i] == player for i in range(3)):\n            return True\n        if all(self.board[i][2-i] == player for i in range(3)):\n            return True\n        return False\n    def is_board_full(self) -> bool:\n        return all(self.board[i][j] != Player.EMPTY \n                  for i in range(3) for j in range(3))\n    def get_available_moves(self) -> List[Tuple[int, int]]:\n        moves = []\n        for i in range(3):\n            for j in range(3):\n                if self.board[i][j] == Player.EMPTY:\n                    moves.append((i, j))\n        return moves\n    def evaluate_position(self) -> int:\n        if self.is_winner(Player.X):  # AI wins\n            return 1\n        elif self.is_winner(Player.O):  # Human wins\n            return -1\n        else:  # Draw\n            return 0\n    def minimax_alpha_beta(self, depth: int, is_maximizing: bool, \n                          alpha: int = -float('inf'), \n                          beta: int = float('inf')) -> int:\n        self.nodes_evaluated += 1\n        board_key = self.get_board_key()\n        if board_key in self.memo:\n            return self.memo[board_key]\n        if self.is_winner(Player.X):\n            score = 1\n            self.memo[board_key] = score\n            return score\n        elif self.is_winner(Player.O):\n            score = -1\n            self.memo[board_key] = score\n            return score\n        elif self.is_board_full():\n            score = 0\n            self.memo[board_key] = score\n            return score\n        moves = self.get_ordered_moves()\n        if is_maximizing:\n            max_score = -float('inf')\n            for row, col in moves:\n                self.board[row][col] = Player.X\n                score = self.minimax_alpha_beta(depth + 1, False, alpha, beta)\n                self.board[row][col] = Player.EMPTY\n                max_score = max(max_score, score)\n                alpha = max(alpha, score)\n                if beta <= alpha:\n                    break\n            self.memo[board_key] = max_score\n            return max_score\n        else:  # Minimizing player\n            min_score = float('inf')\n            for row, col in moves:\n                self.board[row][col] = Player.O\n                score = self.minimax_alpha_beta(depth + 1, True, alpha, beta)\n                self.board[row][col] = Player.EMPTY\n                min_score = min(min_score, score)\n                beta = min(beta, score)\n                if beta <= alpha:\n                    break\n            self.memo[board_key] = min_score\n            return min_score\n    def get_ordered_moves(self) -> List[Tuple[int, int]]:\n        moves = self.get_available_moves()\n        def move_priority(move: Tuple[int, int]) -> int:\n            row, col = move\n            if row == 1 and col == 1:\n                return 3\n            elif (row, col) in [(0,0), (0,2), (2,0), (2,2)]:\n                return 2\n            else:\n                return 1\n        return sorted(moves, key=move_priority, reverse=True)\n    def get_best_move(self) -> Tuple[int, int]:\n        self.nodes_evaluated = 0\n        best_score = -float('inf')\n        best_move = None\n        for row, col in self.get_ordered_moves():\n            self.board[row][col] = Player.X\n            score = self.minimax_alpha_beta(0, False)\n            self.board[row][col] = Player.EMPTY\n            if score > best_score:\n                best_score = score\n                best_move = (row, col)\n        return best_move\n    def make_move(self, row: int, col: int, player: Player) -> bool:\n        if self.board[row][col] == Player.EMPTY:\n            self.board[row][col] = player\n            return True\n        return False\n    def print_board(self):\n        for i, row in enumerate(self.board):\n            print(f\" {row[0].value} | {row[1].value} | {row[2].value} \")\n            if i < 2:\n                print(\"-----------\")\ndef play_game():\n    game = TicTacToe()\n    current_player = Player.O  # Human starts\n    while True:\n        game.print_board()\n        if current_player == Player.O:  # Human turn\n            try:\n                row = int(input(\"Enter row (0-2): \"))\n                col = int(input(\"Enter col (0-2): \"))\n                if not game.make_move(row, col, Player.O):\n                    print(\"Invalid move! Try again.\")\n                    continue\n            except ValueError:\n                print(\"Invalid input! Enter numbers 0-2.\")\n                continue\n        else:  # AI turn\n            print(\"AI is thinking...\")\n            best_move = game.get_best_move()\n            game.make_move(best_move[0], best_move[1], Player.X)\n            print(f\"AI chose position: {best_move}\")\n            print(f\"Nodes evaluated: {game.nodes_evaluated}\")\n        if game.is_winner(Player.X):\n            game.print_board()\n            print(\"AI wins!\")\n            break\n        elif game.is_winner(Player.O):\n            game.print_board()\n            print(\"Human wins!\")\n            break\n        elif game.is_board_full():\n            game.print_board()\n            print(\"It's a draw!\")\n            break\n        current_player = Player.X if current_player == Player.O else Player.O\nif __name__ == \"__main__\":\n    play_game() Alpha-Beta Pruning : Lines 76-82 and 95-101 implement pruning to eliminate unnecessary branches  Memoization : Uses  self.memo  dictionary to cache previously computed positions  Move Ordering :  get_ordered_moves()  prioritizes center, then corners, then edges for better pruning  Efficient Terminal Checks : Early returns for game-ending positions  Performance Tracking :  nodes_evaluated  counter to measure algorithm efficiency  This implementation typically evaluates only ~5,000-15,000 nodes instead of the theoretical 255,168, achieving the ~95% reduction shown in our complexity analysis.",
    "sections": [],
    "codeBlocks": [
      {
        "language": "text",
        "content": "+1  = AI wins\n 0  = Draw/Tie\n-1  = Human wins"
      },
      {
        "language": "text",
        "content": "\nCurrent Position (AI's turn)\n‚îú‚îÄ‚îÄ Move 1 ‚Üí Human's turn\n‚îÇ   ‚îú‚îÄ‚îÄ Human Move A ‚Üí AI's turn\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AI Move X ‚Üí Score: +1 (AI wins)\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AI Move Y ‚Üí Score: 0 (Draw)\n‚îÇ   ‚îî‚îÄ‚îÄ Human Move B ‚Üí AI's turn\n‚îÇ       ‚îî‚îÄ‚îÄ AI Move Z ‚Üí Score: -1 (Human wins)\n‚îî‚îÄ‚îÄ Move 2 ‚Üí Human's turn\n    ‚îî‚îÄ‚îÄ ... (more branches)\n    "
      },
      {
        "language": "text",
        "content": "Maximizing node (Œ± = -1, Œ≤ = +‚àû)\n‚îú‚îÄ‚îÄ Child 1 returns score: 0 (Œ± becomes 0)\n‚îú‚îÄ‚îÄ Child 2 \n‚îÇ   ‚îî‚îÄ‚îÄ Minimizing grandchild returns: -2\n‚îÇ   ‚îî‚îÄ‚îÄ Since -2 < Œ± (0), parent will never choose this\n‚îÇ   ‚îî‚îÄ‚îÄ PRUNE remaining grandchildren\n‚îî‚îÄ‚îÄ Child 3... (continue evaluation)"
      },
      {
        "language": "text",
        "content": "Algorithm                    | Operations | Improvement\nBasic Minimax               | ~362,880   | Baseline\n+ Alpha-Beta Pruning        | ~134,217   | ~63% reduction\n+ Memoization              | ~19,683    | ~95% reduction (amortized)"
      },
      {
        "language": "python",
        "content": "from typing import List, Tuple, Dict, Optional\nfrom enum import Enum\n\nclass Player(Enum):\n    X = \"X\"\n    O = \"O\"\n    EMPTY = \" \"\n\nclass TicTacToe:\n    def __init__(self):\n        self.board: List[List[Player]] = [[Player.EMPTY for _ in range(3)] for _ in range(3)]\n        self.memo: Dict[str, int] = {}\n        self.nodes_evaluated = 0\n    \n    def get_board_key(self) -> str:\n        \"\"\"Generate unique key for memoization\"\"\"\n        return ''.join(''.join(row) for row in self.board)\n    \n    def is_winner(self, player: Player) -> bool:\n        \"\"\"Check if player has won\"\"\"\n        # Check rows and columns\n        for i in range(3):\n            if all(self.board[i][j] == player for j in range(3)):\n                return True\n            if all(self.board[j][i] == player for j in range(3)):\n                return True\n        \n        # Check diagonals\n        if all(self.board[i][i] == player for i in range(3)):\n            return True\n        if all(self.board[i][2-i] == player for i in range(3)):\n            return True\n        \n        return False\n    \n    def is_board_full(self) -> bool:\n        \"\"\"Check if board is completely filled\"\"\"\n        return all(self.board[i][j] != Player.EMPTY \n                  for i in range(3) for j in range(3))\n    \n    def get_available_moves(self) -> List[Tuple[int, int]]:\n        \"\"\"Get all empty positions\"\"\"\n        moves = []\n        for i in range(3):\n            for j in range(3):\n                if self.board[i][j] == Player.EMPTY:\n                    moves.append((i, j))\n        return moves\n    \n    def evaluate_position(self) -> int:\n        \"\"\"Evaluate terminal position\"\"\"\n        if self.is_winner(Player.X):  # AI wins\n            return 1\n        elif self.is_winner(Player.O):  # Human wins\n            return -1\n        else:  # Draw\n            return 0\n    \n    def minimax_alpha_beta(self, depth: int, is_maximizing: bool, \n                          alpha: int = -float('inf'), \n                          beta: int = float('inf')) -> int:\n        \"\"\"\n        Minimax with alpha-beta pruning and memoization\n        \n        Args:\n            depth: Current search depth\n            is_maximizing: True if maximizing player's turn (AI)\n            alpha: Best score maximizing player can guarantee\n            beta: Best score minimizing player can guarantee\n        \n        Returns:\n            Best score for current position\n        \"\"\"\n        self.nodes_evaluated += 1\n        \n        # Check memoization cache\n        board_key = self.get_board_key()\n        if board_key in self.memo:\n            return self.memo[board_key]\n        \n        # Terminal position check\n        if self.is_winner(Player.X):\n            score = 1\n            self.memo[board_key] = score\n            return score\n        elif self.is_winner(Player.O):\n            score = -1\n            self.memo[board_key] = score\n            return score\n        elif self.is_board_full():\n            score = 0\n            self.memo[board_key] = score\n            return score\n        \n        # Get available moves with ordering heuristic\n        moves = self.get_ordered_moves()\n        \n        if is_maximizing:\n            max_score = -float('inf')\n            for row, col in moves:\n                # Make move\n                self.board[row][col] = Player.X\n                \n                # Recursive call\n                score = self.minimax_alpha_beta(depth + 1, False, alpha, beta)\n                \n                # Undo move\n                self.board[row][col] = Player.EMPTY\n                \n                # Update best score and alpha\n                max_score = max(max_score, score)\n                alpha = max(alpha, score)\n                \n                # Alpha-beta pruning\n                if beta <= alpha:\n                    break\n            \n            self.memo[board_key] = max_score\n            return max_score\n        \n        else:  # Minimizing player\n            min_score = float('inf')\n            for row, col in moves:\n                # Make move\n                self.board[row][col] = Player.O\n                \n                # Recursive call\n                score = self.minimax_alpha_beta(depth + 1, True, alpha, beta)\n                \n                # Undo move\n                self.board[row][col] = Player.EMPTY\n                \n                # Update best score and beta\n                min_score = min(min_score, score)\n                beta = min(beta, score)\n                \n                # Alpha-beta pruning\n                if beta <= alpha:\n                    break\n            \n            self.memo[board_key] = min_score\n            return min_score\n    \n    def get_ordered_moves(self) -> List[Tuple[int, int]]:\n        \"\"\"\n        Order moves for better alpha-beta pruning\n        Priority: center > corners > edges\n        \"\"\"\n        moves = self.get_available_moves()\n        \n        def move_priority(move: Tuple[int, int]) -> int:\n            row, col = move\n            # Center has highest priority\n            if row == 1 and col == 1:\n                return 3\n            # Corners have medium priority\n            elif (row, col) in [(0,0), (0,2), (2,0), (2,2)]:\n                return 2\n            # Edges have lowest priority\n            else:\n                return 1\n        \n        return sorted(moves, key=move_priority, reverse=True)\n    \n    def get_best_move(self) -> Tuple[int, int]:\n        \"\"\"\n        Find optimal move using minimax with alpha-beta pruning\n        \n        Returns:\n            (row, col) of best move\n        \"\"\"\n        self.nodes_evaluated = 0\n        best_score = -float('inf')\n        best_move = None\n        \n        # Try all possible moves\n        for row, col in self.get_ordered_moves():\n            # Make move\n            self.board[row][col] = Player.X\n            \n            # Evaluate position\n            score = self.minimax_alpha_beta(0, False)\n            \n            # Undo move\n            self.board[row][col] = Player.EMPTY\n            \n            # Update best move\n            if score > best_score:\n                best_score = score\n                best_move = (row, col)\n        \n        return best_move\n    \n    def make_move(self, row: int, col: int, player: Player) -> bool:\n        \"\"\"Make a move if position is valid\"\"\"\n        if self.board[row][col] == Player.EMPTY:\n            self.board[row][col] = player\n            return True\n        return False\n    \n    def print_board(self):\n        \"\"\"Print current board state\"\"\"\n        for i, row in enumerate(self.board):\n            print(f\" {row[0].value} | {row[1].value} | {row[2].value} \")\n            if i < 2:\n                print(\"-----------\")\n\n# Usage Example\ndef play_game():\n    game = TicTacToe()\n    current_player = Player.O  # Human starts\n    \n    while True:\n        game.print_board()\n        \n        if current_player == Player.O:  # Human turn\n            try:\n                row = int(input(\"Enter row (0-2): \"))\n                col = int(input(\"Enter col (0-2): \"))\n                if not game.make_move(row, col, Player.O):\n                    print(\"Invalid move! Try again.\")\n                    continue\n            except ValueError:\n                print(\"Invalid input! Enter numbers 0-2.\")\n                continue\n        \n        else:  # AI turn\n            print(\"AI is thinking...\")\n            best_move = game.get_best_move()\n            game.make_move(best_move[0], best_move[1], Player.X)\n            print(f\"AI chose position: {best_move}\")\n            print(f\"Nodes evaluated: {game.nodes_evaluated}\")\n        \n        # Check game end\n        if game.is_winner(Player.X):\n            game.print_board()\n            print(\"AI wins!\")\n            break\n        elif game.is_winner(Player.O):\n            game.print_board()\n            print(\"Human wins!\")\n            break\n        elif game.is_board_full():\n            game.print_board()\n            print(\"It's a draw!\")\n            break\n        \n        # Switch players\n        current_player = Player.X if current_player == Player.O else Player.O\n\nif __name__ == \"__main__\":\n    play_game()"
      }
    ],
    "keyTerms": [
      "__init__",
      "about",
      "accounting",
      "achieving",
      "affect",
      "affecting",
      "again",
      "against",
      "algorithm",
      "all",
      "alpha",
      "alpha-beta",
      "alternates",
      "alternating",
      "always",
      "amortized",
      "analysis",
      "append",
      "artificial",
      "artificial-intelligence",
      "assign",
      "assumed",
      "available",
      "average",
      "backpropagation",
      "baseline",
      "basic",
      "becomes",
      "best",
      "best-first",
      "best_move",
      "best_score",
      "beta",
      "better",
      "between",
      "board",
      "board_key",
      "bool",
      "branch",
      "branches",
      "branching",
      "break",
      "bubble",
      "cache",
      "cached",
      "caches",
      "calculation",
      "calculations",
      "cannot",
      "case",
      "cases",
      "center",
      "challenge",
      "characteristics",
      "checks",
      "child",
      "choose",
      "chose",
      "class",
      "classic",
      "code",
      "col",
      "combines",
      "comparison",
      "complete",
      "complexity",
      "components",
      "computed",
      "computer",
      "concepts",
      "condition",
      "configurations",
      "contents",
      "continue",
      "corners",
      "counter",
      "create",
      "current",
      "current_player",
      "cutting",
      "decision",
      "decision-making",
      "decisions",
      "decreases",
      "def",
      "demonstrates",
      "depth",
      "determined",
      "dict",
      "dictionary",
      "dramatically",
      "draw",
      "each",
      "early",
      "edges",
      "educational",
      "effective",
      "efficiency",
      "efficient",
      "elif",
      "eliminate",
      "eliminates",
      "else",
      "empty",
      "ends",
      "enter",
      "enum",
      "enumerate",
      "evaluate_position",
      "evaluated",
      "evaluates",
      "evaluation",
      "every",
      "examining",
      "example",
      "except",
      "explanation",
      "exploration",
      "explore",
      "explores",
      "exploring",
      "factor",
      "false",
      "far",
      "faster",
      "final",
      "finds",
      "first",
      "float",
      "friend",
      "from",
      "full",
      "game",
      "game-ending",
      "get_available_moves",
      "get_best_move",
      "get_board_key",
      "get_ordered_moves",
      "good",
      "grandchild",
      "grandchildren",
      "guarantee",
      "help",
      "here",
      "heuristics",
      "highest",
      "hit",
      "human",
      "impact",
      "implement",
      "implementation",
      "import",
      "improvement",
      "improves",
      "inf",
      "input",
      "instead",
      "int",
      "intelligence",
      "interactive",
      "intermediate",
      "internal",
      "invalid",
      "is_board_full",
      "is_maximizing",
      "is_winner",
      "join",
      "key",
      "leaves",
      "length",
      "level",
      "likely",
      "lines",
      "list",
      "lookups",
      "loss",
      "lowest",
      "maintaining",
      "make",
      "make_move",
      "max",
      "max_score",
      "maximize",
      "maximizing",
      "maximum",
      "measure",
      "memo",
      "memoization",
      "memory",
      "mid-game",
      "min",
      "min_score",
      "minimax",
      "minimax_alpha_beta",
      "minimizing",
      "more",
      "move",
      "move_priority",
      "moves",
      "must",
      "never",
      "node",
      "nodes",
      "nodes_evaluated",
      "non-terminal",
      "none",
      "numbers",
      "o",
      "occurs",
      "only",
      "operations",
      "opponent",
      "opposite",
      "optimal",
      "optimally",
      "optimization",
      "optimizations",
      "optimized",
      "optional",
      "ordering",
      "outcomes",
      "parent",
      "perfect",
      "perfectly",
      "performance",
      "play",
      "play_game",
      "player",
      "players",
      "plays",
      "position",
      "positions",
      "possible",
      "powered",
      "practical",
      "previously",
      "print",
      "print_board",
      "prioritizes",
      "prune",
      "pruning",
      "range",
      "rate",
      "recursive",
      "reduces",
      "reduction",
      "remaining",
      "repeated",
      "represents",
      "resizable",
      "result",
      "results",
      "return",
      "returns",
      "reverse",
      "roles",
      "root",
      "row",
      "rules",
      "scenario",
      "science",
      "score",
      "scores",
      "scoring",
      "search",
      "self",
      "sequence",
      "sequences",
      "several",
      "shown",
      "simple",
      "simulates",
      "since",
      "sorted",
      "space",
      "specific",
      "speed",
      "starting",
      "starts",
      "state",
      "states",
      "still",
      "stop",
      "str",
      "structure",
      "subsequent",
      "system",
      "table",
      "tac",
      "terminal",
      "that",
      "their",
      "then",
      "theoretical",
      "theory",
      "thinking",
      "tic",
      "tic-tac-toe",
      "tictactoe",
      "tictactoegame",
      "tie",
      "time",
      "toe",
      "tracking",
      "tradeoff",
      "transposition",
      "tree",
      "tries",
      "true",
      "tuple",
      "turn",
      "turns",
      "typically",
      "typing",
      "unbeatable",
      "unnecessary",
      "until",
      "usage",
      "uses",
      "valid",
      "value",
      "valueerror",
      "when",
      "where",
      "while",
      "will",
      "win",
      "wins",
      "with",
      "without",
      "works",
      "worst"
    ],
    "notations": [
      "(\"-----------\")",
      "(\"AI is thinking...\")",
      "(\"AI wins!\")",
      "(\"Human wins!\")",
      "(\"Invalid input! Enter numbers 0-2.\")",
      "(\"Invalid move! Try again.\")",
      "(\"It's a draw!\")",
      "(''.join(row)",
      "('inf')",
      "((i, j)",
      "(0)",
      "(0, False)",
      "(0,0)",
      "(0,2)",
      "(1)",
      "(134,217)",
      "(19,683)",
      "(2,0)",
      "(2,2)",
      "(3)",
      "(362,880)",
      "(3^9)",
      "(9!)",
      "(9, 8, 7, 6... available moves)",
      "(9^4.5)",
      "(9^6.75)",
      "(AI wins)",
      "(AI's turn)",
      "(AI)",
      "(Draw)",
      "(Enum)",
      "(Human wins)",
      "(Human)",
      "(Memoization)",
      "(Player.O)",
      "(Player.X)",
      "(accounting for game rules)",
      "(alpha, score)",
      "(amortized)",
      "(b^(3d/4)",
      "(b^(d/2)",
      "(b^d)",
      "(best_move[0], best_move[1], Player.X)",
      "(beta, score)",
      "(continue evaluation)",
      "(depth + 1, False, alpha, beta)",
      "(depth + 1, True, alpha, beta)",
      "(empty board to full)",
      "(f\" {row[0].value} | {row[1].value} | {row[2].value} \")",
      "(f\"AI chose position: {best_move}\")",
      "(f\"Nodes evaluated: {game.nodes_evaluated}\")",
      "(get the highest possible value)",
      "(input(\"Enter col (0-2)",
      "(input(\"Enter row (0-2)",
      "(max_score, score)",
      "(min_score, score)",
      "(more branches)",
      "(move: Tuple[int, int])",
      "(moves, key=move_priority, reverse=True)",
      "(row, col)",
      "(row, col, Player.O)",
      "(self)",
      "(self, depth: int, is_maximizing: bool, \n                          alpha: int = -float('inf')",
      "(self, player: Player)",
      "(self, row: int, col: int, player: Player)",
      "(self.board)",
      "(self.board[i][2-i] == player for i in range(3)",
      "(self.board[i][i] == player for i in range(3)",
      "(self.board[i][j] != Player.EMPTY \n                  for i in range(3)",
      "(self.board[i][j] == player for j in range(3)",
      "(self.board[j][i] == player for j in range(3)",
      "(win, loss, or draw)",
      "(Œ± = -1, Œ≤ = +‚àû)",
      "(Œ± becomes 0)",
      "(Œ±)",
      "(Œ≤)",
      "Œ±",
      "Œ≤"
    ],
    "categories": [
      "tic-tac-toe"
    ],
    "leetcodeProblems": []
  },
  "stack": {
    "title": "Stack",
    "route": "/notes/stack",
    "filePath": "app/notes/stack/page.mdx",
    "headings": [
      "Stack",
      "Resizable Table of Contents",
      "Definition",
      "Problems",
      "1. Valid Parentheses",
      "2. Min Stack",
      "3. Daily Temperatures",
      "4. Decode String"
    ],
    "text": "A stack is a fundamental data structure that follows the  LIFO (Last-In, First-Out)  principle. Think of it like a stack of plates: you can only add a new plate to the top or remove the topmost plate. The main operations are:  Push : Adds an element to the top of the stack.  Pop : Removes and returns the top element of the stack.  Peek (or Top) : Returns the top element without removing it.  In Python, you can easily implement a stack using a list, where  append()  is  push  and  pop()  is  pop .  Checks if a string containing  '()', '{}', '[]'  has balanced and correctly ordered brackets.  20. Valid Parentheses  def isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack üí° Tip:  Use a stack to keep track of opening brackets. When you encounter a closing bracket, check if the top of the stack is its corresponding opening bracket. If it is, pop from the stack. If not, or if the stack is empty, the string is invalid.  Time Complexity:   , where   is the length of the string.  Space Complexity:    in the worst case (e.g., a string of all opening brackets).  Design a stack that supports  push ,  pop ,  top , and retrieving the minimum element in constant time.  155. Min Stack  class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.min_stack[-1] if self.min_stack else val)\n        self.min_stack.append(val)\n    def pop(self) -> None:\n        self.stack.pop()\n        self.min_stack.pop()\n    def top(self) -> int:\n        return self.stack[-1]\n    def getMin(self) -> int:\n        return self.min_stack[-1] üí° Tip:  Use an auxiliary stack ( min_stack ) that stores the minimum value seen  so far  at each level of the main stack. When you push a new value, you push  min(new_value, current_min)  onto the  min_stack . This ensures  getMin()  is always an   operation.  Time Complexity:    for all operations ( push ,  pop ,  top ,  getMin ).  Space Complexity:   , where   is the number of elements in the stack.  Given a list of daily temperatures, return a list where each element is the number of days you'd have to wait for a warmer temperature. If there's no warmer day, use 0.  739. Daily Temperatures  def dailyTemperatures(temperatures: list[int]) -> list[int]:\n    n = len(temperatures)\n    result = [0] * n\n    stack = []  \n    for i, temp in enumerate(temperatures):\n        while stack and temperatures[stack[-1]] < temp:\n            prev_index = stack.pop()\n            result[prev_index] = i - prev_index\n        stack.append(i)\n    return result üí° Tip:  This problem is a classic example of using a  monotonic stack . The stack maintains a list of indices of days with decreasing temperatures. When you encounter a day that's warmer than the day at the top of the stack, you've found the \"next warmer day\" for that previous day. Pop from the stack and calculate the day difference until the condition is no longer met.  Time Complexity:   , because each index is pushed and popped at most once.  Space Complexity:    in the worst case (a strictly decreasing list of temperatures).  Decode a string that is encoded with the rule  k[encoded_string] , where the  encoded_string  inside the square brackets is repeated exactly  k  times.  394. Decode String  def decodeString(s: str) -> str:\n    stack = []\n    current_num = 0\n    current_string = \"\"\n    for char in s:\n        if char.isdigit():\n            current_num = current_num * 10 + int(char)\n        elif char == '[':\n            stack.append(current_string)\n            stack.append(current_num)\n            current_string = \"\"\n            current_num = 0\n        elif char == ']':\n            num = stack.pop()\n            prev_string = stack.pop()\n            current_string = prev_string + num * current_string\n        else:\n            current_string += char\n    return current_string üí° Tip:  Use a single stack to manage nested context. When you encounter an opening bracket  [ , push the  current_string  built so far and the  current_num  onto the stack. When you see a closing bracket  ] , pop the count and the previous string, perform the multiplication, and prepend the result.  Time Complexity:   , where   is the length of the fully decoded string.  Space Complexity:   , as the stack can store parts of the decoded string in the worst case.",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack"
      },
      {
        "language": "python",
        "content": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.min_stack[-1] if self.min_stack else val)\n        self.min_stack.append(val)\n\n    def pop(self) -> None:\n        self.stack.pop()\n        self.min_stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.min_stack[-1]"
      },
      {
        "language": "python",
        "content": "def dailyTemperatures(temperatures: list[int]) -> list[int]:\n    n = len(temperatures)\n    result = [0] * n\n    # Stack stores indices of temperatures\n    stack = []  \n    for i, temp in enumerate(temperatures):\n        # While stack is not empty and current temp is warmer than temp at stack's top index\n        while stack and temperatures[stack[-1]] < temp:\n            prev_index = stack.pop()\n            result[prev_index] = i - prev_index\n        stack.append(i)\n    return result"
      },
      {
        "language": "python",
        "content": "def decodeString(s: str) -> str:\n    stack = []\n    current_num = 0\n    current_string = \"\"\n    for char in s:\n        if char.isdigit():\n            current_num = current_num * 10 + int(char)\n        elif char == '[':\n            # Push the string and number we had before this new scope\n            stack.append(current_string)\n            stack.append(current_num)\n            # Reset for the new scope\n            current_string = \"\"\n            current_num = 0\n        elif char == ']':\n            # Pop the number and previous string for this scope\n            num = stack.pop()\n            prev_string = stack.pop()\n            current_string = prev_string + num * current_string\n        else:\n            current_string += char\n    return current_string"
      }
    ],
    "keyTerms": [
      "__init__",
      "adds",
      "always",
      "append",
      "auxiliary",
      "balanced",
      "because",
      "bool",
      "bracket",
      "brackets",
      "built",
      "calculate",
      "case",
      "char",
      "check",
      "checks",
      "class",
      "classic",
      "closing",
      "complexity",
      "condition",
      "constant",
      "containing",
      "contents",
      "context",
      "correctly",
      "corresponding",
      "count",
      "current_min",
      "current_num",
      "current_string",
      "daily",
      "dailytemperatures",
      "data",
      "days",
      "decode",
      "decoded",
      "decodestring",
      "decreasing",
      "def",
      "definition",
      "design",
      "difference",
      "each",
      "easily",
      "element",
      "elements",
      "elif",
      "else",
      "empty",
      "encoded",
      "encoded_string",
      "encounter",
      "ensures",
      "enumerate",
      "exactly",
      "example",
      "false",
      "far",
      "first-out",
      "follows",
      "found",
      "from",
      "fully",
      "fundamental",
      "getmin",
      "given",
      "have",
      "implement",
      "index",
      "indices",
      "inside",
      "int",
      "invalid",
      "isdigit",
      "isvalid",
      "keep",
      "last-in",
      "len",
      "length",
      "level",
      "lifo",
      "like",
      "list",
      "longer",
      "main",
      "maintains",
      "manage",
      "mapping",
      "met",
      "min",
      "min_stack",
      "minimum",
      "minstack",
      "monotonic",
      "most",
      "multiplication",
      "nested",
      "new_value",
      "next",
      "none",
      "num",
      "number",
      "once",
      "only",
      "onto",
      "opening",
      "operation",
      "operations",
      "ordered",
      "parentheses",
      "parts",
      "peek",
      "perform",
      "plate",
      "plates",
      "pop",
      "popped",
      "prepend",
      "prev_index",
      "prev_string",
      "previous",
      "principle",
      "problem",
      "problems",
      "push",
      "pushed",
      "python",
      "remove",
      "removes",
      "removing",
      "repeated",
      "resizable",
      "result",
      "retrieving",
      "return",
      "returns",
      "rule",
      "seen",
      "self",
      "single",
      "space",
      "square",
      "stack",
      "store",
      "stores",
      "str",
      "strictly",
      "string",
      "structure",
      "supports",
      "table",
      "temp",
      "temperature",
      "temperatures",
      "than",
      "that",
      "there",
      "think",
      "time",
      "times",
      "tip",
      "top",
      "top_element",
      "topmost",
      "track",
      "until",
      "using",
      "val",
      "valid",
      "value",
      "wait",
      "warmer",
      "when",
      "where",
      "while",
      "with",
      "without",
      "worst"
    ],
    "notations": [
      "( min_stack )",
      "( push ,  pop ,  top ,  getMin )",
      "(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop()",
      "(Last-In, First-Out)",
      "(a strictly decreasing list of temperatures)",
      "(char)",
      "(current_num)",
      "(current_string)",
      "(e.g., a string of all opening brackets)",
      "(i)",
      "(new_value, current_min)",
      "(or Top)",
      "(s: str)",
      "(self)",
      "(self, val: int)",
      "(temperatures)",
      "(temperatures: list[int])",
      "(val)",
      "(val, self.min_stack[-1] if self.min_stack else val)"
    ],
    "categories": [
      "stack"
    ],
    "leetcodeProblems": [
      {
        "number": "20",
        "name": "Valid Parentheses",
        "url": "https://leetcode.com/problems/valid-parentheses/",
        "section": "1\\. Valid Parentheses"
      },
      {
        "number": "155",
        "name": "Min Stack",
        "url": "https://leetcode.com/problems/min-stack/",
        "section": "2\\. Min Stack"
      },
      {
        "number": "739",
        "name": "Daily Temperatures",
        "url": "https://leetcode.com/problems/daily-temperatures/",
        "section": "3\\. Daily Temperatures"
      },
      {
        "number": "394",
        "name": "Decode String",
        "url": "https://leetcode.com/problems/decode-string/",
        "section": "4\\. Decode String"
      }
    ]
  },
  "sliding-window": {
    "title": "Sliding Window",
    "route": "/notes/sliding-window",
    "filePath": "app/notes/sliding-window/page.mdx",
    "headings": [
      "Sliding Window",
      "Resizable Table of Contents",
      "Problem",
      "1. Subarray Product Less Than K",
      "2. Longest Substring Without Repeating Characters"
    ],
    "text": "Given an array of integers  nums  and an integer  k , return the number of contiguous subarrays where the product of all the elements in the subarray is less than  k .  713. Subarray Product Less Than K   Given a string  s , find the length of the longest substring without repeating characters.  3. Longest Substring Without Repeating Characters",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/sliding_window.py#method:SlidingWindow.numSubarrayProductLessThanK",
        "fileSource": "backend/algorithms/sliding_window.py",
        "className": "SlidingWindow",
        "methodName": "numSubarrayProductLessThanK"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/sliding_window.py#method:SlidingWindow.lengthOfLongestSubstring   ",
        "fileSource": "backend/algorithms/sliding_window.py",
        "className": "SlidingWindow",
        "methodName": "lengthOfLongestSubstring"
      }
    ],
    "keyTerms": [
      "array",
      "characters",
      "contents",
      "contiguous",
      "elements",
      "find",
      "given",
      "integer",
      "integers",
      "length",
      "less",
      "longest",
      "number",
      "nums",
      "problem",
      "product",
      "repeating",
      "resizable",
      "return",
      "sliding",
      "string",
      "subarray",
      "subarrays",
      "substring",
      "table",
      "than",
      "where",
      "window",
      "without"
    ],
    "notations": [],
    "categories": [
      "sliding-window"
    ],
    "leetcodeProblems": [
      {
        "number": "713",
        "name": "Subarray Product Less Than K",
        "url": "https://leetcode.com/problems/subarray-product-less-than-k/",
        "section": "1. Subarray Product Less Than K"
      },
      {
        "number": "3",
        "name": "Longest Substring Without Repeating Characters",
        "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
        "section": "2. Longest Substring Without Repeating Characters"
      }
    ]
  },
  "prefix-sum": {
    "title": "Prefix Sum",
    "route": "/notes/prefix-sum",
    "filePath": "app/notes/prefix-sum/page.mdx",
    "headings": [
      "Prefix Sum",
      "Resizable Table of Contents",
      "The Power of a Pre-Calculated Route",
      "1. Longest Streak Covering Exactly k Kilometers",
      "2. Count of Streaks Covering k Kilometers",
      "3. Longest Balanced Forward/Backward Day-Count",
      "4. Detecting a Segment of k-Multiple Distance",
      "5. Counting All Spans Divisible by k",
      "6. Minimal Segment to Skip",
      "7. Constructing the Itinerary",
      "8. Counting Valid Starting Points"
    ],
    "text": "Imagine you're on a long highway road trip. The road has mile markers posted sequentially,\nstarting from Mile  0 . If you just passed marker  75  and your exit is at marker  180 ,\nyou instantly know the distance you have left to travel:  180 - 75 = 105  miles.  These  Highway Markers  are a perfect real-world example of a pre-calculated system.\nEach marker represents the total distance from the start of the highway.\nThis allows you to find the distance between  any  two points with a single subtraction,\nwithout having to measure the road yourself. This is the core idea behind  prefix sums .  For an array of numbers representing sequential trip segments:  segment = [120, -30, 200, -50, 150]  This represents the change in position each day: 120km east, then 30km west, 200km east, etc.  Its  [13:]prefix_sum  array is the set of highway  [13:]markers :  marker = [120, 90, 290, 240, 390]  This is the mile marker you're at after each day's travel.  marker[i]  =  segment[0]  +  segment[1]  + ... +  segment[i] .   The total distance of any continuous \"segment\" of your trip, from day  i  to day  j , is simply  Markers[j] - Markers[i-1] :   Note:  For a range starting at index  0 , the formula is just  , since   would be 0.  This allows us to answer any range query( sum of any continuous segment from index  i  to  j ) in constant   time after one   pass to build the  Markers  array.  By combining this technique with a hash map to remember past marker locations, we can solve a huge range of\notherwise complex problems with surprising efficiency. Let's see it in action.  LeetCode 325: Maximum Size Subarray Sum Equals k  find the longest continuous sequence of trip segments whose combined length is exactly  k km .   LeetCode 560: Subarray Sum Equals K  How many distinct, continuous sequences of trip segments have a total length of exactly  k km ?   LeetCode 525: Contiguous Array  To balance your driving, find the longest stretch of days with an equal number of forward (+) and backward (-) segments.\nThis is equivalent to finding the longest subarray that sums to zero after converting forward/backward segments to +/- 1 .   LeetCode 523: Continuous Subarray Sum  Did any continuous part of your trip, lasting at least two days, cover a total distance that was an exact  multiple of k km ?   LeetCode 974: Subarray Sums Divisible by K  How many continuous sequences of trip segments have a total length that is perfectly divisible by k?   [!deepdive:collapse]  sum[i...j]  ( prefix_sum[j] - prefix_sum[i-1] ) is divisible by  k   iff   prefix_sum[i]  and  prefix_sum[j]  divided by  k  have an  identical remainder  Redefine the problem: counting  every pair  of prefix sums that have an  identical remainder  The sum of any subarray is the difference between two prefix sums  sum[i...j] = prefix_sum[j] - prefix_sum[i-1] .  A key principle of modular arithmetic  is that this difference is perfectly divisible by  k  if and only if  prefix_sum[i]  and  prefix_sum[j] \nhave the exact same remainder when divided by  k .  Therefore, the problem of finding subarray sums divisible by  k  becomes the simpler problem\nof counting  every pair  of prefix sums that have an  identical remainder  .  prefix_remainder = (prefix_remainder + segment) % k  This code is a direct application of the  property of modular addition .  (A + B) mod C = ((A mod C) + (B mod C)) mod C  This property guarantees that finding the remainder of a sum  (previous_sum + segment) % k  is equivalent to using the remainder from the previous step:  ( (previous_sum % k) + segment) % k .  Since the  prefix_remainder  variable already holds  previous_sum % k , the code correctly uses this efficient shortcut. It yields the same result without needing to calculate the full, and potentially large, prefix sum.  LeetCode 1590: Make Sum Divisible by P  Your total trip length (the final highway marker) isn‚Äôt divisible by  p . Find the  shortest continuous trip segment  you can remove from your log, so that the length of the remaining segments  is  divisible by  p .   [!deepdive:collapse]  The logic is based on a core principle of  modular congruence  A ‚â° B (mod C) :  ~  a % c == b % c  (Two numbers have the same remainder)  ~  (a - b) % c == 0  (Their difference is a multiple of  c )  Let's apply this:  If  Total Sum % p == Subarray Sum % p  Then  (Total Sum - Subarray Sum) % p == 0  Since  Total Sum - Subarray Sum  is the  Remaining Sum , this proves that removing a subarray with the same remainder makes the new total divisible by  p .  The Logic and Implementation  The reasoning above simplifies our goal:  find the shortest subarray whose sum has the same remainder  as the total sum.  The code achieves this using prefix sums, where  Subarray Sum = Current Prefix Sum - Past Prefix Sum . The goal is to find a subarray where  Subarray Sum % p == Total's Remainder . This leads to the derivation of the  need  variable.  Deriving  need  Let's simplify the names for clarity:  C = Current Prefix Sum  P = Past Prefix Sum  R = Total's Remainder  ~  Start with the objective:  We need the subarray's sum ( C - P ) to have the remainder  R .\n (C - P) % p == R  ~  Isolate the unknown:  We need to find the  Past Prefix Sum  ( P ). Using the rules of modular arithmetic, we can rearrange the equation to solve for  P .\n P % p == (C - R) % p  [!note:collapse] That rearrangement is based on the algebraic rules of  modular congruence  The Rule  The principle is that a modular congruence  A ‚â° B (mod p)  behaves like a standard algebraic equation. You can add or subtract the same value on both sides of the  ‚â°  symbol and the congruence remains true.  Applying the Rule  ~  Start with the equation in congruence form: \n (C - P) % p == R  is the same as  C - P ‚â° R (mod p) .  ~  Rearrange using algebra:  To solve for  P , you can add  P  to both sides and subtract  R  from both sides.\n C - R ‚â° P (mod p)  ~  Convert back:  :\n P % p == (C - R) % p  Think of  (mod p)  like a unit of measurement, such as \"in kilograms\" or a currency like \"in USD.\" It's not a number or variable that you move around algebraically.  If you have an equation where all terms are in kilograms:\n Weight A = Weight B  (in kg)  And you subtract 5 kg from both sides, the new equation is still valid within that context:\n Weight A - 5 kg = Weight B - 5 kg  (in kg)  You don't \"move\" the \"(in kg)\" part; it remains as the context for the relationship.  Similarly,  (mod p)  tells us the mathematical system we are working in. All the algebra we perform on  C ,  P , and  R  happens  within that system . The  (mod p)  at the end simply states that the congruence relationship is true under those specific rules.  ~  Define  need :  The term we solved for,  Past Prefix Sum % p , is the value the code is looking for. This is what  need  represents.\n need = (C - R) % p  Why add  + p ?  This is a common trick in programming to correctly handle potential negative numbers. The subtraction  (C - R)  could result in a negative value.\nAdding  p  before the modulo operation ensures the input is always positive, which guarantees a consistent remainder from  0  to  p-1  for the hash map lookup.  Therefore,  (C - R + p) % p  is the robust, code-friendly way to calculate  (C - R) % p .  LeetCode 370: Range Addition  You start with a blank itinerary for a trip of length days.\nUsing a list of instructions like  [16:]add 50km/day for days 2-5 ,\nwhat is your final daily travel plan?   LeetCode 2145: Count the Hidden Sequences  You know your daily travel segments but not your starting mile marker.\nIf you always stayed between markers lower and upper, how many starting points could you have had?",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/prefix_sum.py#func:maxSubArrayLen ",
        "fileSource": "backend/algorithms/prefix_sum.py",
        "functionName": "maxSubArrayLen"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/prefix_sum.py#func:subarraySum ",
        "fileSource": "backend/algorithms/prefix_sum.py",
        "functionName": "subarraySum"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/prefix_sum.py#func:findMaxLength ",
        "fileSource": "backend/algorithms/prefix_sum.py",
        "functionName": "findMaxLength"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/prefix_sum.py#func:checkSubarraySum ",
        "fileSource": "backend/algorithms/prefix_sum.py",
        "functionName": "checkSubarraySum"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/prefix_sum.py#func:subarraysDivByK ",
        "fileSource": "backend/algorithms/prefix_sum.py",
        "functionName": "subarraysDivByK"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/prefix_sum.py#func:minSubarray ",
        "fileSource": "backend/algorithms/prefix_sum.py",
        "functionName": "minSubarray"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/prefix_sum.py#func:getModifiedArray ",
        "fileSource": "backend/algorithms/prefix_sum.py",
        "functionName": "getModifiedArray"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/prefix_sum.py#func:numberOfArrays ",
        "fileSource": "backend/algorithms/prefix_sum.py",
        "functionName": "numberOfArrays"
      }
    ],
    "keyTerms": [
      "above",
      "achieves",
      "action",
      "adding",
      "addition",
      "after",
      "algebra",
      "algebraic",
      "algebraically",
      "allows",
      "already",
      "always",
      "answer",
      "application",
      "apply",
      "applying",
      "arithmetic",
      "around",
      "array",
      "back",
      "backward",
      "balance",
      "balanced",
      "based",
      "becomes",
      "before",
      "behaves",
      "behind",
      "between",
      "blank",
      "both",
      "build",
      "calculate",
      "change",
      "clarity",
      "code",
      "code-friendly",
      "collapse",
      "combined",
      "combining",
      "common",
      "complex",
      "congruence",
      "consistent",
      "constant",
      "constructing",
      "contents",
      "context",
      "contiguous",
      "continuous",
      "convert",
      "converting",
      "core",
      "correctly",
      "could",
      "count",
      "counting",
      "cover",
      "covering",
      "currency",
      "current",
      "daily",
      "day-count",
      "days",
      "deepdive",
      "define",
      "derivation",
      "deriving",
      "detecting",
      "difference",
      "direct",
      "distance",
      "distinct",
      "divided",
      "divisible",
      "don",
      "driving",
      "each",
      "east",
      "efficiency",
      "efficient",
      "ensures",
      "equal",
      "equals",
      "equation",
      "equivalent",
      "etc",
      "every",
      "exact",
      "exactly",
      "example",
      "exit",
      "final",
      "find",
      "finding",
      "form",
      "formula",
      "forward",
      "from",
      "full",
      "goal",
      "guarantees",
      "handle",
      "happens",
      "hash",
      "have",
      "having",
      "hidden",
      "highway",
      "holds",
      "huge",
      "i-1",
      "idea",
      "identical",
      "iff",
      "imagine",
      "implementation",
      "index",
      "input",
      "instantly",
      "instructions",
      "isn",
      "isolate",
      "itinerary",
      "just",
      "k-multiple",
      "key",
      "kilograms",
      "kilometers",
      "know",
      "large",
      "lasting",
      "leads",
      "least",
      "leetcode",
      "left",
      "length",
      "like",
      "list",
      "locations",
      "log",
      "logic",
      "long",
      "longest",
      "looking",
      "lookup",
      "lower",
      "make",
      "makes",
      "many",
      "map",
      "marker",
      "markers",
      "mathematical",
      "maximum",
      "measure",
      "measurement",
      "mile",
      "miles",
      "minimal",
      "mod",
      "modular",
      "modulo",
      "move",
      "multiple",
      "names",
      "need",
      "needing",
      "negative",
      "note",
      "number",
      "numbers",
      "objective",
      "only",
      "operation",
      "otherwise",
      "p-1",
      "pair",
      "part",
      "pass",
      "passed",
      "past",
      "perfect",
      "perfectly",
      "perform",
      "plan",
      "points",
      "position",
      "positive",
      "posted",
      "potential",
      "potentially",
      "power",
      "pre-calculated",
      "prefix",
      "prefix_remainder",
      "prefix_sum",
      "previous",
      "previous_sum",
      "principle",
      "problem",
      "problems",
      "programming",
      "property",
      "proves",
      "query",
      "range",
      "real-world",
      "rearrange",
      "rearrangement",
      "reasoning",
      "redefine",
      "relationship",
      "remainder",
      "remaining",
      "remains",
      "remember",
      "remove",
      "removing",
      "representing",
      "represents",
      "resizable",
      "result",
      "road",
      "robust",
      "route",
      "rule",
      "rules",
      "same",
      "segment",
      "segments",
      "sequence",
      "sequences",
      "sequential",
      "sequentially",
      "shortcut",
      "shortest",
      "sides",
      "similarly",
      "simpler",
      "simplifies",
      "simplify",
      "simply",
      "since",
      "single",
      "size",
      "skip",
      "solve",
      "solved",
      "spans",
      "specific",
      "standard",
      "start",
      "starting",
      "states",
      "stayed",
      "step",
      "still",
      "streak",
      "streaks",
      "stretch",
      "subarray",
      "subtract",
      "subtraction",
      "such",
      "sum",
      "sums",
      "surprising",
      "symbol",
      "system",
      "table",
      "technique",
      "tells",
      "term",
      "terms",
      "that",
      "their",
      "then",
      "therefore",
      "these",
      "think",
      "those",
      "time",
      "total",
      "travel",
      "trick",
      "trip",
      "true",
      "under",
      "unit",
      "unknown",
      "upper",
      "usd",
      "uses",
      "using",
      "valid",
      "value",
      "variable",
      "weight",
      "west",
      "what",
      "when",
      "where",
      "which",
      "whose",
      "with",
      "within",
      "without",
      "working",
      "would",
      "yields",
      "your",
      "yourself",
      "zero"
    ],
    "notations": [
      "( (previous_sum % k)",
      "( C - P )",
      "( P )",
      "( prefix_sum[j] - prefix_sum[i-1] )",
      "( sum of any continuous segment from index  i  to  j )",
      "((A mod C)",
      "(+)",
      "(-)",
      "(A + B)",
      "(B mod C)",
      "(C - P)",
      "(C - R + p)",
      "(C - R)",
      "(Their difference is a multiple of  c )",
      "(Total Sum - Subarray Sum)",
      "(Two numbers have the same remainder)",
      "(a - b)",
      "(in kg)",
      "(mod C)",
      "(mod p)",
      "(prefix_remainder + segment)",
      "(previous_sum + segment)",
      "(the final highway marker)"
    ],
    "categories": [
      "prefix-sum"
    ],
    "leetcodeProblems": [
      {
        "number": "325",
        "name": "Maximum Size Subarray Sum Equals k",
        "url": "https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/",
        "section": "1\\. Longest Streak Covering Exactly k Kilometers"
      },
      {
        "number": "560",
        "name": "Subarray Sum Equals K",
        "url": "https://leetcode.com/problems/subarray-sum-equals-k/",
        "section": "2\\. Count of Streaks Covering k Kilometers"
      },
      {
        "number": "525",
        "name": "Contiguous Array",
        "url": "https://leetcode.com/problems/contiguous-array/",
        "section": "3\\. Longest Balanced Forward/Backward Day-Count"
      },
      {
        "number": "523",
        "name": "Continuous Subarray Sum",
        "url": "https://leetcode.com/problems/continuous-subarray-sum/",
        "section": "4\\. Detecting a Segment of k-Multiple Distance"
      },
      {
        "number": "974",
        "name": "Subarray Sums Divisible by K",
        "url": "https://leetcode.com/problems/subarray-sums-divisible-by-k/",
        "section": "5\\. Counting All Spans Divisible by k"
      },
      {
        "number": "1590",
        "name": "Make Sum Divisible by P",
        "url": "https://leetcode.com/problems/make-sum-divisible-by-p/",
        "section": "6\\. Minimal Segment to Skip"
      },
      {
        "number": "370",
        "name": "Range Addition",
        "url": "https://leetcode.com/problems/range-addition/",
        "section": "7\\. Constructing the Itinerary"
      },
      {
        "number": "2145",
        "name": "Count the Hidden Sequences",
        "url": "https://leetcode.com/problems/count-the-hidden-sequences/",
        "section": "8\\. Counting Valid Starting Points"
      }
    ]
  },
  "modular-arithmetic": {
    "title": "Modular Arithmetic",
    "route": "/notes/modular-arithmetic",
    "filePath": "app/notes/modular-arithmetic/page.mdx",
    "headings": [
      "Modular Arithmetic",
      "Resizable table of contents",
      "Introduction to Modular Arithmetic",
      "What is Modular Arithmetic?",
      "Congruence Modulo",
      "Basic Operations",
      "Addition",
      "Subtraction",
      "Multiplication",
      "Algebraic Properties of Congruence",
      "Addition and Subtraction",
      "A Special Case: Adding a Constant"
    ],
    "text": "When we divide two integers we will have an equation that looks like the following:   is the dividend  is the divisor  is the quotient  is the remainder  Sometimes, we are only interested in what the  remainder  is when we divide   by  .\nFor these cases there is an operator called the  modulo operator  (abbreviated as  mod ).\nUsing the same  ,  ,  , and   as above, we would have:  Modular arithmetic is a system of arithmetic for integers,\nwhere numbers \"wrap around\" upon reaching a certain value‚Äîthe\n modulus .  Example:  The most common example is a clock üï∞Ô∏è.\nIf it's  10  o'clock and  4  hours pass,\nthe time becomes  2  o'clock, not  14 .\nThis is because a clock  wraps around  at a modulus of  12 .  We use the  modulo operator  (written as  mod  or  % )\nto find the remainder of a division.  Example:   14 mod 12 = 2   or   14 % 12 = 2  A ‚â° B (mod C)  Two integers  A  and  B  are  congruent modulo C  if they satisfy two equivalent conditions:  They have the  same remainder  when divided by  C a % c == b % c  Example:   14 mod 12 = 2  and  2 mod 12 = 2 .  Their  difference  (A - B)  is a multiple  of  C (a - b) % c == 0  Example:   14 - 2 = 12 , which is a multiple of 12. In programming style, this means  (14 - 2) mod 12 = 0 .  [!deepdive:collapse]\n Proof That The Two Conditions Are Equivalent:  ~  Same Remainder ‚Üí Difference is a Multiple: \nIf  A  and  B  have the same remainder  r , we can write  A = q‚ÇÅC + r   and  B = q‚ÇÇC + r . Subtracting them cancels the remainder  r , leaving  A - B = (q‚ÇÅ - q‚ÇÇ)C , which is a multiple of  C  ~  Difference is a Multiple ‚Üí Same Remainder: \nIf  A - B  is a multiple of  C , then  A - B = qC . This means  A = B + qC . Applying the modulo C operation to both sides, we get  A % C = (B + qC) % C , the  qC  term's remainder is 0, leaving  A % C = B % C  You can simplify numbers by taking the  mod  before or after an operation.  (A + B) mod C  =  ((A mod C) + (B mod C)) mod C  Example:   (14 + 17) mod 5  =  (4 + 2) mod 5  =  1  (A - B) mod C  =  ((A mod C) - (B mod C)) mod C  Example:   (14 - 3) mod 5  =  (4 - 3) mod 5  =  1  (A * B) mod C  =  ((A mod C) * (B mod C)) mod C  Example:   (14 * 17) mod 5  =  (4 * 2) mod 5  =  3  A powerful feature of congruences is that they behave much like standard algebraic equations. You can add, subtract, or multiply them. This is crucial for solving equations involving modular arithmetic.  If you have two separate congruences with the same modulus, you can add or subtract them.  If  A ‚â° B (mod C)  and  D ‚â° E (mod C) , then:  \n  Example:  We know  14 ‚â° 2 (mod 12)  and  20 ‚â° 8 (mod 12) .  Adding them:  14 + 20 ‚â° 2 + 8 (mod 12)  results in  34 ‚â° 10 (mod 12) . This is true, as both sides have a remainder of 10.  The rule that you can add the same integer  k  to both sides of a congruence is a special case of the rule above, where the second congruence is the simple fact that  k ‚â° k (mod C) .  If we have  A ‚â° B (mod C)  and add it to  k ‚â° k (mod C) , we get:\n A + k ‚â° B + k (mod C)",
    "sections": [],
    "codeBlocks": [],
    "keyTerms": [
      "abbreviated",
      "above",
      "adding",
      "addition",
      "after",
      "algebraic",
      "applying",
      "arithmetic",
      "around",
      "basic",
      "because",
      "becomes",
      "before",
      "behave",
      "both",
      "called",
      "cancels",
      "case",
      "cases",
      "certain",
      "clock",
      "collapse",
      "common",
      "conditions",
      "congruence",
      "congruences",
      "congruent",
      "constant",
      "contents",
      "crucial",
      "deepdive",
      "difference",
      "divide",
      "divided",
      "dividend",
      "division",
      "divisor",
      "equation",
      "equations",
      "equivalent",
      "example",
      "fact",
      "feature",
      "find",
      "following",
      "have",
      "hours",
      "integer",
      "integers",
      "interested",
      "introduction",
      "involving",
      "know",
      "leaving",
      "like",
      "looks",
      "means",
      "mod",
      "modular",
      "modulo",
      "modulus",
      "most",
      "much",
      "multiple",
      "multiplication",
      "multiply",
      "numbers",
      "only",
      "operation",
      "operations",
      "operator",
      "pass",
      "powerful",
      "programming",
      "proof",
      "properties",
      "qc",
      "quotient",
      "reaching",
      "remainder",
      "resizable",
      "results",
      "rule",
      "same",
      "satisfy",
      "second",
      "separate",
      "sides",
      "simple",
      "simplify",
      "solving",
      "sometimes",
      "special",
      "standard",
      "style",
      "subtract",
      "subtracting",
      "subtraction",
      "system",
      "table",
      "taking",
      "term",
      "that",
      "their",
      "them",
      "then",
      "there",
      "these",
      "they",
      "time",
      "true",
      "upon",
      "using",
      "value",
      "what",
      "when",
      "where",
      "which",
      "will",
      "with",
      "would",
      "wrap",
      "wraps",
      "write",
      "written"
    ],
    "notations": [
      "((A mod C)",
      "(14 * 17)",
      "(14 + 17)",
      "(14 - 2)",
      "(14 - 3)",
      "(4 * 2)",
      "(4 + 2)",
      "(4 - 3)",
      "(A * B)",
      "(A + B)",
      "(A - B)",
      "(B + qC)",
      "(B mod C)",
      "(a - b)",
      "(abbreviated as  mod )",
      "(mod 12)",
      "(mod C)",
      "(q‚ÇÅ - q‚ÇÇ)",
      "(written as  mod  or  % )",
      "q‚ÇÅ",
      "q‚ÇÇ"
    ],
    "categories": [
      "modular-arithmetic"
    ],
    "leetcodeProblems": []
  },
  "python": {
    "title": "Python",
    "route": "/notes/python",
    "filePath": "app/notes/python/page.mdx",
    "headings": [
      "Python",
      "Resizable Table Of contents",
      "Bitwise Operators",
      "Odd/Even Check",
      "Division",
      "True division `/`:  always returns a float",
      "Floor division `//`: rounds down toward ‚Äì‚àû"
    ],
    "text": "In binary, every integer is represented as a sequence of bits. The very least significant bit (LSB) encodes whether a number is odd or even:\n‚Ä¢\t‚Ä¶‚Äã0 (in binary) ‚Üí even\n‚Ä¢\t‚Ä¶‚Äã1 (in binary) ‚Üí odd  The literal 1 in binary is ‚Ä¶0001. When you do a bitwise AND:  total & 1  you‚Äôre effectively ‚Äúmasking out‚Äù all bits except the LSB:\n‚Ä¢\tIf total is even, its LSB is 0, so  ‚Ä¶xxxx0\n& ‚Ä¶0001\n= ‚Ä¶0000  ‚Üí 0 ‚Ä¢\tIf total is odd, its LSB is 1, so ‚Ä¶xxxx1\n& ‚Ä¶0001\n= ‚Ä¶0001  ‚Üí 1 Thus total & 1 evaluates to 0 for even totals and 1 for odd totals. In an if-statement, 0 is treated as False and any non-zero (here 1) is True, making if total & 1: a concise check for ‚Äúis this number odd?‚Äù  >>> 7   / 3\n2.3333333333333335\n>>> 6   / 3\n2.0\n>>> -7  / 3\n-2.3333333333333335\n>>> 7.0 / 3\n2.3333333333333335 >>> 7   // 3\n2\n>>> 6   // 3\n2\n>>> -7  // 3\n-3        # because -7/3 ‚âà -2.33, flooring gives -3\n>>> 7.0 // 3\n2.0\n>>> 7   // 3.0\n2.0",
    "sections": [],
    "codeBlocks": [
      {
        "language": "text",
        "content": "‚Ä¶xxxx0\n& ‚Ä¶0001\n= ‚Ä¶0000  ‚Üí 0"
      },
      {
        "language": "text",
        "content": "‚Ä¢\tIf total is odd, its LSB is 1, so"
      },
      {
        "language": "text",
        "content": "‚Ä¶xxxx1\n& ‚Ä¶0001\n= ‚Ä¶0001  ‚Üí 1"
      },
      {
        "language": "bash",
        "content": ">>> 7   / 3\n2.3333333333333335\n>>> 6   / 3\n2.0\n>>> -7  / 3\n-2.3333333333333335\n>>> 7.0 / 3\n2.3333333333333335"
      },
      {
        "language": "bash",
        "content": ">>> 7   // 3\n2\n>>> 6   // 3\n2\n>>> -7  // 3\n-3        # because -7/3 ‚âà -2.33, flooring gives -3\n>>> 7.0 // 3\n2.0\n>>> 7   // 3.0\n2.0"
      }
    ],
    "keyTerms": [
      "always",
      "because",
      "binary",
      "bits",
      "bitwise",
      "check",
      "concise",
      "contents",
      "division",
      "down",
      "effectively",
      "encodes",
      "evaluates",
      "even",
      "every",
      "except",
      "false",
      "float",
      "floor",
      "flooring",
      "gives",
      "here",
      "if-statement",
      "integer",
      "least",
      "literal",
      "lsb",
      "making",
      "masking",
      "non-zero",
      "number",
      "odd",
      "operators",
      "python",
      "represented",
      "resizable",
      "returns",
      "rounds",
      "sequence",
      "significant",
      "table",
      "thus",
      "total",
      "totals",
      "toward",
      "treated",
      "true",
      "very",
      "when",
      "whether",
      "xxxx0",
      "xxxx1"
    ],
    "notations": [
      "(LSB)",
      "(here 1)",
      "(in binary)",
      "x0",
      "x1"
    ],
    "categories": [
      "python"
    ],
    "leetcodeProblems": []
  },
  "min-max": {
    "title": "Adversarial Search ‚öîÔ∏è",
    "route": "/notes/min-max",
    "filePath": "app/notes/min-max/page.mdx",
    "headings": [
      "Adversarial Search ‚öîÔ∏è",
      "Minimax Algorithm",
      "Optimizations for Minimax"
    ],
    "text": "In some problems, an AI agent faces an opponent who is actively trying to achieve an opposing goal. This is common in games like tic-tac-toe.  The  Minimax  algorithm is designed for two-player adversarial games. One player is the  maximizer  (MAX), who tries to achieve the highest possible score, while the other is the  minimizer  (MIN), who tries to get the lowest score. The algorithm works by exploring future moves to determine the best possible action.  The key components of a game for the Minimax algorithm are:  Initial State ( ) : The starting configuration of the game.  PLAYER(s) : A function that determines which player has the move in state  s .  ACTIONS(s) : A function that returns all legal moves from state  s .  RESULT(s, a) : The state that results from taking action  a  in state  s .  TERMINAL(s) : A function that checks if the game has ended (win, lose, or tie).  UTILITY(s) : A function that assigns a final numerical value to a terminal state (e.g., +1 for a MAX win, -1 for a MIN win, 0 for a tie).  The algorithm works by having the maximizer pick actions that lead to the highest value, assuming the minimizer will always pick actions that lead to the lowest value. This creates a recursive process where each player anticipates the other's optimal response.  Alpha-Beta Pruning : This optimization allows the Minimax algorithm to skip evaluating branches that won't affect the final decision. If the maximizer finds a path that guarantees a certain score, it can ignore (or \"prune\") any other path where the minimizer could force a worse outcome.  Depth-Limited Minimax : For complex games like chess, exploring every possible game to its end is computationally impossible. This technique limits the search to a certain number of moves ahead. To make decisions without reaching a terminal state, it uses an  evaluation function  that estimates the utility of a non-final game state, for instance, by assessing which player has a material or positional advantage.",
    "sections": [],
    "codeBlocks": [],
    "keyTerms": [
      "achieve",
      "action",
      "actions",
      "actively",
      "advantage",
      "adversarial",
      "affect",
      "agent",
      "ahead",
      "algorithm",
      "allows",
      "alpha-beta",
      "always",
      "anticipates",
      "assessing",
      "assigns",
      "assuming",
      "best",
      "branches",
      "certain",
      "checks",
      "chess",
      "common",
      "complex",
      "components",
      "computationally",
      "configuration",
      "could",
      "creates",
      "decision",
      "decisions",
      "depth-limited",
      "designed",
      "determine",
      "determines",
      "each",
      "ended",
      "estimates",
      "evaluating",
      "evaluation",
      "every",
      "exploring",
      "faces",
      "final",
      "finds",
      "force",
      "from",
      "function",
      "future",
      "game",
      "games",
      "goal",
      "guarantees",
      "having",
      "highest",
      "ignore",
      "impossible",
      "initial",
      "instance",
      "key",
      "lead",
      "legal",
      "like",
      "limits",
      "lose",
      "lowest",
      "make",
      "material",
      "max",
      "maximizer",
      "min",
      "minimax",
      "minimizer",
      "move",
      "moves",
      "non-final",
      "number",
      "numerical",
      "opponent",
      "opposing",
      "optimal",
      "optimization",
      "optimizations",
      "other",
      "outcome",
      "path",
      "pick",
      "player",
      "positional",
      "possible",
      "problems",
      "process",
      "prune",
      "pruning",
      "reaching",
      "recursive",
      "response",
      "result",
      "results",
      "returns",
      "score",
      "search",
      "skip",
      "some",
      "starting",
      "state",
      "taking",
      "technique",
      "terminal",
      "that",
      "tic-tac-toe",
      "tie",
      "tries",
      "trying",
      "two-player",
      "uses",
      "utility",
      "value",
      "where",
      "which",
      "while",
      "will",
      "win",
      "without",
      "won",
      "works",
      "worse"
    ],
    "notations": [
      "( )",
      "(MAX)",
      "(MIN)",
      "(e.g., +1 for a MAX win, -1 for a MIN win, 0 for a tie)",
      "(or \"prune\")",
      "(s)",
      "(s, a)",
      "(win, lose, or tie)"
    ],
    "categories": [
      "min-max"
    ],
    "leetcodeProblems": []
  },
  "list": {
    "title": "List",
    "route": "/notes/list",
    "filePath": "app/notes/list/page.mdx",
    "headings": [
      "List",
      "Resizable Table of Contents",
      "try again",
      "Ordered List",
      "Unordered List",
      "Unordered Feature List",
      "Ordered Feature List"
    ],
    "text": "hi  by  hi again  by again  Item five - part of the previous list (as 5 comes after 4)\n3.1. Item five.one - this should be nested (the svg should be 5.1)\n3.2. Item five.two - this should be nested (the svg should be 5.2)  Item one - this should start a new list  Item two  Item one\n1.1. Item one.one - this should be nested (the svg should be 1.1)\n1.2. Item one.two - this should be nested (the svg should be 1.2)  Item two  Item three  Item four  Item five - part of the previous list (as 5 comes after 4)\n5.1. Item five.one - this should be nested (the svg should be 5.1)\n5.2. Item five.two - this should be nested (the svg should be 5.2)  Item one - this should start a new list\n1.1. Item nested ones\n1.2. Item nested two  Item two  Item three  A single shelf  [8:]starts  at a  [8:]reshelving basket   $üß∫  _üìò..._üìï üëµ$  and  [2:]ends  right next to the  [2:]librarian's chair .  Item one  Item two  Item two.one  Item two.one.one  Item three  Item four  A single shelf  [8:]starts  at a  [8:]reshelving basket   $üß∫  _üìò..._üìï üëµ$  and  [2:]ends  right next to the  [2:]librarian's chair .  ~ Feature one  ~ Feature two  ~ Feature two.one  ~ Feature three  ~ Feature four  ~ A single shelf  [8:]starts  at a  [8:]reshelving basket   $üß∫  _üìò..._üìï üëµ$  and  [2:]ends  right next to the  [2:]librarian's chair .  ~ A single shelf  [8:]starts  at a  [8:]reshelving basket   $üß∫  _üìò..._üìï üëµ$  and  [2:]ends  right next to the  [2:]librarian's chair .  ~ Feature one  ~ Feature two\n2.1. ~ Feature two.one  ~ Feature three  ~ Feature four  ~ A single shelf  [8:]starts  at a  [8:]reshelving basket   $üß∫  _üìò..._üìï üëµ$  and  [2:]ends  right next to the  [2:]librarian's chair .  ~ A single shelf  [8:]starts  at a  [8:]reshelving basket   $üß∫  _üìò..._üìï üëµ$  and  [2:]ends  right next to the  [2:]librarian's chair .  ~ hi  In Code:  The  [8:]buckets  dictionary is our  [8:]bookcase (our  [8:]shelves ); each  [14:]key  is a  [14:]shelf number .  In Code:  ~ The  [8:]buckets  dictionary is our  [8:]bookcase (our  [8:]shelves ); each  [14:]key  is a  [14:]shelf number .  They have the  same remainder  when divided by  C a % c == b % c  Example:   14 mod 12 = 2  and  2 mod 12 = 2 .  They have the  same remainder  when divided by  C a % c == b % c  Example:   14 mod 12 = 2  and  2 mod 12 = 2 .  ~ They have the  same remainder  when divided by  C a % c == b % c  Example:   14 mod 12 = 2  and  2 mod 12 = 2 .",
    "sections": [],
    "codeBlocks": [],
    "keyTerms": [
      "after",
      "again",
      "basket",
      "bookcase",
      "buckets",
      "chair",
      "code",
      "comes",
      "contents",
      "dictionary",
      "divided",
      "each",
      "ends",
      "example",
      "feature",
      "five",
      "four",
      "have",
      "item",
      "key",
      "librarian",
      "list",
      "mod",
      "nested",
      "next",
      "number",
      "ones",
      "ordered",
      "part",
      "previous",
      "remainder",
      "reshelving",
      "resizable",
      "right",
      "same",
      "shelf",
      "shelves",
      "should",
      "single",
      "start",
      "starts",
      "svg",
      "table",
      "they",
      "three",
      "unordered",
      "when"
    ],
    "notations": [
      "(as 5 comes after 4)",
      "(our  [8:]shelves )",
      "(the svg should be 1.1)",
      "(the svg should be 1.2)",
      "(the svg should be 5.1)",
      "(the svg should be 5.2)",
      "üß∫  _üìò..._üìï üëµ$"
    ],
    "categories": [
      "list"
    ],
    "leetcodeProblems": []
  },
  "kadane": {
    "title": "Kadane's Algorithm",
    "route": "/notes/kadane",
    "filePath": "app/notes/kadane/page.mdx",
    "headings": [
      "Kadane's Algorithm",
      "Resizable Table of Contents",
      "Problem",
      "1. Maximum Subarray",
      "2. Maximum Product Subarray",
      "3. Maximum Sum of Circular Subarray",
      "4. Binary Tree Maximum Path Sum",
      "5. Max Sum of Rectangle No Larger Than K"
    ],
    "text": "Given an array of integers, return the maximum sum of any contiguous subarray.  53. Maximum Subarray   [!insight:collapse]  Greedy max-sum tracking & correctness  Kadane‚Äôs Algorithm is an   dynamic programming method for finding the maximum subarray sum in a list of integers (contiguous elements).  ~ Core idea:  Keep track of the best sum ending at the current position.  If adding the current number hurts the sum, start fresh from the current number.  Track the overall maximum as you go.  ~ Recurrence:  max_ending_here  =  max(num, max_ending_here + num)  max_so_far  =  max(max_so_far, max_ending_here)  ~  Example: \nFor  [-2,1,-3,4,-1,2,1,-5,4]  ‚Üí  6  ( [4,-1,2,1] ).  [!timecomplexity:collapse]   Given an array of integers, return the maximum product of any contiguous subarray.  152. Maximum Product Subarray   [!insight:collapse]  Dynamic product tracking & correctness  Kadane‚Äôs Algorithm can be adapted to track both max and min products, allowing for negative numbers.  ~ We track two states per index:  hi  = max product ending at current index.  lo  = min product ending at current index (could become max if multiplied by a negative).  ~\tWhy swap on negative:  Multiplying by a negative flips sign ‚Äî the previous max could become the new min and vice versa.  So when  x < 0 ,  hi  and  lo  swap before the update.  ~\tUpdate step:  hi = max(x, hi * x)  ‚Üí either start fresh from x or extend previous max.  lo = min(x, lo * x)  ‚Üí same but for min.  ~\tTrack global max:  max_prod = max(max_prod, hi)  each iteration.  ~ Zeros:\n-\tThey naturally reset the product because  max(x, hi * x)  will pick  x  when  x == 0 .  [!timecomplexity:collapse]   Given a circular array of integers, return the maximum sum of any contiguous subarray.  918. Maximum Sum of Circular Subarray   [!insight:collapse]  Kadane Min and Max for Circular Max Sum  ~ Run Kadane twice ‚Äî max for non-wrap and min for worst segment.  ~ Wrap max = total ‚àí min (everything except the worst segment).  ~ If  max_sum  < 0 (all-negative), return it; else return  max(max_sum, total ‚àí min_sum) .  [!timecomplexity:collapse]   Given a binary tree, find the maximum path sum.   [!insight:collapse]  Kadane on Trees  DFS returns the  best downward path sum  from each node (discarding negatives as 0).  At each node, check  node.val + left_gain + right_gain  for the  best path through this node  (could be root of global max).  Return  node.val + max(left_gain, right_gain)  so parent can extend the higher-gain branch.  [!timecomplexity]   ‚Äî each node visited once.  Given a 2D matrix and a target sum, return the maximum sum of any submatrix no larger than K.  363. Max Sum of Rectangle No Larger Than K   [!insight:collapse]  Turn the 2D problem into many 1D problems, then solve each 1D ‚Äúmax subarray ‚â§ k‚Äù optimally.  Uses  column-pair compression ,  Kadane‚Äôs algorithm , and  ordered prefix sums + binary search .  1. Column-pair compression ‚Üí transform 2D into 1D  Technique:  Fix two columns  (l, r)  and sum values row-wise between them.  Data:   row[i]  = sum of  matrix[i][l..r] .  Why:  Any contiguous block in  row  represents a rectangular submatrix between columns  l  and  r .  Example: \nMatrix:  1  2  3\n4  5  6\n7  8  9 Fix  (l=0, r=1)  ‚Üí take cols 0..1:  Row sums = [1+2, 4+5, 7+8] = [3, 9, 15] Now  [3, 9, 15]  is a 1D problem.  Where in code:  for r in range(l, n):\n    for i in range(m):\n        row[i] += mat[i][r] 2. Kadane‚Äôs algorithm (fast path)  Technique:  Standard Kadane finds the max subarray sum in O(n) without constraints.  Data:  Works on the compressed  row  array.  Why:  If Kadane‚Äôs result ‚â§ k, that‚Äôs optimal for this  (l, r) , so skip heavier search.  Example: \nFor  row = [3, 9, 15]  and  k = 30 :\nKadane = 27 (whole array sum) ‚Üí ‚â§ 30, so no binary search needed.  Where in code:  fast = kadane_leq(row, k)\nif fast is not None:\n    ans = max(ans, fast)\n    if ans == k: return k\n    continue 3. Ordered prefix sums + binary search (constrained Kadane)  Technique:  Maintain sorted list of prefix sums; for running sum  s , binary search for smallest prefix ‚â•  s - k .  Data:  Prefix sums of  row  as we scan.  Why:  This ensures  s - prefix ‚â§ k  and is the closest possible to k. Handles negatives optimally.  Example: \n row = [3, -2, 5] ,  k = 6 :  Prefix list starts  [0] ,  s = 0 .  Add 3 ‚Üí search for ‚â•  3-6=-3  ‚Üí match 0 ‚Üí sum = 3.  Add -2 ‚Üí s=1 ‚Üí search for ‚â• -5 ‚Üí match 0 ‚Üí sum = 1.  Add 5 ‚Üí s=6 ‚Üí search for ‚â• 0 ‚Üí match 0 ‚Üí sum = 6 (best).  Where in code:  s, pref = 0, [0]\nfor v in row:\n    s += v\n    j = bisect_left(pref, s - k)\n    if j < len(pref):\n        ans = max(ans, s - pref[j])\n        if ans == k: return k\n    insort(pref, s) 4. Loop ordering optimization  Technique:  Transpose if  rows > cols  so outer loops iterate over smaller dimension.  Data:  The matrix itself.  Why:  Reduces number of  (l, r)  pairs ‚Üí less total work.  Example: \nIf matrix is 100x1000 ‚Üí transpose to 1000x100 so  min(m,n)=100  for outer loops.  Where in code:  if m > n:\n    mat = [list(r) for r in zip(*mat)]\n    m, n = n, m [!timecomplexity:collapse]",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/kadane.py#method:Kadane.maxSubArray",
        "fileSource": "backend/algorithms/kadane.py",
        "className": "Kadane",
        "methodName": "maxSubArray"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/kadane.py#method:Kadane.maxProduct",
        "fileSource": "backend/algorithms/kadane.py",
        "className": "Kadane",
        "methodName": "maxProduct"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/kadane.py#method:Kadane.maxSubarraySumCircular",
        "fileSource": "backend/algorithms/kadane.py",
        "className": "Kadane",
        "methodName": "maxSubarraySumCircular"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/kadane.py#method:Kadane.maxPathSum",
        "fileSource": "backend/algorithms/kadane.py",
        "className": "Kadane",
        "methodName": "maxPathSum"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/kadane.py#method:Kadane.maxSumSubmatrix",
        "fileSource": "backend/algorithms/kadane.py",
        "className": "Kadane",
        "methodName": "maxSumSubmatrix"
      },
      {
        "language": "text",
        "content": "1  2  3\n4  5  6\n7  8  9"
      },
      {
        "language": "text",
        "content": "Row sums = [1+2, 4+5, 7+8] = [3, 9, 15]"
      },
      {
        "language": "python",
        "content": "for r in range(l, n):\n    for i in range(m):\n        row[i] += mat[i][r]"
      },
      {
        "language": "python",
        "content": "fast = kadane_leq(row, k)\nif fast is not None:\n    ans = max(ans, fast)\n    if ans == k: return k\n    continue"
      },
      {
        "language": "python",
        "content": "s, pref = 0, [0]\nfor v in row:\n    s += v\n    j = bisect_left(pref, s - k)\n    if j < len(pref):\n        ans = max(ans, s - pref[j])\n        if ans == k: return k\n    insort(pref, s)"
      },
      {
        "language": "python",
        "content": "if m > n:\n    mat = [list(r) for r in zip(*mat)]\n    m, n = n, m"
      }
    ],
    "keyTerms": [
      "adapted",
      "adding",
      "algorithm",
      "all-negative",
      "allowing",
      "ans",
      "array",
      "because",
      "become",
      "before",
      "best",
      "between",
      "binary",
      "bisect_left",
      "block",
      "both",
      "branch",
      "check",
      "circular",
      "closest",
      "code",
      "collapse",
      "cols",
      "column-pair",
      "columns",
      "compressed",
      "compression",
      "constrained",
      "constraints",
      "contents",
      "contiguous",
      "continue",
      "core",
      "correctness",
      "could",
      "current",
      "data",
      "dfs",
      "dimension",
      "discarding",
      "downward",
      "dynamic",
      "each",
      "either",
      "elements",
      "else",
      "ending",
      "ensures",
      "everything",
      "example",
      "except",
      "extend",
      "fast",
      "find",
      "finding",
      "finds",
      "fix",
      "flips",
      "fresh",
      "from",
      "given",
      "global",
      "greedy",
      "handles",
      "heavier",
      "higher-gain",
      "hurts",
      "idea",
      "index",
      "insight",
      "insort",
      "integers",
      "into",
      "iterate",
      "iteration",
      "itself",
      "kadane",
      "kadane_leq",
      "keep",
      "larger",
      "left_gain",
      "len",
      "less",
      "list",
      "loop",
      "loops",
      "maintain",
      "many",
      "mat",
      "match",
      "matrix",
      "max",
      "max-sum",
      "max_ending_here",
      "max_prod",
      "max_so_far",
      "max_sum",
      "maximum",
      "method",
      "min",
      "min_sum",
      "multiplied",
      "multiplying",
      "naturally",
      "needed",
      "negative",
      "negatives",
      "node",
      "non-wrap",
      "none",
      "num",
      "number",
      "numbers",
      "o",
      "once",
      "optimal",
      "optimally",
      "optimization",
      "ordered",
      "ordering",
      "outer",
      "over",
      "overall",
      "pairs",
      "parent",
      "path",
      "pick",
      "position",
      "possible",
      "pref",
      "prefix",
      "previous",
      "problem",
      "problems",
      "product",
      "products",
      "programming",
      "range",
      "rectangle",
      "rectangular",
      "recurrence",
      "reduces",
      "represents",
      "reset",
      "resizable",
      "result",
      "return",
      "returns",
      "right_gain",
      "root",
      "row",
      "row-wise",
      "rows",
      "running",
      "same",
      "scan",
      "search",
      "segment",
      "sign",
      "skip",
      "smaller",
      "smallest",
      "solve",
      "sorted",
      "standard",
      "start",
      "starts",
      "states",
      "step",
      "subarray",
      "submatrix",
      "sum",
      "sums",
      "swap",
      "table",
      "take",
      "target",
      "technique",
      "than",
      "that",
      "them",
      "then",
      "they",
      "through",
      "timecomplexity",
      "total",
      "track",
      "tracking",
      "transform",
      "transpose",
      "tree",
      "trees",
      "turn",
      "twice",
      "update",
      "uses",
      "val",
      "values",
      "versa",
      "vice",
      "visited",
      "when",
      "where",
      "whole",
      "will",
      "without",
      "work",
      "works",
      "worst",
      "wrap",
      "zeros",
      "zip"
    ],
    "notations": [
      "( [4,-1,2,1] )",
      "(*mat)",
      "(all-negative)",
      "(ans, fast)",
      "(ans, s - pref[j])",
      "(best)",
      "(constrained Kadane)",
      "(contiguous elements)",
      "(could be root of global max)",
      "(could become max if multiplied by a negative)",
      "(discarding negatives as 0)",
      "(everything except the worst segment)",
      "(fast path)",
      "(l, n)",
      "(l, r)",
      "(l=0, r=1)",
      "(left_gain, right_gain)",
      "(m)",
      "(m,n)",
      "(max_prod, hi)",
      "(max_so_far, max_ending_here)",
      "(max_sum, total ‚àí min_sum)",
      "(n)",
      "(num, max_ending_here + num)",
      "(pref)",
      "(pref, s - k)",
      "(pref, s)",
      "(r)",
      "(row, k)",
      "(whole array sum)",
      "(x, hi * x)",
      "(x, lo * x)",
      "x100",
      "x1000"
    ],
    "categories": [
      "kadane"
    ],
    "leetcodeProblems": [
      {
        "number": "53",
        "name": "Maximum Subarray",
        "url": "https://leetcode.com/problems/maximum-subarray/",
        "section": "1. Maximum Subarray"
      },
      {
        "number": "152",
        "name": "Maximum Product Subarray",
        "url": "https://leetcode.com/problems/maximum-product-subarray/",
        "section": "2. Maximum Product Subarray"
      },
      {
        "number": "918",
        "name": "Maximum Sum of Circular Subarray",
        "url": "https://leetcode.com/problems/maximum-sum-circular-subarray/",
        "section": "3. Maximum Sum of Circular Subarray"
      },
      {
        "number": "363",
        "name": "Max Sum of Rectangle No Larger Than K",
        "url": "https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/",
        "section": "5. Max Sum of Rectangle No Larger Than K"
      }
    ]
  },
  "games": {
    "title": "Games",
    "route": "/notes/games",
    "filePath": "app/notes/games/page.mdx",
    "headings": [
      "Games",
      "Resizable Table of Contents",
      "Problems",
      "1. Sudoku",
      "1.1 Valid Sudoku",
      "1.2 Sudoku Solver",
      "2. Stone Game",
      "2.1 Stone Game IV",
      "2.2 Stone Game III"
    ],
    "text": "36. Valid Sudoku  Given a partially filled 9√ó9 board with digits  $1$‚Äì$9$  and  $.$  for empty cells, determine if it is valid \n [19:]no duplicates in any row, column, or 3√ó3 sub-box. You do not need to solve it.   [!insight:collapse]  cube_index and think locally  cube_index := (r // 3) * 3 + (c // 3)  treats the 9√ó9 board as a 3√ó3 grid of 3√ó3 boxes:  r//3  gives which box-row (0,1,2) you‚Äôre in  c//3  gives which box-column (0,1,2)  Multiplying the box-row by 3 and adding the box-column yields a unique index 0‚Äì8 for each 3√ó3 cube  Think locally  If a repeated digit is found in a row, column, or cube, instantly stop.  [!timecomplexity:collapse]  $O(81)$  ( [19:]i.e.,   $O(n^2)$ )  Fixed 9√ó9 boards scan at most 81 cells. Generalized   Sudoku validation runs in  $O(n^2)$  time.  37. Sudoku Solver  Given a partially filled 9√ó9 board with digits  $1$‚Äì$9$  and  $.$  for empty cells, solve it. \n [19:]It is guaranteed that the input board has only one solution   [!insight:collapse]  MRV (Minimum Remaining Values)  Candidates per cell:  {'1'..'9'} ‚àí (row $‚à™$ col $‚à™$ box) .  MRV:  pick the empty cell with the fewest candidates to prune hardest.  Place a digit  tentatively , update sets, recurse; undo on failure ( backtrack ).  If any cell has  0 candidates , the branch is impossible ‚Üí backtrack immediately.  [!complexity:collapse]  Sudoku Solver (MRV) ‚Äî Complexity  Let  k  be the number of empty cells (‚â§ 81).  Time:  worst case   practically   where   = MRV-picked cell‚Äôs candidate count at step   (usually ‚â™ 9)  MRV selection adds   per level (‚â§   per path), dominated by the search  Space:  board/bookkeeping is constant on fixed 9√ó9 ‚áí   recursion depth   Alice and Bob start with  n  stones. On each turn, remove a non-zero perfect square. The player with no move loses. Decide if Alice (first) wins under optimal play.  1510. Stone Game IV   [!Intuition:collapse]  Minimax  Paradigm : This is a classic  impartial game  solved using the  Minimax  principle on game states.  Insight : A position is defined as  winning  if you can make  any  move to a position that you know is  losing  for your opponent. The DP builds this win/loss classification for every number of stones up to  n , starting from the base case that 0 stones is a losing position.  [!timecomplexity:collapse]   (try all squares for each  x )  Array  stoneValue ; players alternately take  1‚Äì3  stones from the left maximizing score difference. Return  \"Alice\" ,  \"Bob\" , or  \"Tie\"  under optimal play.  1406. Stone Game III   [!insight:collapse]  Score-difference DP  Let  dp[i]  = max score difference current player can achieve starting at index  i .\nTransition:  dp[i] = max_{k‚àà{1,2,3}} (sum(i..i+k-1) ‚àí dp[i+k]) . Answer from  dp[0] .  [!timecomplexity:collapse]   (constant 3 choices per  i )",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/games/valid_sudoku.py#method:Sudoku.isValidSudoku",
        "fileSource": "backend/algorithms/games/valid_sudoku.py",
        "className": "Sudoku",
        "methodName": "isValidSudoku"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/games/sudoku_solver.py#method:SudokuSolver.solveSudoku",
        "fileSource": "backend/algorithms/games/sudoku_solver.py",
        "className": "SudokuSolver",
        "methodName": "solveSudoku"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=./backend/algorithms/dp.py#method:DP.winnerSquareGame",
        "fileSource": "./backend/algorithms/dp.py",
        "className": "DP",
        "methodName": "winnerSquareGame"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=./backend/algorithms/games/stone_3.py#method:StoneGameIII.stoneGameIII",
        "fileSource": "./backend/algorithms/games/stone_3.py",
        "className": "StoneGameIII",
        "methodName": "stoneGameIII"
      }
    ],
    "keyTerms": [
      "achieve",
      "adding",
      "adds",
      "alice",
      "alternately",
      "answer",
      "array",
      "backtrack",
      "base",
      "board",
      "boards",
      "bob",
      "bookkeeping",
      "box",
      "box-column",
      "box-row",
      "boxes",
      "branch",
      "builds",
      "candidate",
      "candidates",
      "case",
      "cell",
      "cells",
      "choices",
      "classic",
      "classification",
      "col",
      "collapse",
      "column",
      "complexity",
      "constant",
      "contents",
      "count",
      "cube",
      "cube_index",
      "current",
      "decide",
      "defined",
      "depth",
      "determine",
      "difference",
      "digit",
      "digits",
      "dominated",
      "duplicates",
      "each",
      "empty",
      "every",
      "failure",
      "fewest",
      "filled",
      "first",
      "fixed",
      "found",
      "from",
      "game",
      "games",
      "generalized",
      "given",
      "gives",
      "grid",
      "guaranteed",
      "hardest",
      "iii",
      "immediately",
      "impartial",
      "impossible",
      "index",
      "input",
      "insight",
      "instantly",
      "intuition",
      "k-1",
      "know",
      "left",
      "level",
      "locally",
      "loses",
      "losing",
      "loss",
      "make",
      "max",
      "max_",
      "maximizing",
      "minimax",
      "minimum",
      "most",
      "move",
      "mrv",
      "mrv-picked",
      "multiplying",
      "need",
      "non-zero",
      "number",
      "o",
      "only",
      "opponent",
      "optimal",
      "paradigm",
      "partially",
      "path",
      "perfect",
      "pick",
      "place",
      "play",
      "player",
      "players",
      "position",
      "practically",
      "principle",
      "problems",
      "prune",
      "recurse",
      "recursion",
      "remaining",
      "remove",
      "repeated",
      "resizable",
      "return",
      "row",
      "runs",
      "scan",
      "score",
      "score-difference",
      "search",
      "selection",
      "sets",
      "solution",
      "solve",
      "solved",
      "solver",
      "space",
      "square",
      "squares",
      "start",
      "starting",
      "states",
      "step",
      "stone",
      "stones",
      "stonevalue",
      "stop",
      "sub-box",
      "sudoku",
      "sum",
      "table",
      "take",
      "tentatively",
      "that",
      "think",
      "tie",
      "time",
      "timecomplexity",
      "transition",
      "treats",
      "turn",
      "under",
      "undo",
      "unique",
      "update",
      "using",
      "usually",
      "valid",
      "validation",
      "values",
      "where",
      "which",
      "win",
      "winning",
      "wins",
      "with",
      "worst",
      "yields",
      "your"
    ],
    "notations": [
      "( [19:]i.e.,   $O(n^2)",
      "( backtrack )",
      "(0,1,2)",
      "(81)",
      "(MRV)",
      "(Minimum Remaining Values)",
      "(c // 3)",
      "(constant 3 choices per  i )",
      "(first)",
      "(n^2)",
      "(r // 3)",
      "(row $‚à™$ col $‚à™$ box)",
      "(sum(i..i+k-1)",
      "(try all squares for each  x )",
      "(usually ‚â™ 9)",
      "(‚â§   per path)",
      "(‚â§ 81)",
      ".$",
      "1$",
      "9$",
      "O(81)$",
      "O(n^2)$",
      "‚à™$"
    ],
    "categories": [
      "games"
    ],
    "leetcodeProblems": [
      {
        "number": "36",
        "name": "Valid Sudoku",
        "url": "https://leetcode.com/problems/valid-sudoku/",
        "section": "1.1 Valid Sudoku"
      },
      {
        "number": "37",
        "name": "Sudoku Solver",
        "url": "https://leetcode.com/problems/sudoku-solver/",
        "section": "1.2 Sudoku Solver"
      },
      {
        "number": "1510",
        "name": "Stone Game IV",
        "url": "https://leetcode.com/problems/stone-game-iv/",
        "section": "2.1 Stone Game IV"
      },
      {
        "number": "1406",
        "name": "Stone Game III",
        "url": "https://leetcode.com/problems/stone-game-iii/",
        "section": "2.2 Stone Game III"
      }
    ]
  },
  "dfs": {
    "title": "Depth-First Search (DFS)",
    "route": "/notes/dfs",
    "filePath": "app/notes/dfs/page.mdx",
    "headings": [
      "Depth-First Search (DFS)"
    ],
    "text": "",
    "sections": [],
    "codeBlocks": [],
    "keyTerms": [
      "depth-first",
      "dfs",
      "search"
    ],
    "notations": [
      "(DFS)"
    ],
    "categories": [
      "dfs"
    ],
    "leetcodeProblems": []
  },
  "dijkstra": {
    "title": "Dijkstra's Algorithm",
    "route": "/notes/dijkstra",
    "filePath": "app/notes/dijkstra/page.mdx",
    "headings": [
      "Dijkstra's Algorithm",
      "Resizable table of contents",
      "Description",
      "Code Snippet (Binary Heap)",
      "Runtime Analysis",
      "Example: Your Personal Transit Map",
      "Problems",
      "1. The Classic Broadcast: Network Delay Time",
      "2. The Thrifty Hike: Path With Minimum Effort",
      "3. Swim in Rising Water",
      "4. Cheapest Flights Within K Stops",
      "5. Shortest Path in a Grid with Obstacles Elimination"
    ],
    "text": "import TransitMapAnimation from '@/components/notes/trip';  Given a directed or undirected graph with  non-negative edge weights ( ), and a source vertex  , compute the  shortest path distance  to every vertex: .   Let   be the number of vertices and   the number of edges.\nLet  ,  , and   be the costs of insert, extract-min, and decrease-key:  In practice,  binary heaps  are preferred: they offer near-optimal performance with simple, efficient implementations.\nFibonacci heaps achieve better asymptotic bounds but are rarely used due to large constant factors and implementation complexity.  You're planning the fastest routes from  Home  to various destinations:\n Work , the  Gym , and the nearby transit  Stations .  The Map: \n Home ‚Üí Station A: 5 \n Home ‚Üí Station B: 12 \n Station A ‚Üí Gym: 10 \n Station B ‚Üí Gym: 2 \n Station B ‚Üí Work: 20  743. Network Delay Time  Given  n  nodes labeled  1  through  n \nand directed travel times between them, find the minimum time for a signal starting at node  k \nto reach  all  nodes. If impossible, return -1   [!insight:collapse]  This is Dijkstra's canonical use case: finding the shortest time for a signal to reach every node from a single source.  This is a direct application where  \"distance\" is time . The algorithm finds the shortest time from  k  to every other node. The final answer is the  maximum  of these shortest times, which represents the moment the  last  node receives the signal.  [!timecomplexity:collapse]  V (Vertices):  The number of vertices corresponds to the input  n , the total number of nodes.  E (Edges):  The number of edges corresponds to the length of the input list  times , as each element in  times  defines a single directed edge.  By substituting these into the standard Dijkstra complexity formula,  , you get  .  1631. Path With Minimum Effort  Find a path from the top-left to the bottom-right of a height grid that minimizes the \"effort\".\nEffort is the single largest height difference between any two adjacent cells on the path.   [!insight:collapse]  This problem redefines \"cost.\" It's not the sum of a path's edges but its single most challenging step: \nThe graph is the grid. The key is redefining path cost.\nInstead of a  [13:]sum  of the path, the  [16:]cost is its bottleneck: the max_effort_so_far .  Dijkstra's greedy choice to always explore the path with the minimum current max_effort naturally finds the route with the overall minimum bottleneck.  [!timecomplexity:collapse]  time complexity for Dijkstra's on a grid.  General Dijkstra Complexity  First, the standard time complexity for Dijkstra's algorithm when using a priority queue (like Python's  heapq ) is  .  V (Vertices):  The total number of nodes in the graph.  E (Edges):  The total number of connections between nodes.  log V:  This part comes from the cost of push and pop operations on the priority queue, which can hold up to all   vertices.  Applying to a Grid  Now, let's map the graph terms  V  and  E  to a grid with  R  rows and  C  columns.  Vertices (V):  Each cell in the grid is a vertex. So, the total number of vertices is  .  Edges (E):  Each cell can have an edge connecting to its neighbors (up, down, left, right). At most, each of the   cells has 4 edges. Therefore, the total number of edges   is proportional to  , which we write as  .  Putting It Together  By substituting the grid values back into the general formula, we get the final complexity:  ~  Start with the general formula:    ~  Substitute E:    ~  Substitute V:    So, the complexity   represents the cost of visiting each cell's edges ( ) and, for each edge, potentially performing an operation on the priority queue that costs  .  778. Swim in Rising Water  You are given an  N x N  grid of elevations. Find the minimum \"time\"  t  to travel from  (0, 0)  to  (N-1, N-1) .\nYou can only move between adjacent cells if their elevation is less than or equal to the time  t  ```python file=backend/algorithms/dijkstra.py#func:swimInWater   meta=\"/[2:]grid[0][0]/\"\n``` [!insight:collapse]  This problem elegantly frames a \"bottleneck\" challenge. (similar to the  Path With Minimum Effort \nYou must find a path where the highest point is as low as possible.\nThis code uses  Dijkstra's algorithm  where the path \"cost\" is not a sum, but the  maximum elevation  encountered so far. The priority queue always explores the path requiring the lowest water level ( time ). By doing this, the first time it reaches the destination, it guarantees it has found the path with the absolute minimum water level required.\nnotice  pq=[( [6:]grid[0][0] , 0, 0)]  [!timecomplexity:collapse]  The standard time complexity for Dijkstra's algorithm using a priority queue is  , where:  V  is the number of vertices (nodes).  E  is the number of edges.  When we apply this to an   grid:  ~  Vertices (V):  Each of the cells is a vertex, so  .  ~  Edges (E):  Each cell connects to at most 4 neighbors, so the total number of edges is roughly  . In Big O notation, this is just  .  Substituting these into the formula gives us:\n  Using the logarithm property that  , we can simplify   to  . This gives us:\n  Finally, we drop the constant factor  2 , leaving the final time complexity as  .\nThe  log N  part comes directly from the cost of the  heappush  and  heappop  operations on the priority queue.  787. Cheapest Flights Within K Stops  Find the cheapest flight from a source to a destination with at most  k  stops.  [!warning:collapse] Achieve   with  Bellman-Ford ,faster than this modified Dijkstra's   N  = number of cities\n E  = number of flights\n k  = number of stops\nWhile this Dijkstra approach works, with  Bellman-Ford  we can achieve   which is faster than our modified Dijkstra's   by a logarithmic term.   [!insight:collapse]  This problem requires a  modified Dijkstra's algorithm .\nThe state in the priority queue is expanded to  (cost, city, stops)  to track the stop count.\nTo optimize, we prune any path that reaches a city with more stops than a previously found path to that same city.  [!timecomplexity:collapse]   Standard Dijkstra:  Complexity is  , where  V  is the number of nodes (cities). The priority queue holds at most  V  items.  Modified Dijkstra (This problem):  The \"nodes\" in our search aren't just cities, but  states  defined by  (city, stops) .  log(Nk)  - The Size of the Priority Queue: \nSince we can visit each of the  N  cities with up to  k  different stop counts, the maximum number of unique states we might store in the priority queue is on the order of  N * k . This replaces the  V  in the standard  log(V)  term.  Ek  - The Number of Operations: \nIn the worst case, we might explore the outgoing edges ( E ) from a city for each possible stop count up to  k . This gives a loose upper bound on the number of times we push to the priority queue.  1293. Shortest Path in a Grid with Obstacles Elimination  Given an  m x n  grid where cells are either empty ( 0 ) or an obstacle ( 1 ), and an integer  k \nrepresenting the maximum number of obstacles you can eliminate, find the minimum number of steps to travel from the top-left corner  (0, 0) \nto the bottom-right  (m-1, n-1) . Each move (up, down, left, right) costs one step. If no such path exists, return  -1 .  [!warning:collapse]\nin practice,  A* Search  is faster.   [!timecomplexity:collapse]   Let:\n m  be the number of rows.\n n  be the number of columns.\n k  be the maximum number of eliminations.  The state in the search is defined by  (row, col, remaining_k) , leading to a total of  m * n * k  possible states. The time complexity is driven by the priority queue operations ( heappush  and  heappop ), which take logarithmic time relative to the number of items in the queue.  Therefore, the complexity is the total number of states multiplied by the logarithmic cost of the heap operations.",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/dijkstra.py#func:dijkstra ",
        "fileSource": "backend/algorithms/dijkstra.py",
        "functionName": "dijkstra"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/dijkstra.py#func:networkDelayTime   ",
        "fileSource": "backend/algorithms/dijkstra.py",
        "functionName": "networkDelayTime"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/dijkstra.py#func:minimumEffortPath   ",
        "fileSource": "backend/algorithms/dijkstra.py",
        "functionName": "minimumEffortPath"
      },
      {
        "language": "text",
        "content": "```python file=backend/algorithms/dijkstra.py#func:swimInWater   meta=\"/[2:]grid[0][0]/\"\n```"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/dijkstra.py#func:findCheapestPriceDijkstra  ",
        "fileSource": "backend/algorithms/dijkstra.py",
        "functionName": "findCheapestPriceDijkstra"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/dijkstra.py#func:dijkstraShortestPath  ",
        "fileSource": "backend/algorithms/dijkstra.py",
        "functionName": "dijkstraShortestPath"
      }
    ],
    "keyTerms": [
      "absolute",
      "achieve",
      "adjacent",
      "algorithm",
      "algorithms",
      "always",
      "analysis",
      "answer",
      "application",
      "apply",
      "applying",
      "approach",
      "aren",
      "asymptotic",
      "back",
      "backend",
      "bellman-ford",
      "better",
      "between",
      "binary",
      "bottleneck",
      "bottom-right",
      "bound",
      "bounds",
      "broadcast",
      "canonical",
      "case",
      "cell",
      "cells",
      "challenge",
      "challenging",
      "cheapest",
      "choice",
      "cities",
      "city",
      "classic",
      "code",
      "col",
      "collapse",
      "columns",
      "comes",
      "complexity",
      "components",
      "compute",
      "connecting",
      "connections",
      "connects",
      "constant",
      "contents",
      "corner",
      "corresponds",
      "cost",
      "costs",
      "count",
      "counts",
      "current",
      "decrease-key",
      "defined",
      "defines",
      "delay",
      "description",
      "destination",
      "destinations",
      "difference",
      "different",
      "dijkstra",
      "direct",
      "directed",
      "directly",
      "distance",
      "doing",
      "down",
      "driven",
      "drop",
      "each",
      "edge",
      "edges",
      "efficient",
      "effort",
      "either",
      "elegantly",
      "element",
      "elevation",
      "elevations",
      "eliminate",
      "elimination",
      "eliminations",
      "empty",
      "encountered",
      "equal",
      "every",
      "example",
      "exists",
      "expanded",
      "explore",
      "explores",
      "extract-min",
      "factor",
      "factors",
      "far",
      "faster",
      "fastest",
      "fibonacci",
      "file",
      "final",
      "finally",
      "find",
      "finding",
      "finds",
      "first",
      "flight",
      "flights",
      "formula",
      "found",
      "frames",
      "from",
      "func",
      "general",
      "given",
      "gives",
      "graph",
      "greedy",
      "grid",
      "guarantees",
      "gym",
      "have",
      "heap",
      "heappop",
      "heappush",
      "heapq",
      "heaps",
      "height",
      "highest",
      "hike",
      "hold",
      "holds",
      "home",
      "implementation",
      "implementations",
      "import",
      "impossible",
      "input",
      "insert",
      "insight",
      "instead",
      "integer",
      "into",
      "items",
      "just",
      "key",
      "labeled",
      "large",
      "largest",
      "last",
      "leading",
      "leaving",
      "left",
      "length",
      "less",
      "level",
      "like",
      "list",
      "log",
      "logarithm",
      "logarithmic",
      "loose",
      "low",
      "lowest",
      "m-1",
      "map",
      "max_effort",
      "max_effort_so_far",
      "maximum",
      "meta",
      "might",
      "minimizes",
      "minimum",
      "modified",
      "moment",
      "more",
      "most",
      "move",
      "multiplied",
      "must",
      "n-1",
      "naturally",
      "near-optimal",
      "nearby",
      "neighbors",
      "network",
      "node",
      "nodes",
      "non-negative",
      "notation",
      "notes",
      "notice",
      "number",
      "obstacle",
      "obstacles",
      "offer",
      "only",
      "operation",
      "operations",
      "optimize",
      "order",
      "other",
      "outgoing",
      "overall",
      "part",
      "path",
      "performance",
      "performing",
      "personal",
      "planning",
      "point",
      "pop",
      "possible",
      "potentially",
      "practice",
      "preferred",
      "previously",
      "priority",
      "problem",
      "problems",
      "property",
      "proportional",
      "prune",
      "push",
      "putting",
      "python",
      "queue",
      "rarely",
      "reach",
      "reaches",
      "receives",
      "redefines",
      "redefining",
      "relative",
      "remaining_k",
      "replaces",
      "representing",
      "represents",
      "required",
      "requires",
      "requiring",
      "resizable",
      "return",
      "right",
      "rising",
      "roughly",
      "route",
      "routes",
      "row",
      "rows",
      "runtime",
      "same",
      "search",
      "shortest",
      "signal",
      "similar",
      "simple",
      "simplify",
      "since",
      "single",
      "size",
      "snippet",
      "source",
      "standard",
      "start",
      "starting",
      "state",
      "states",
      "station",
      "stations",
      "step",
      "steps",
      "stop",
      "stops",
      "store",
      "substitute",
      "substituting",
      "such",
      "sum",
      "swim",
      "swiminwater",
      "table",
      "take",
      "term",
      "terms",
      "than",
      "that",
      "their",
      "them",
      "therefore",
      "these",
      "they",
      "thrifty",
      "through",
      "time",
      "timecomplexity",
      "times",
      "together",
      "top-left",
      "total",
      "track",
      "transit",
      "transitmapanimation",
      "travel",
      "trip",
      "undirected",
      "unique",
      "upper",
      "used",
      "uses",
      "using",
      "values",
      "various",
      "vertex",
      "vertices",
      "visit",
      "visiting",
      "warning",
      "water",
      "weights",
      "when",
      "where",
      "which",
      "while",
      "with",
      "within",
      "work",
      "works",
      "worst",
      "write",
      "your"
    ],
    "notations": [
      "( )",
      "( 0 )",
      "( 1 )",
      "( E )",
      "( [6:]grid[0][0] , 0, 0)",
      "( heappush  and  heappop )",
      "(0, 0)",
      "(Binary Heap)",
      "(E)",
      "(Edges)",
      "(N-1, N-1)",
      "(Nk)",
      "(This problem)",
      "(V)",
      "(Vertices)",
      "(cities)",
      "(city, stops)",
      "(cost, city, stops)",
      "(like Python's  heapq )",
      "(m-1, n-1)",
      "(nodes)",
      "(row, col, remaining_k)",
      "(similar to the  Path With Minimum Effort \nYou must find a path where the highest point is as low as possible.\nThis code uses  Dijkstra's algorithm  where the path \"cost\" is not a sum, but the  maximum elevation  encountered so far. The priority queue always explores the path requiring the lowest water level ( time )",
      "(up, down, left, right)"
    ],
    "categories": [
      "dijkstra"
    ],
    "leetcodeProblems": [
      {
        "number": "743",
        "name": "Network Delay Time",
        "url": "https://leetcode.com/problems/network-delay-time/",
        "section": "1\\. The Classic Broadcast: Network Delay Time"
      },
      {
        "number": "1631",
        "name": "Path With Minimum Effort",
        "url": "https://leetcode.com/problems/path-with-minimum-effort/",
        "section": "2. The Thrifty Hike: Path With Minimum Effort"
      },
      {
        "number": "778",
        "name": "Swim in Rising Water",
        "url": "https://leetcode.com/problems/swim-in-rising-water/",
        "section": "3\\. Swim in Rising Water"
      },
      {
        "number": "787",
        "name": "Cheapest Flights Within K Stops",
        "url": "https://leetcode.com/problems/cheapest-flights-within-k-stops/",
        "section": "4\\. Cheapest Flights Within K Stops"
      },
      {
        "number": "1293",
        "name": "Shortest Path in a Grid with Obstacles Elimination",
        "url": "https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",
        "section": "5\\. Shortest Path in a Grid with Obstacles Elimination"
      }
    ]
  },
  "cache": {
    "title": "Cache",
    "route": "/notes/cache",
    "filePath": "app/notes/cache/page.mdx",
    "headings": [
      "Cache",
      "Resizable table of contents",
      "Caching Strategies: LRU and LFU",
      "LRU Cache: Evicting the Oldest",
      "Example: The Library Convenience Shelf",
      "Python Implementation",
      "LFU Cache: Evicting the Rarest",
      "Example: Bookcase with Multiple Convenience Shelves",
      "Python Implementation"
    ],
    "text": "Caching is a fundamental technique in computer science used to store frequently accessed data temporarily in a faster-to-access location (a \"cache\"). When the cache reaches its capacity, an eviction policy decides which item to discard to make room for new ones. Two popular policies are  Least Recently Used (LRU)  and  Least Frequently Used (LFU) . Both can be implemented to achieve  O(1)  time complexity for their core operations.  An  LRU (Least Recently Used)  cache discards the item that hasn't been accessed for the longest time. The logic is simple: if you haven't used something recently, you're less likely to use it in the near future.  This policy is efficiently implemented using an  OrderedDict  in Python, which internally combines a hash map for fast lookups and a doubly-linked list to maintain insertion order.  get(key) : When an item is accessed, it becomes the most recently used. We fetch the item and move it to the end of the  OrderedDict .  put(key, value) : When an item is added or updated, it's also considered the most recently used and is added to the end. If the cache exceeds its capacity, the item at the front of the  OrderedDict  (the least recently used) is removed.  The Setup:  A single shelf  [8:]starts  at a  [8:]reshelving basket   $üß∫  _üìò..._üìï üëµ$  and  [2:]ends  right next to the  [2:]librarian's chair .  The Action:  When a book is needed ( get  or  put ), the librarian places it on the shelf right beside her chair‚Äîat the very  end  of the line.  As she adds books, the line gets pushed down the shelf until the book at the far end(the one at the beginning of the shelf) falls into the basket. This evicted book is the one that was least recently used.  In Code:  cache.move_to_end(key)  places a book at the  [2:]end , near the  [2:]librarian's chair .  cache.popitem(last=False)  drops the book farthest from the librarian(a.k.a. the one at the  [8:]beginning  of the shelf) into the  [8:]basket .   An  LFU (Least Frequently Used)  cache tracks how often each item is accessed. When eviction is necessary, it removes the item with the lowest access count. If there's a tie (multiple items have the same lowest frequency), the least recently used among them is chosen.  This requires a more complex structure:  A  cache dictionary  ( key ‚Üí value ) for the main data store.  A  frequency dictionary  ( key ‚Üí frequency_count ).  A  buckets dictionary  that groups keys by their frequency count. Each bucket is an  OrderedDict  to maintain LRU order within that frequency level ( frequency_count ‚Üí OrderedDict[key, None] ).  When an item is accessed ( get  or  put ), its frequency count is incremented, and it moves from its current frequency bucket to the next, becoming the most recent item in that new bucket. For eviction, we remove the least recently used item from the lowest frequency bucket.  The librarian notices a flaw in her simple system: a popular book can be pushed out by a burst of new, less important books. To solve this, she upgrades.  The Setup:  Instead of one shelf, she now has a small bookcase with  multiple shelves , stacked vertically. This is the  LFU (Least Frequently Used)  system, which tracks a book's  popularity .  The Action: \n> -  The shelves represent popularity levels. The  bottom shelf (#1)  is for newcomers (used once), the shelf above it  (#2)  is for books used twice, and so on.\n> -  When a book on a lower shelf (say, Shelf #1) is needed again, it gets a  promotion!  The librarian moves it up to Shelf #2 and places it in the spot  right next to her chair ‚Äîat the end of that new line. It is now the most recently used among all books with a popularity score of two.\n> -  For  eviction , she always takes from the  bottom shelf (#1) , since it holds the least popular books. From that shelf, she removes the book at the far end‚Äîthe one closest to the basket.  This protects popular books by moving them up the bookcase, away from the eviction zone on the bottom shelf.  In Code:  The  [8:]buckets  dictionary is our  [8:]bookcase (our  [8:]shelves ); each  [14:]key  is a  [14:]shelf number .",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/cache.py#class:LRUCache  ",
        "fileSource": "backend/algorithms/cache.py"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/cache.py#class:LFUCache  ",
        "fileSource": "backend/algorithms/cache.py"
      }
    ],
    "keyTerms": [
      "above",
      "access",
      "accessed",
      "achieve",
      "action",
      "added",
      "adds",
      "again",
      "also",
      "always",
      "among",
      "away",
      "basket",
      "becomes",
      "becoming",
      "been",
      "beginning",
      "beside",
      "book",
      "bookcase",
      "books",
      "both",
      "bottom",
      "bucket",
      "buckets",
      "burst",
      "cache",
      "caching",
      "capacity",
      "chair",
      "chosen",
      "closest",
      "code",
      "combines",
      "complex",
      "complexity",
      "computer",
      "considered",
      "contents",
      "convenience",
      "core",
      "count",
      "current",
      "data",
      "decides",
      "dictionary",
      "discard",
      "discards",
      "doubly-linked",
      "down",
      "drops",
      "each",
      "efficiently",
      "end",
      "ends",
      "evicted",
      "evicting",
      "eviction",
      "example",
      "exceeds",
      "falls",
      "false",
      "far",
      "farthest",
      "fast",
      "faster-to-access",
      "fetch",
      "flaw",
      "frequency",
      "frequency_count",
      "frequently",
      "from",
      "front",
      "fundamental",
      "future",
      "get",
      "gets",
      "groups",
      "hash",
      "hasn",
      "have",
      "haven",
      "holds",
      "implementation",
      "implemented",
      "important",
      "incremented",
      "insertion",
      "instead",
      "internally",
      "into",
      "item",
      "items",
      "key",
      "keys",
      "last",
      "least",
      "less",
      "level",
      "levels",
      "lfu",
      "librarian",
      "library",
      "likely",
      "line",
      "list",
      "location",
      "logic",
      "longest",
      "lookups",
      "lower",
      "lowest",
      "lru",
      "main",
      "maintain",
      "make",
      "map",
      "more",
      "most",
      "move",
      "move_to_end",
      "moves",
      "moving",
      "multiple",
      "near",
      "necessary",
      "needed",
      "newcomers",
      "next",
      "none",
      "notices",
      "number",
      "o",
      "often",
      "oldest",
      "once",
      "ones",
      "operations",
      "order",
      "ordereddict",
      "places",
      "policies",
      "policy",
      "popitem",
      "popular",
      "popularity",
      "promotion",
      "protects",
      "pushed",
      "put",
      "python",
      "rarest",
      "reaches",
      "recent",
      "recently",
      "remove",
      "removed",
      "removes",
      "represent",
      "requires",
      "reshelving",
      "resizable",
      "right",
      "room",
      "same",
      "science",
      "score",
      "setup",
      "shelf",
      "shelves",
      "simple",
      "since",
      "single",
      "small",
      "solve",
      "something",
      "spot",
      "stacked",
      "starts",
      "store",
      "strategies",
      "structure",
      "system",
      "table",
      "takes",
      "technique",
      "temporarily",
      "that",
      "their",
      "them",
      "there",
      "tie",
      "time",
      "tracks",
      "twice",
      "until",
      "updated",
      "upgrades",
      "used",
      "using",
      "value",
      "vertically",
      "very",
      "when",
      "which",
      "with",
      "within",
      "zone"
    ],
    "notations": [
      "( frequency_count ‚Üí OrderedDict[key, None] )",
      "( get  or  put )",
      "( key ‚Üí frequency_count )",
      "( key ‚Üí value )",
      "(#1)",
      "(#2)",
      "(1)",
      "(LFU)",
      "(LRU)",
      "(Least Frequently Used)",
      "(Least Recently Used)",
      "(a \"cache\")",
      "(a.k.a. the one at the  [8:]beginning  of the shelf)",
      "(key)",
      "(key, value)",
      "(last=False)",
      "(multiple items have the same lowest frequency)",
      "(our  [8:]shelves )",
      "(say, Shelf #1)",
      "(the least recently used)",
      "(the one at the beginning of the shelf)",
      "(used once)",
      "üß∫  _üìò..._üìï üëµ$"
    ],
    "categories": [
      "cache"
    ],
    "leetcodeProblems": []
  },
  "code": {
    "title": "code",
    "route": "/notes/code",
    "filePath": "app/notes/code/page.mdx",
    "headings": [],
    "text": "",
    "sections": [],
    "codeBlocks": [],
    "keyTerms": [],
    "notations": [],
    "categories": [
      "code"
    ],
    "leetcodeProblems": []
  },
  "dp": {
    "title": "Dynamic Programming(DP)",
    "route": "/notes/dp",
    "filePath": "app/notes/dp/page.mdx",
    "headings": [
      "Dynamic Programming(DP)",
      "Resizable Table Of contents",
      "Examples",
      "1. Triangle",
      "2. Partition Equal Subset Sum",
      "3. Coin Change II",
      "4. Solving Questions With Brainpower",
      "See Also"
    ],
    "text": "Dynamic Programming (DP) is an algorithmic technique for  optimization  or  counting  problems that exibit the following properties:  ~  Optimal substructure : the best solution for the whole problem is formed from optimal solutions to its subproblems.  ~  Overlapping subproblems : identical subproblems recur multiple times, allowing reuse of results to avoid exponential recomputation.  DP can be implemented in two equivalent ways:  ~  Top-down (memoization) : start from the  root state  (the full problem), recursively compute only needed subproblems, cache results, and implicitly traverse the subproblem DAG in  reverse topological order .  ~  Bottom-up (tabulation) : explicitly define a  topological order  over all states (e.g., by increasing substring length or decreasing index) and iteratively fill a table from base cases up to the root‚Äîeliminating recursion overhead and directly matching the memoized logic.  Both methods yield identical results. Top-down is  straightforward to write , while bottom-up is typically  more efficient in practice  and easy to derive by unrolling memoized recursion in topological order.  Given a  triangle  (list of lists), find the minimum path sum from top to bottom. From index  i  in a row, you may move to index  i  or  i + 1  in the next row.  120. Triangle   [!Intuition:collapse]  Paradigm : This is a classic bottom-up dynamic programming problem.  Insight : The minimum path to the bottom  from  any cell  (r, c)  is independent of the path taken  to  that cell. This allows us to start at the bottom (where path sums are known) and iteratively compute the optimal path for each cell on the row above by choosing the cheaper of its two children's already-computed optimal paths.  [!timecomplexity:collapse]   where   is the total number of cells in the triangle. The complexity is the number of subproblems ( ), as each is solved once.  Given an integer array  nums , determine if you can partition it into two subsets with an equal sum.  416. Partition Equal Subset Sum   [!Intuition:collapse]  Paradigm : This is the  0/1 Knapsack  decision problem in disguise.  Insight : The problem transforms from partitioning an array into a simpler question: can a subset of \"items\" ( nums ) perfectly fill a \"knapsack\" with capacity  total_sum / 2 ? Each item's weight is equal to its value.  [!timecomplexity:collapse]   where  N  is the number of elements and  Sum  is the target subset sum.  Given an array of coin denominations and a total amount, return the number of combinations of coins that make up that amount. You can assume an infinite number of each coin.  518. Coin Change II   [!Intuition:collapse]  Paradigm : This is a classic  Unbounded Knapsack  counting problem.  Insight : To count  combinations  without overcounting  permutations  ( 1+2  vs  2+1 ), the DP imposes a strict processing order on the coins. This ensures that combinations are always built in the same sequence (e.g., using smaller denomination coins before larger ones), elegantly eliminating duplicates.  [!timecomplexity:collapse]   where  n  is the number of coins and  amount  is the target.  Given a list of  questions  where  questions[i] = [points·µ¢, brainpower·µ¢] , you process from i=0 and at each i choose to either solve (gain  points·µ¢  and jump  brainpower·µ¢ + 1 ) or skip (move to  i + 1 ). Return the maximum points achievable.  2140. Solving Questions With Brainpower   [!Intuition:collapse]  Paradigm : This is a  longest path problem on a Directed Acyclic Graph (DAG) .  Insight : The maximum score obtainable  from  any question  i  is a fixed value, regardless of past choices. This allows a backward pass from the end of the exam (where the future score is 0), calculating the optimal future score for each question by simply choosing the  max()  of two pre-computed paths: the one from \"solving\" vs. the one from \"skipping\".  [!timecomplexity:collapse]   where  n  is the number of questions.  Stone Game IV  Stone Game III",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=./backend/algorithms/dp.py#method:DP.minimumTotal",
        "fileSource": "./backend/algorithms/dp.py",
        "className": "DP",
        "methodName": "minimumTotal"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=./backend/algorithms/dp.py#method:DP.canPartition",
        "fileSource": "./backend/algorithms/dp.py",
        "className": "DP",
        "methodName": "canPartition"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=./backend/algorithms/dp.py#method:DP.change",
        "fileSource": "./backend/algorithms/dp.py",
        "className": "DP",
        "methodName": "change"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=./backend/algorithms/dp.py#method:DP.mostPoints",
        "fileSource": "./backend/algorithms/dp.py",
        "className": "DP",
        "methodName": "mostPoints"
      }
    ],
    "keyTerms": [
      "above",
      "achievable",
      "acyclic",
      "algorithmic",
      "allowing",
      "allows",
      "already-computed",
      "also",
      "always",
      "amount",
      "array",
      "assume",
      "avoid",
      "backward",
      "base",
      "before",
      "best",
      "both",
      "bottom",
      "bottom-up",
      "brainpower",
      "built",
      "cache",
      "calculating",
      "capacity",
      "cases",
      "cell",
      "cells",
      "change",
      "cheaper",
      "children",
      "choices",
      "choose",
      "choosing",
      "classic",
      "coin",
      "coins",
      "collapse",
      "combinations",
      "complexity",
      "compute",
      "contents",
      "count",
      "counting",
      "dag",
      "decision",
      "decreasing",
      "define",
      "denomination",
      "denominations",
      "derive",
      "determine",
      "directed",
      "directly",
      "disguise",
      "duplicates",
      "dynamic",
      "each",
      "easy",
      "efficient",
      "either",
      "elegantly",
      "elements",
      "eliminating",
      "ensures",
      "equal",
      "equivalent",
      "exam",
      "examples",
      "exibit",
      "explicitly",
      "exponential",
      "fill",
      "find",
      "fixed",
      "following",
      "formed",
      "from",
      "full",
      "future",
      "gain",
      "game",
      "given",
      "graph",
      "identical",
      "iii",
      "implemented",
      "implicitly",
      "imposes",
      "increasing",
      "independent",
      "index",
      "infinite",
      "insight",
      "integer",
      "into",
      "intuition",
      "item",
      "items",
      "iteratively",
      "jump",
      "knapsack",
      "known",
      "larger",
      "length",
      "list",
      "lists",
      "logic",
      "longest",
      "make",
      "matching",
      "max",
      "maximum",
      "memoization",
      "memoized",
      "methods",
      "minimum",
      "more",
      "move",
      "multiple",
      "needed",
      "next",
      "number",
      "nums",
      "obtainable",
      "once",
      "ones",
      "only",
      "optimal",
      "optimization",
      "order",
      "over",
      "overcounting",
      "overhead",
      "overlapping",
      "paradigm",
      "partition",
      "partitioning",
      "pass",
      "past",
      "path",
      "paths",
      "perfectly",
      "permutations",
      "points",
      "practice",
      "pre-computed",
      "problem",
      "problems",
      "process",
      "processing",
      "programming",
      "properties",
      "question",
      "questions",
      "recomputation",
      "recur",
      "recursion",
      "recursively",
      "regardless",
      "resizable",
      "results",
      "return",
      "reuse",
      "reverse",
      "root",
      "row",
      "same",
      "score",
      "sequence",
      "simpler",
      "simply",
      "skip",
      "skipping",
      "smaller",
      "solution",
      "solutions",
      "solve",
      "solved",
      "solving",
      "start",
      "state",
      "states",
      "stone",
      "straightforward",
      "strict",
      "subproblem",
      "subproblems",
      "subset",
      "subsets",
      "substring",
      "substructure",
      "sum",
      "sums",
      "table",
      "tabulation",
      "taken",
      "target",
      "technique",
      "that",
      "timecomplexity",
      "times",
      "top-down",
      "topological",
      "total",
      "total_sum",
      "transforms",
      "traverse",
      "triangle",
      "typically",
      "unbounded",
      "unrolling",
      "using",
      "value",
      "ways",
      "weight",
      "where",
      "while",
      "whole",
      "with",
      "without",
      "write",
      "yield"
    ],
    "notations": [
      "( )",
      "( 1+2  vs  2+1 )",
      "( nums )",
      "(DAG)",
      "(DP)",
      "(e.g., by increasing substring length or decreasing index)",
      "(e.g., using smaller denomination coins before larger ones)",
      "(gain  points·µ¢  and jump  brainpower·µ¢ + 1 )",
      "(list of lists)",
      "(memoization)",
      "(move to  i + 1 )",
      "(r, c)",
      "(tabulation)",
      "(the full problem)",
      "(where path sums are known)",
      "(where the future score is 0)"
    ],
    "categories": [
      "dp"
    ],
    "leetcodeProblems": [
      {
        "number": "120",
        "name": "Triangle",
        "url": "https://leetcode.com/problems/triangle/",
        "section": "1. Triangle"
      },
      {
        "number": "416",
        "name": "Partition Equal Subset Sum",
        "url": "https://leetcode.com/problems/partition-equal-subset-sum/",
        "section": "2. Partition Equal Subset Sum"
      },
      {
        "number": "518",
        "name": "Coin Change II",
        "url": "https://leetcode.com/problems/coin-change-ii/",
        "section": "3. Coin Change II"
      },
      {
        "number": "2140",
        "name": "Solving Questions With Brainpower",
        "url": "https://leetcode.com/problems/solving-questions-with-brainpower/",
        "section": "4. Solving Questions With Brainpower"
      }
    ]
  },
  "bfs": {
    "title": "Breadth-First Search (BFS)",
    "route": "/notes/bfs",
    "filePath": "app/notes/bfs/page.mdx",
    "headings": [
      "Breadth-First Search (BFS)",
      "Resizable table of contents",
      "Problems",
      "1. Binary Tree Level Order Traversal",
      "2. Number of Islands",
      "3. Rotting Oranges",
      "4. Clone Graph",
      "5. Snakes and Ladders",
      "6. 01 Matrix",
      "7. Shortest Path in a Grid with Obstacles Elimination",
      "8. Word Ladder"
    ],
    "text": "Given the root of a binary tree, return its nodes' values organized by level,\nfrom left to right.  102. Binary Tree Level Order Traversal  ```python file=backend/algorithms/bfs.py#func:levelOrder  \n``` [!insight:collapse]  for _ in range(len(queue))  ,  len(queue)  is the level size.  The core logic hinges on the inner  for  loop. The expression  len(queue) \ntakes a  \"snapshot\"  of the number of nodes on the current level before the loop begins. The loop then dequeues and processes exactly that many nodes, ensuring that only nodes from the current level are handled while their children are queued up for the next iteration. This technique is the key to cleanly separating the levels.  [!timecomplexity:collapse]   where   is the total number of nodes in the tree. This is optimal as every node must be visited once.  Given an  m x n  2D grid of '1's (land) and '0's (water), return the number of islands. An island is formed by connecting adjacent lands horizontally or vertically. \nassume all four edges of the grid are all surrounded by water.  200. Number of Islands   [!insight:collapse] Find, Count, and Sink üèùÔ∏è  The strategy is to scan every cell of the grid. If an unvisited piece of land ( 1 ) is found, you've discovered a new island, so you increment the  islands  counter. Then, immediately launch a BFS from that cell to find and \"sink\" all connected parts of that same island by changing their value to  0 . This modification of the grid ensures each island group is counted exactly once.  [!timecomplexity:collapse]   where   and   are the dimensions of the grid. This is optimal as each cell is visited a constant number of times.  In a grid of  0 s (empty),  1 s (fresh), and  2 s (rotten), every minute, any fresh orange adjacent to a rotten one becomes rotten. Return the minimum minutes required until no fresh oranges remain. If it's impossible, return -1.  994. Rotting Oranges   [!insight:collapse] Multi-Source BFS üçä  This problem is a classic multi-source BFS. The key is to initialize the queue with the coordinates of  all  initially rotten oranges. The BFS then naturally simulates the rotting process in parallel from all sources. Each \"level\" of the BFS corresponds to one minute passing. Finally, you must check if any  fresh_oranges  remain to handle cases where some are unreachable.  [!timecomplexity:collapse]   where   and   are the grid dimensions. Each cell is enqueued and dequeued at most once, making the process highly efficient and optimal.  Given a reference to a node in a connected undirected graph, return a deep copy (clone) of the graph.  133. Clone Graph   [!insight:collapse] Hash Map as a Visited Set & Node Cache üó∫Ô∏è  The key to traversing a potentially cyclic graph is a  visited  set. Here, the  cloned  dictionary serves a dual purpose. It acts as both a  visited  set  (by checking  if n not in cloned ) and a  cache  that maps an original node to its clone. This ensures each node is cloned exactly once and prevents getting stuck in an infinite loop.  [!timecomplexity:collapse]   where   is the number of vertices (nodes) and   is the number of edges. This is optimal as we must visit every node and traverse every edge to create the full copy.  Given an  $n \\times n$  integer board where cells are numbered from  1  to  $n^{2}$ \nin a Boustrophedonical style.\nEach cell's value is either  [3:]-1  for a  [3:]normal  square or a  [16:]destination  number for a  [16:]snake/ladder .\nStarting from square  1 , return the least number of moves to reach square  $n^{2}$ . You must take any snake or ladder you land on.  909. Snakes and Ladders  [!note:collapse]  Boustrophedonical Style  zigzag pattern  In this context,  Boustrophedonical  simply means the board is numbered in a back-and-forth, zigzag pattern. The numbering starts at  1  in the bottom-left corner, and the direction reverses on each row moving up the grid.  Example 4x4 Board Numbering:  ‚Üê| 16 15 14 13 | \n       ‚Üí|  9 10 11 12 | \n       ‚Üê|  8  7  6  5 | \n start ‚Üí|  1  2  3  4 |  [!insight:collapse] Flatten the Board First üé≤  The key insight here is to  pre-process the 2D  board  into a 1D  flat_board  list . This powerful first step handles all the complex Boustrophedonical logic upfront. By doing this, the BFS loop becomes exceptionally clean and avoids the need for a coordinate conversion function. The search can then operate on a simple 1D array, treating the board as the simple, linear graph it truly represents.  [!timecomplexity:collapse]   where   is the dimension of the board. The initial flattening of the board takes   time. The subsequent BFS visits each of the   squares at most once.  Given an  m x n  binary matrix, return the distance of the nearest  0  for each cell. The distance between two adjacent cells is 1.  542. 01 Matrix   [!insight:collapse]  Multi-Source BFS from the Target üéØ  Instead of starting a separate BFS from every  1  to find the nearest  0  (which would be slow), this approach inverts the problem. It starts a single,  multi-source BFS from all  0 s simultaneously . The level of the BFS at which a cell is reached is, by definition, its shortest distance to any  0 . This \"start from the answer\" strategy is a powerful technique for shortest path problems.  [!timecomplexity:collapse]   where   and   are the grid dimensions. Every cell is enqueued and processed exactly once, making this the optimal solution.  Find the length of the shortest path from the top-left to the bottom-right of a grid containing empty cells ( 0 ) and obstacles ( 1 ). You can move through a maximum of  k  obstacles.  1293. Shortest Path in a Grid with Obstacles Elimination  [!warning:collapse]\nin practice,  A* Search    is faster than this   .   [!insight:collapse]   BFS with State-Budget Pruning  Core idea:  Perform a standard BFS over  (row, col, steps, remaining_k)  states, but only enqueue a move if it arrives at a cell with  strictly more   remaining_k  than any prior visit.  Trivial shortcut:  If  k ‚â• rows+cols‚Äì2 , you can go straight in  rows+cols‚Äì2  steps without ever touching an obstacle.  Correctness guarantee:  Because BFS explores in order of increasing  steps , the first time you dequeue the goal is the fewest-step path. Pruning by  remaining_k  never discards any shorter-step route‚Äîit simply avoids re-exploring dominated states.  [!timecomplexity:collapse]   Worst-case   (every cell √ó every possible  ), but aggressive pruning usually makes it far faster in practice.  [!spacecomplexity:collapse]   for the  max_k  grid plus up to   queued states in the pathological worst case.  Given a  beginWord , an  endWord , and a dictionary  wordList , find the length of the shortest transformation sequence from  beginWord  to  endWord  such that only one letter is changed at a time and each transformed word exists in the  wordList .  127. Word Ladder   [!insight:collapse] Bidirectional BFS Meets in the Middle ü§ù  This solution uses two  optimizations. First, it  pre-computes all possible generic transformations  (e.g.,  h*t ) in a dictionary, allowing for instant lookups of neighboring words instead of generating them on the fly. Second, it performs a  bidirectional BFS , launching one search from the  beginWord  and another from the  endWord . By always expanding the smaller of the two frontiers, it drastically reduces the search space. The algorithm finishes when the two searches meet, at which point the shortest path is found.  [!timecomplexity:collapse]   where   is the number of words and   is the length of each word. The dominant operation is the initial pre-computation step to build the  combos  dictionary. The subsequent bidirectional search is typically much faster than this initial setup.",
    "sections": [],
    "codeBlocks": [
      {
        "language": "text",
        "content": "```python file=backend/algorithms/bfs.py#func:levelOrder  \n```"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bfs.py#func:numIslands   ",
        "fileSource": "backend/algorithms/bfs.py",
        "functionName": "numIslands"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bfs.py#func:orangesRotting   ",
        "fileSource": "backend/algorithms/bfs.py",
        "functionName": "orangesRotting"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bfs.py#func:cloneGraph ",
        "fileSource": "backend/algorithms/bfs.py",
        "functionName": "cloneGraph"
      },
      {
        "language": "text",
        "content": "\n       ‚Üê| 16 15 14 13 | \n       ‚Üí|  9 10 11 12 | \n       ‚Üê|  8  7  6  5 | \n start ‚Üí|  1  2  3  4 |  \n"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bfs.py#func:snakesAndLadders  ",
        "fileSource": "backend/algorithms/bfs.py",
        "functionName": "snakesAndLadders"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bfs.py#func:updateMatrix  ",
        "fileSource": "backend/algorithms/bfs.py",
        "functionName": "updateMatrix"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bfs.py#func:shortestPath  ",
        "fileSource": "backend/algorithms/bfs.py",
        "functionName": "shortestPath"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bfs.py#func:ladderLength  ",
        "fileSource": "backend/algorithms/bfs.py",
        "functionName": "ladderLength"
      }
    ],
    "keyTerms": [
      "acts",
      "adjacent",
      "aggressive",
      "algorithm",
      "algorithms",
      "allowing",
      "always",
      "another",
      "answer",
      "approach",
      "array",
      "arrives",
      "assume",
      "avoids",
      "back-and-forth",
      "backend",
      "because",
      "becomes",
      "before",
      "begins",
      "beginword",
      "between",
      "bfs",
      "bidirectional",
      "binary",
      "board",
      "both",
      "bottom-left",
      "bottom-right",
      "boustrophedonical",
      "breadth-first",
      "build",
      "cache",
      "case",
      "cases",
      "cell",
      "cells",
      "changed",
      "changing",
      "check",
      "checking",
      "children",
      "classic",
      "clean",
      "cleanly",
      "clone",
      "cloned",
      "col",
      "collapse",
      "cols",
      "combos",
      "complex",
      "connected",
      "connecting",
      "constant",
      "containing",
      "contents",
      "context",
      "conversion",
      "coordinate",
      "coordinates",
      "copy",
      "core",
      "corner",
      "correctness",
      "corresponds",
      "count",
      "counted",
      "counter",
      "create",
      "current",
      "cyclic",
      "deep",
      "definition",
      "dequeue",
      "dequeued",
      "dequeues",
      "destination",
      "dictionary",
      "dimension",
      "dimensions",
      "direction",
      "discards",
      "discovered",
      "distance",
      "doing",
      "dominant",
      "dominated",
      "drastically",
      "dual",
      "each",
      "edge",
      "edges",
      "efficient",
      "either",
      "elimination",
      "empty",
      "endword",
      "enqueue",
      "enqueued",
      "ensures",
      "ensuring",
      "ever",
      "every",
      "exactly",
      "example",
      "exceptionally",
      "exists",
      "expanding",
      "explores",
      "expression",
      "far",
      "faster",
      "fewest-step",
      "file",
      "finally",
      "find",
      "finishes",
      "first",
      "flat_board",
      "flatten",
      "flattening",
      "fly",
      "formed",
      "found",
      "four",
      "fresh",
      "fresh_oranges",
      "from",
      "frontiers",
      "full",
      "func",
      "function",
      "generating",
      "generic",
      "getting",
      "given",
      "goal",
      "graph",
      "grid",
      "group",
      "guarantee",
      "handle",
      "handled",
      "handles",
      "hash",
      "here",
      "highly",
      "hinges",
      "horizontally",
      "idea",
      "immediately",
      "impossible",
      "increasing",
      "increment",
      "infinite",
      "initial",
      "initialize",
      "initially",
      "inner",
      "insight",
      "instant",
      "instead",
      "integer",
      "into",
      "inverts",
      "island",
      "islands",
      "iteration",
      "key",
      "ladder",
      "ladders",
      "land",
      "lands",
      "launch",
      "launching",
      "least",
      "left",
      "len",
      "length",
      "letter",
      "level",
      "levelorder",
      "levels",
      "linear",
      "list",
      "logic",
      "lookups",
      "loop",
      "makes",
      "making",
      "many",
      "map",
      "maps",
      "matrix",
      "max_k",
      "maximum",
      "means",
      "meet",
      "meets",
      "middle",
      "minimum",
      "minute",
      "minutes",
      "modification",
      "more",
      "most",
      "move",
      "moves",
      "moving",
      "much",
      "multi-source",
      "must",
      "naturally",
      "nearest",
      "need",
      "neighboring",
      "never",
      "next",
      "node",
      "nodes",
      "normal",
      "note",
      "number",
      "numbered",
      "numbering",
      "obstacle",
      "obstacles",
      "once",
      "only",
      "operate",
      "operation",
      "optimal",
      "optimizations",
      "orange",
      "oranges",
      "order",
      "organized",
      "original",
      "over",
      "parallel",
      "parts",
      "passing",
      "path",
      "pathological",
      "pattern",
      "perform",
      "performs",
      "piece",
      "plus",
      "point",
      "possible",
      "potentially",
      "powerful",
      "practice",
      "pre-computation",
      "pre-computes",
      "pre-process",
      "prevents",
      "prior",
      "problem",
      "problems",
      "process",
      "processed",
      "processes",
      "pruning",
      "purpose",
      "python",
      "queue",
      "queued",
      "range",
      "re-exploring",
      "reach",
      "reached",
      "reduces",
      "reference",
      "remain",
      "remaining_k",
      "represents",
      "required",
      "resizable",
      "return",
      "reverses",
      "right",
      "root",
      "rotten",
      "rotting",
      "route",
      "row",
      "rows",
      "same",
      "scan",
      "search",
      "searches",
      "second",
      "separate",
      "separating",
      "sequence",
      "serves",
      "setup",
      "shortcut",
      "shorter-step",
      "shortest",
      "simple",
      "simply",
      "simulates",
      "simultaneously",
      "single",
      "sink",
      "size",
      "slow",
      "smaller",
      "snake",
      "snakes",
      "snapshot",
      "solution",
      "some",
      "sources",
      "space",
      "spacecomplexity",
      "square",
      "squares",
      "standard",
      "start",
      "starting",
      "starts",
      "state-budget",
      "states",
      "step",
      "steps",
      "straight",
      "strategy",
      "strictly",
      "stuck",
      "style",
      "subsequent",
      "such",
      "surrounded",
      "table",
      "take",
      "takes",
      "target",
      "technique",
      "than",
      "that",
      "their",
      "them",
      "then",
      "through",
      "time",
      "timecomplexity",
      "times",
      "top-left",
      "total",
      "touching",
      "transformation",
      "transformations",
      "transformed",
      "traversal",
      "traverse",
      "traversing",
      "treating",
      "tree",
      "trivial",
      "truly",
      "typically",
      "undirected",
      "unreachable",
      "until",
      "unvisited",
      "upfront",
      "uses",
      "usually",
      "value",
      "values",
      "vertically",
      "vertices",
      "visit",
      "visited",
      "visits",
      "warning",
      "water",
      "when",
      "where",
      "which",
      "while",
      "with",
      "without",
      "word",
      "wordlist",
      "words",
      "worst",
      "worst-case",
      "would",
      "zigzag"
    ],
    "notations": [
      "( 0 )",
      "( 1 )",
      "(BFS)",
      "(by checking  if n not in cloned )",
      "(clone)",
      "(e.g.,  h*t )",
      "(empty)",
      "(every cell √ó every possible  )",
      "(fresh)",
      "(land)",
      "(len(queue)",
      "(nodes)",
      "(queue)",
      "(rotten)",
      "(row, col, steps, remaining_k)",
      "(water)",
      "(which would be slow)",
      "n \\times n$",
      "n^{2}$",
      "x4"
    ],
    "categories": [
      "bfs"
    ],
    "leetcodeProblems": [
      {
        "number": "102",
        "name": "Binary Tree Level Order Traversal",
        "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
        "section": "1. Binary Tree Level Order Traversal"
      },
      {
        "number": "200",
        "name": "Number of Islands",
        "url": "https://leetcode.com/problems/number-of-islands/",
        "section": "2. Number of Islands"
      },
      {
        "number": "994",
        "name": "Rotting Oranges",
        "url": "https://leetcode.com/problems/rotting-oranges/",
        "section": "3. Rotting Oranges"
      },
      {
        "number": "133",
        "name": "Clone Graph",
        "url": "https://leetcode.com/problems/clone-graph/",
        "section": "4. Clone Graph"
      },
      {
        "number": "909",
        "name": "Snakes and Ladders",
        "url": "https://leetcode.com/problems/snakes-and-ladders/",
        "section": "5. Snakes and Ladders"
      },
      {
        "number": "542",
        "name": "01 Matrix",
        "url": "https://leetcode.com/problems/01-matrix/",
        "section": "6. 01 Matrix"
      },
      {
        "number": "1293",
        "name": "Shortest Path in a Grid with Obstacles Elimination",
        "url": "https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",
        "section": "7. Shortest Path in a Grid with Obstacles Elimination"
      },
      {
        "number": "127",
        "name": "Word Ladder",
        "url": "https://leetcode.com/problems/word-ladder/",
        "section": "8. Word Ladder"
      }
    ]
  },
  "bellman-ford": {
    "title": "Bellman-Ford",
    "route": "/notes/bellman-ford",
    "filePath": "app/notes/bellman-ford/page.mdx",
    "headings": [
      "Bellman-Ford",
      "Resizable Table of Contents",
      "Variant 1: Classical Bellman-Ford",
      "Variant 2: Graph Duplication with DAG Relaxation",
      "Comparison",
      "Problems",
      "1. Cheapest Flight Within K Stops",
      "2. Path with Maximum Probability"
    ],
    "text": "[!definition]\nGiven a directed graph  , edge weights  , and source node  , compute   for all  , or detect a negative-weight cycle reachable from  .  Algorithm:  ~ initialize distance estimates,  ~  Relax all edges |V|‚Äì1 times  to compute shortest paths( where each relaxation improves distance estimates ).  ~  Then  do one more pass (the  th):  ~ if any edge is relaxable (i.e., violates the triangle inequality) ‚Üí  negative-weight cycle exists .  ~ otherwise,  d(s, v) = Œ¥(s, v) for all v ‚àà V   Time:   Space:   [!comment]\nThis Classical Bellman-Ford solves  SSSP 's ( single-source shortest paths ),\nonly detects whether a negative-weight cycle exists ,it will not return such a negative weight cycle.  [!definition]\nLet   be the shortest path from   to   using   edges.\nConstruct DAG   with levels   to  , each node   tracks distance using   edges.\nIf  , then   is a witness to a negative cycle.  Algorithm:  Build   with (|V|+1) levels  Edges:  From  : weight 0  From  : weight   Run DAG Relaxation from   Final value   unless reachable from a witness ‚Üí    Time:   Space:   [!deepdive:collapse]  how  bellman_ford_layered_dag  maps to our layered‚ÄêDAG algorithm  Below we break the function into its five conceptual steps‚Äîshowing the exact code and explaining how it implements each part of Variant 2:  ~  Initialize Œ¥‚ÇÄ (distance 0 at  source , ‚àû elsewhere)  d = {v: float(\"inf\") for v in vertices}\nd[source], V = 0, len(vertices) Builds the initial  layer 0  distances,  $Œ¥_0(s, v)$ .  V  is the number of vertices (so we‚Äôll do V relaxation passes next).  ~  Layered relaxation: compute Œ¥‚ÇÅ‚Ä¶Œ¥_V  for k in range(V):            # k = 0‚Ä¶V-1\n    d_k = {**d}               # snapshot of Œ¥_k\n    for u, v, w in edges:\n        if d[u] + w < d_k[v]:\n            d_k[v] = d[u] + w  # build Œ¥_{k+1}(s,v)\n    d = d_k                   # now holds Œ¥_{k+1} Each iteration reads only from the old  d  ( ) and writes into  , so no two relaxations chain in one pass.  After pass k you get   in  d .  ~  Detect direct witnesses ( )  witnesses = {\n    v\n    for u, v, w in edges\n    if d[u] + w < d[v]\n}\nif not witnesses:\n    return d Any  v  still relaxable on the V-th pass is a  negative-cycle witness .  ~  Build successor list for propagation  adj = defaultdict(list)\nfor u, v, _ in edges:\n    adj[u].append(v) adj[u]  now lists every direct neighbor of  u  in the original graph, ready for a DFS flood-fill.  ~  Flood-fill ‚àí‚àû from each witness  stack    = list(witnesses)\nreachable = set(witnesses)\nwhile stack:\n    u = stack.pop()\n    d[u] = float(\"-inf\")\n    for v in adj[u]:\n        if v not in reachable:\n            reachable.add(v)\n            stack.append(v)\nreturn d Marks each witness  and  every node reachable from it as  .  This matches the variant 2's rule: any vertex reachable from a negative-cycle witness inherits  .  Together, these blocks exactly implement the  layered-DAG duplication  approach:  Steps 1‚Äì2  build all k-edge distances Œ¥‚ÇÄ‚Ä¶Œ¥_V in V passes.  Step 3  finds the true witnesses.  Steps 4‚Äì5  propagate the ‚Äú‚àí‚àû‚Äù label to all cycle-affected vertices.  Cheapest Flights With at Most K Stops  Find the cheapest flight from  src  to  dst  using at most  k  stops.   [!deepdive:collapse]  You have this DP for ‚Äúat most k stops‚Äù (‚â§k+1 edges):  d = [inf] * n\nd[src] = 0\nfor _ in range(k + 1):\n    tmp = d[:]    # snapshot of ‚Äú‚â§ i-edge‚Äù distances\n    for u, v, w in flights:\n        if d[u] + w < tmp[v]:\n            tmp[v] = d[u] + w\n    d = tmp\nreturn d[dst] if d[dst] < inf else -1 ~  Interpretation as layered DAG  Think of a DAG with layers 0‚Ä¶k+1. Layer i holds the best cost to each city using ‚â§ i flights (edges).  Before any loop,  d = Œ¥‚ÇÄ  (only the source is 0; others ‚àû).  After loop iteration i (0-indexed),  d = Œ¥_{i+1} : the best cost using ‚â§ (i+1) edges.  ~  Why the  tmp  array?  By writing into a fresh copy  tmp  while reading only from the old  d , you enforce that every relaxation uses exactly one additional edge.  If you instead updated  d  in place, a newly decreased  d[x]  could feed into another relaxation in the same pass‚Äîletting you string together multiple edges, which breaks the ‚Äú‚â§ i edges‚Äù guarantee and degenerates to the classic Bellman-Ford.  ~  Mapping to the variant 2's layered-DAG Bellman-Ford  variant 2  builds an explicit |V|+1 layer DAG, where each pass relaxes only edges from layer k‚àí1 ‚Üí k, so after k passes you have Œ¥‚Çñ(s,v).  Our Solution  does the same in ‚Äúsoftware‚Äù: each  for _ in range(k+1)  pass reads Œ¥‚Çñ from  d  and writes Œ¥‚Çñ‚Çä‚ÇÅ into  tmp .  After k+1 passes,  d[v] = Œ¥_{k+1}(s,v) .  ~  Classic (in-place) Bellman-Ford vs. layered version  ~  Classic BF \nrelaxes all edges in place for V‚àí1 passes ‚Üí d[v] may already incorporate paths of length > k within pass k.\nruns in O(V¬∑E) time, O(V) space, and can detect negative cycles by one extra pass‚Äîbut can‚Äôt recover them.  ~  Layered BF \nisolates each pass via a tmp copy ‚Üí d[v] = Œ¥‚Çñ exactly after pass k.  Layered runs in O(V¬∑E) time, O(V¬∑E) space if you build the DAG explicitly (but our code stays O(V+E) space), and can pinpoint witnesses and propagate ‚àí‚àû.  ~  Our Solution \ntmp array simulates the variant 2's DAG without building V√óV state.  ~  Time complexity \nEach of the k+1 passes scans all E edges ‚Üí   In summary:  our cheapest-flights solution  is  the layered-DAG Bellman-Ford in disguise. The  tmp  copy enforces strict layering (Œ¥‚Çñ‚ÜíŒ¥‚Çñ‚Çä‚ÇÅ), matching\nvariant 2's model, while in-place updates would collapse multiple hops per pass into the classic algorithm.  [!timecomplexity:collapse]\n  where  E  is the number of flights.  Path with Maximum Probability  In a graph with edges representing traversal probabilities,\nfind the path from a  start  to an  end  node with the highest success probability.",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bellman-ford.py#func:bellman_ford_classic  ",
        "fileSource": "backend/algorithms/bellman-ford.py",
        "functionName": "bellman_ford_classic"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bellman-ford.py#func:bellman_ford_layered_dag  ",
        "fileSource": "backend/algorithms/bellman-ford.py",
        "functionName": "bellman_ford_layered_dag"
      },
      {
        "language": "python",
        "content": "d = {v: float(\"inf\") for v in vertices}\nd[source], V = 0, len(vertices)"
      },
      {
        "language": "python",
        "content": "for k in range(V):            # k = 0‚Ä¶V-1\n    d_k = {**d}               # snapshot of Œ¥_k\n    for u, v, w in edges:\n        if d[u] + w < d_k[v]:\n            d_k[v] = d[u] + w  # build Œ¥_{k+1}(s,v)\n    d = d_k                   # now holds Œ¥_{k+1}"
      },
      {
        "language": "python",
        "content": "witnesses = {\n    v\n    for u, v, w in edges\n    if d[u] + w < d[v]\n}\nif not witnesses:\n    return d"
      },
      {
        "language": "python",
        "content": "adj = defaultdict(list)\nfor u, v, _ in edges:\n    adj[u].append(v)"
      },
      {
        "language": "python",
        "content": "stack    = list(witnesses)\nreachable = set(witnesses)\n\nwhile stack:\n    u = stack.pop()\n    d[u] = float(\"-inf\")\n    for v in adj[u]:\n        if v not in reachable:\n            reachable.add(v)\n            stack.append(v)\nreturn d"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bellman-ford.py#func:findCheapestPrice  ",
        "fileSource": "backend/algorithms/bellman-ford.py",
        "functionName": "findCheapestPrice"
      },
      {
        "language": "python",
        "content": "d = [inf] * n\nd[src] = 0\n\nfor _ in range(k + 1):\n    tmp = d[:]    # snapshot of ‚Äú‚â§ i-edge‚Äù distances\n    for u, v, w in flights:\n        if d[u] + w < tmp[v]:\n            tmp[v] = d[u] + w\n    d = tmp\n\nreturn d[dst] if d[dst] < inf else -1"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/bellman-ford.py#func:maxProbability  ",
        "fileSource": "backend/algorithms/bellman-ford.py",
        "functionName": "maxProbability"
      }
    ],
    "keyTerms": [
      "_0",
      "add",
      "additional",
      "adj",
      "after",
      "algorithm",
      "already",
      "another",
      "append",
      "approach",
      "array",
      "before",
      "bellman-ford",
      "bellman_ford_layered_dag",
      "below",
      "best",
      "blocks",
      "break",
      "breaks",
      "build",
      "building",
      "builds",
      "chain",
      "cheapest",
      "cheapest-flights",
      "city",
      "classic",
      "classical",
      "code",
      "collapse",
      "comment",
      "comparison",
      "complexity",
      "compute",
      "conceptual",
      "construct",
      "contents",
      "copy",
      "cost",
      "could",
      "cycle",
      "cycle-affected",
      "cycles",
      "d",
      "d_k",
      "dag",
      "decreased",
      "deepdive",
      "defaultdict",
      "definition",
      "degenerates",
      "detect",
      "detects",
      "dfs",
      "direct",
      "directed",
      "disguise",
      "distance",
      "distances",
      "does",
      "dst",
      "duplication",
      "each",
      "edge",
      "edges",
      "else",
      "elsewhere",
      "enforce",
      "enforces",
      "estimates",
      "every",
      "exact",
      "exactly",
      "exists",
      "explaining",
      "explicit",
      "explicitly",
      "extra",
      "feed",
      "final",
      "find",
      "finds",
      "five",
      "flight",
      "flights",
      "float",
      "flood-fill",
      "fresh",
      "from",
      "function",
      "given",
      "graph",
      "guarantee",
      "have",
      "highest",
      "holds",
      "hops",
      "i-edge",
      "implement",
      "implements",
      "improves",
      "in-place",
      "incorporate",
      "indexed",
      "inequality",
      "inf",
      "inherits",
      "initial",
      "initialize",
      "instead",
      "interpretation",
      "into",
      "isolates",
      "iteration",
      "k-edge",
      "label",
      "layer",
      "layered",
      "layered-dag",
      "layering",
      "layers",
      "len",
      "length",
      "letting",
      "levels",
      "list",
      "lists",
      "loop",
      "mapping",
      "maps",
      "marks",
      "matches",
      "matching",
      "maximum",
      "model",
      "more",
      "most",
      "multiple",
      "negative",
      "negative-cycle",
      "negative-weight",
      "neighbor",
      "newly",
      "next",
      "node",
      "number",
      "o",
      "only",
      "original",
      "others",
      "otherwise",
      "part",
      "pass",
      "passes",
      "path",
      "paths",
      "pinpoint",
      "place",
      "pop",
      "probabilities",
      "probability",
      "problems",
      "propagate",
      "propagation",
      "range",
      "reachable",
      "reading",
      "reads",
      "ready",
      "recover",
      "relax",
      "relaxable",
      "relaxation",
      "relaxations",
      "relaxes",
      "representing",
      "resizable",
      "return",
      "rule",
      "runs",
      "same",
      "scans",
      "set",
      "shortest",
      "showing",
      "simulates",
      "single-source",
      "snapshot",
      "software",
      "solution",
      "solves",
      "source",
      "space",
      "src",
      "sssp",
      "stack",
      "start",
      "state",
      "stays",
      "step",
      "steps",
      "still",
      "stops",
      "strict",
      "string",
      "success",
      "successor",
      "such",
      "summary",
      "table",
      "that",
      "them",
      "then",
      "these",
      "think",
      "time",
      "timecomplexity",
      "times",
      "tmp",
      "together",
      "tracks",
      "traversal",
      "triangle",
      "true",
      "unless",
      "updated",
      "updates",
      "uses",
      "using",
      "v-1",
      "v-th",
      "value",
      "variant",
      "version",
      "vertex",
      "vertices",
      "violates",
      "weight",
      "weights",
      "where",
      "whether",
      "which",
      "while",
      "will",
      "with",
      "within",
      "without",
      "witness",
      "witnesses",
      "would",
      "writes",
      "writing"
    ],
    "notations": [
      "( )",
      "( single-source shortest paths )",
      "( where each relaxation improves distance estimates )",
      "(\"-inf\")",
      "(\"inf\")",
      "(0-indexed)",
      "(V)",
      "(V¬∑E)",
      "(but our code stays O(V+E)",
      "(distance 0 at  source , ‚àû elsewhere)",
      "(edges)",
      "(i+1)",
      "(i.e., violates the triangle inequality)",
      "(in-place)",
      "(k + 1)",
      "(k+1)",
      "(list)",
      "(only the source is 0; others ‚àû)",
      "(s, v)",
      "(s,v)",
      "(so we‚Äôll do V relaxation passes next)",
      "(the  th)",
      "(v)",
      "(vertices)",
      "(witnesses)",
      "(|V|+1)",
      "(Œ¥‚Çñ‚ÜíŒ¥‚Çñ‚Çä‚ÇÅ)",
      "(‚â§k+1 edges)",
      "Œ¥",
      "Œ¥_0(s, v)$"
    ],
    "categories": [
      "bellman-ford"
    ],
    "leetcodeProblems": []
  },
  "binary-search": {
    "title": "Binary search",
    "route": "/notes/binary-search",
    "filePath": "app/notes/binary-search/page.mdx",
    "headings": [
      "Binary search",
      "Resizable Table of Contents",
      "Finding the Leftmost Insertion Point",
      "Finding the Rightmost Insertion Point",
      "Examples",
      "1. Search Insert Position",
      "2. Find First and Last Position of Element in Sorted Array",
      "3. Find Minimum in Rotated Sorted Array",
      "4. Koko Eating Bananas",
      "5. Capacity To Ship Packages Within D Days"
    ],
    "text": "Binary search is an efficient  $O(\\log n)$  algorithm for finding an item in a  sorted  list .\nIt works by repeatedly dividing the list in half.  The core idea is to compare the target value with the middle element of the list.\nIf they are not equal, the half in which the target cannot lie is eliminated,\nand the search continues on the remaining half.  Given a sorted list  a  and a target  x , return the index at which  x  should be inserted to maintain order.\n(i.e.  first  position  i  where  a[i] >= x )   [!tip]\nWhen  a[mid]  is greater than or equal to  x , we set  r = mid .\nThis ensures we keep considering the  mid  index as a potential answer and forces the search to\nconverge on the leftmost possible index.  Given a sorted list  a  and a target  x , return the index at which  x  should be inserted to maintain order.\n(i.e.  first  position  i  where  a[i] > x )   [!tip]\nWhen  a[mid]  is less than or equal to  x , we set  l = mid + 1 .\nThis effectively pushes the search past all elements equal to  x , ensuring the final index is just after the rightmost occurrence.  35. Search Insert Position  Given a sorted array of distinct integers and a target value, find the index of the target.\nIf absent, return the index where it would be inserted to maintain order.   [!tip]\nPython's  bisect  module is the standard for binary search.\nSee  Finding the Leftmost Insertion Point  for simplified  bisect_left .  34. Find First and Last Position of Element in Sorted Array  Given a sorted array of integers  nums  that may contain duplicates,\nfind the starting and ending indices of a given  target . If the target is not in the array, return  [-1, -1] .   [!tip]\n bisect_left  finds the first position where  target  could be inserted, and\n bisect_right  finds the first position  after  all\nexisting  target s.  153. Find Minimum in Rotated Sorted Array  Given a unique-element sorted array that has been rotated at an unknown pivot, find its minimum value.   [!intuition:collapse]\nThe goal is to find the  inflection point  in the rotated list (where the numbers switch from high to low) ‚Äî this point is the minimum element.\nWe use a modified binary search to home in on this point.  The key is comparing the middle element  nums[mid]  with the rightmost element  nums[r] . This comparison tells us which part of the array is currently sorted and can be discarded.  Case 1:  nums[mid] < nums[r]  Example:  In  [4, 5, 1, 2, 3] , if  mid  points to  1 ,  nums[mid]  ( 1 ) is less than  nums[r]  ( 3 ).  Logic:  This indicates that the entire right portion of the array from  mid  to  r  (i.e.,  [1, 2, 3] ) is sorted. The minimum element could be  nums[mid]  itself, or it could be to its left. We can safely search the left half (including  mid ) by setting  r = mid .  Case 2:  nums[mid] >= nums[r]  Example:  In  [4, 5, 1, 2, 3] , if  mid  points to  5  in an earlier step,  nums[mid]  ( 5 ) is greater than  nums[r]  ( 3 ).  Logic:  This indicates that the inflection point (the minimum value) must lie to the right of  mid . The left portion  [4, 5]  is sorted but contains values larger than the true minimum. We discard this left portion by setting  l = mid + 1 .  The loop terminates when  l  and  r  converge, at which point  nums[l]  is the smallest element.  875. Koko Eating Bananas  Given banana piles  piles  and hour limit  h ,\nfind the minimum eating speed  $k‚àà‚Ñï$  such that\n $\\displaystyle \\sum_{i=1}^{|piles|} \\left\\lceil \\frac{p_i}{k} \\right\\rceil \\le h$ \nwhere each hour Koko eats up to  $k$  bananas from one pile\n(any leftover hour is wasted)   [!intuition:collapse]  binary searching the answer space, (the eating speed  k )  The range of possible speeds is from  1  to  max(piles) .  The key property is that the problem is  monotonic  (if a speed  k  is fast enough, any speed greater than  k  will also be fast enough). This allows us to binary search for the  minimum  valid speed.  We test a mid speed ( k = (l + r) // 2 ). If it's valid ( hours(k) <= h ), we try to find a smaller valid speed by searching the lower half ( r = k ). If it's too slow, we must increase the speed by searching the upper half ( l = k + 1 ). The loop converges on the smallest  k  that works. üçå  [!timecomplexity]\n , where  $n$  is the number of piles and  $m$  is the maximum pile size.  1011. Capacity To Ship Packages Within D Days  Given a list of weights and a number of days, find the minimum capacity of a ship that can ship all the weights within the given number of days.   [!intuition:collapse] Binary Search on the Answer Space  (ship's capacity)  The search space for the answer (the ship's capacity) ranges from a lower bound of  max(weights) to carry the heaviest item, to an upper bound of  sum(weights)  to ship everything in one day.  The problem has a  monotonic property  ideal for binary search. The function  daysNeeded(capacity)  is monotonically non-increasing: as  capacity  grows, the days required can only decrease or stay the same.  This creates a predictable  [False, ..., False, True, ..., True]  sequence for our condition,  daysNeeded(capacity) <= days . The goal is to find the leftmost  True , which represents the minimal valid capacity.  If  daysNeeded(capacity) <= days  is  True , then  capacity  is a potential answer, and we try for a better (smaller) one in the left half by setting  r = capacity .  If it is  False , then  capacity  is too small, and we must search for a larger capacity in the right half by setting  l = capacity + 1 .",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/binary_search.py#func:simple_bisect_left ",
        "fileSource": "backend/algorithms/binary_search.py",
        "functionName": "simple_bisect_left"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/binary_search.py#func:simple_bisect_right",
        "fileSource": "backend/algorithms/binary_search.py",
        "functionName": "simple_bisect_right"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/binary_search.py#func:searchInsert",
        "fileSource": "backend/algorithms/binary_search.py",
        "functionName": "searchInsert"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/binary_search.py#func:searchRange",
        "fileSource": "backend/algorithms/binary_search.py",
        "functionName": "searchRange"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/binary_search.py#func:findMin",
        "fileSource": "backend/algorithms/binary_search.py",
        "functionName": "findMin"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/binary_search.py#func:minEatingSpeed",
        "fileSource": "backend/algorithms/binary_search.py",
        "functionName": "minEatingSpeed"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/binary_search.py#func:shipWithinDays",
        "fileSource": "backend/algorithms/binary_search.py",
        "functionName": "shipWithinDays"
      }
    ],
    "keyTerms": [
      "absent",
      "after",
      "algorithm",
      "allows",
      "also",
      "answer",
      "array",
      "banana",
      "bananas",
      "been",
      "better",
      "binary",
      "bisect",
      "bisect_left",
      "bisect_right",
      "bound",
      "cannot",
      "capacity",
      "carry",
      "case",
      "collapse",
      "compare",
      "comparing",
      "comparison",
      "condition",
      "considering",
      "contain",
      "contains",
      "contents",
      "continues",
      "converge",
      "converges",
      "core",
      "could",
      "creates",
      "currently",
      "days",
      "daysneeded",
      "decrease",
      "discard",
      "discarded",
      "displaystyle",
      "distinct",
      "dividing",
      "duplicates",
      "each",
      "earlier",
      "eating",
      "eats",
      "effectively",
      "efficient",
      "element",
      "elements",
      "eliminated",
      "ending",
      "enough",
      "ensures",
      "ensuring",
      "entire",
      "equal",
      "everything",
      "example",
      "examples",
      "existing",
      "false",
      "fast",
      "final",
      "find",
      "finding",
      "finds",
      "first",
      "forces",
      "frac",
      "from",
      "function",
      "given",
      "goal",
      "greater",
      "grows",
      "half",
      "heaviest",
      "high",
      "home",
      "hour",
      "hours",
      "idea",
      "ideal",
      "including",
      "increase",
      "index",
      "indicates",
      "indices",
      "inflection",
      "insert",
      "inserted",
      "insertion",
      "integers",
      "intuition",
      "item",
      "itself",
      "just",
      "keep",
      "key",
      "koko",
      "larger",
      "last",
      "lceil",
      "left",
      "leftmost",
      "leftover",
      "less",
      "lie",
      "limit",
      "list",
      "log",
      "logic",
      "loop",
      "low",
      "lower",
      "maintain",
      "max",
      "maximum",
      "mid",
      "middle",
      "minimal",
      "minimum",
      "modified",
      "module",
      "monotonic",
      "monotonically",
      "must",
      "non-increasing",
      "number",
      "numbers",
      "nums",
      "o",
      "occurrence",
      "only",
      "order",
      "p_i",
      "packages",
      "part",
      "past",
      "pile",
      "piles",
      "pivot",
      "point",
      "points",
      "portion",
      "position",
      "possible",
      "potential",
      "predictable",
      "problem",
      "property",
      "pushes",
      "python",
      "range",
      "ranges",
      "rceil",
      "remaining",
      "repeatedly",
      "represents",
      "required",
      "resizable",
      "return",
      "right",
      "rightmost",
      "rotated",
      "safely",
      "same",
      "search",
      "searching",
      "sequence",
      "setting",
      "ship",
      "should",
      "simplified",
      "size",
      "slow",
      "small",
      "smaller",
      "smallest",
      "sorted",
      "space",
      "speed",
      "speeds",
      "standard",
      "starting",
      "stay",
      "step",
      "such",
      "sum",
      "sum_",
      "switch",
      "table",
      "target",
      "tells",
      "terminates",
      "test",
      "than",
      "that",
      "then",
      "they",
      "timecomplexity",
      "tip",
      "true",
      "unique-element",
      "unknown",
      "upper",
      "valid",
      "value",
      "values",
      "wasted",
      "weights",
      "when",
      "where",
      "which",
      "will",
      "with",
      "within",
      "works",
      "would"
    ],
    "notations": [
      "( 1 )",
      "( 3 )",
      "( 5 )",
      "( hours(k)",
      "( k = (l + r)",
      "( l = k + 1 )",
      "( r = k )",
      "(\\log n)",
      "(any leftover hour is wasted)",
      "(capacity)",
      "(i.e.  first  position  i  where  a[i] > x )",
      "(i.e.  first  position  i  where  a[i] >= x )",
      "(i.e.,  [1, 2, 3] )",
      "(if a speed  k  is fast enough, any speed greater than  k  will also be fast enough)",
      "(including  mid )",
      "(piles)",
      "(ship's capacity)",
      "(smaller)",
      "(the eating speed  k )",
      "(the minimum value)",
      "(the ship's capacity)",
      "(weights)",
      "(where the numbers switch from high to low)",
      "O(\\log n)$",
      "\\displaystyle \\sum_{i=1}^{|piles|} \\left\\lceil \\frac{p_i}{k} \\right\\rceil \\le h$",
      "k$",
      "k‚àà‚Ñï$",
      "m$",
      "n$"
    ],
    "categories": [
      "binary-search"
    ],
    "leetcodeProblems": [
      {
        "number": "35",
        "name": "Search Insert Position",
        "url": "https://leetcode.com/problems/search-insert-position/",
        "section": "1. Search Insert Position"
      },
      {
        "number": "34",
        "name": "Find First and Last Position of Element in Sorted Array",
        "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/",
        "section": "2. Find First and Last Position of Element in Sorted Array"
      },
      {
        "number": "153",
        "name": "Find Minimum in Rotated Sorted Array",
        "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
        "section": "3. Find Minimum in Rotated Sorted Array"
      },
      {
        "number": "875",
        "name": "Koko Eating Bananas",
        "url": "https://leetcode.com/problems/koko-eating-bananas/",
        "section": "4. Koko Eating Bananas"
      },
      {
        "number": "1011",
        "name": "Capacity To Ship Packages Within D Days",
        "url": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/",
        "section": "5. Capacity To Ship Packages Within D Days"
      }
    ]
  },
  "a-star": {
    "title": "Informed Search",
    "route": "/notes/a-star",
    "filePath": "app/notes/a-star/page.mdx",
    "headings": [
      "Informed Search",
      "Resizable Table Of Contents",
      "Greedy Best-First Search",
      "A* Search üå≤",
      "Examples",
      "1. Shortest Path in a Grid with Obstacles Elimination"
    ],
    "text": "Informed search algorithms use problem-specific knowledge to find solutions more efficiently.\nThis is in contrast to uninformed search algorithms like Depth-First or Breadth-First Search, which don't use any knowledge they haven't acquired through exploration.  Greedy best-first search is an informed search algorithm that works by always expanding the node that appears to be closest to the goal. This decision is based on a  heuristic function , denoted as  , which estimates how close a node is to the goal.  A common example of a heuristic is the  Manhattan distance . Used in grid-based problems, it calculates the distance between a node and the goal by counting the steps up, down, left, or right, ignoring any walls or obstacles that might be in the way.  The \"greedy\" nature of this algorithm means it can be very fast. However, because it only considers the estimated cost to the goal and ignores the path cost already taken, it can be misled by a poor heuristic and is not guaranteed to find the  optimal solution . The algorithm's effectiveness is entirely dependent on the quality of its heuristic function.  A* is essentially Dijkstra's algorithm plus a heuristic (h) that estimates the remaining cost to the destination.  A* search is a development of the greedy best-first algorithm that combines both the estimated cost to the goal and the actual cost incurred to reach the current node  The algorithm evaluates nodes based on the formula:\n  : The  cost  to reach the current node  n  from the start.  : The  heuristic  (estimated) cost from node  n  to the goal.  By summing these two values, the algorithm gets a more accurate way to determine the cost of a solution and optimize its choices.  For A* search to be optimal (meaning it's guaranteed to find the best solution), its heuristic function   must be:  Admissible : It must never overestimate the true cost to reach the goal.  Consistent : For any node  n  and its successor  n' , the heuristic's value at  n  must be less than or equal to the cost of moving to  n'  plus the heuristic's value at  n' . In other words,  , where c is the step cost  LeetCode 1293  Given an  m x n  grid where cells are either empty ( 0 ) or an obstacle ( 1 ), and an integer  k \nrepresenting the maximum number of obstacles you can eliminate, find the minimum number of steps to travel from the top-left corner  (0, 0) \nto the bottom-right  (m-1, n-1) . Each move (up, down, left, right) costs one step. If no such path exists, return  -1 .   [!timecomplexity:collapse]    The    vs   Breadth-First  vs  Dijkstra \nFor this type of single-destination grid problem,  A* is almost always faster in practice than BFS or Dijkstra . While all three algorithms can find the correct answer, their search strategies lead to dramatically different performance.  The Core Difference: Guided vs. Blind Search  The reason for A*'s superior speed is that it's an  informed  search algorithm, while BFS and Dijkstra are  blind .  BFS and Dijkstra (Blind) : These algorithms explore outwards from the start without any sense of the goal's direction. Dijkstra's expands based on the lowest cost from the start, and BFS expands layer by layer. This is like searching for an address in a city by systematically checking every block in an ever-expanding circle‚Äîyou'll find it, but you'll visit countless useless locations.  A* (Guided) : A* uses a heuristic as a \"sense of direction\" or a magic compass that always points toward the goal. At every step, it prioritizes paths that are not only short but are also moving in the right direction. This allows it to ignore vast, irrelevant parts of the grid and focus its effort.  How the Search Area Differs on a Grid  This difference is most obvious when visualizing the cells each algorithm explores ( x ) to get from a start  S  to a goal  G .  Dijkstra / BFS Exploration (Blind) \nThe search expands in a uniform wave, exploring many cells that are not on the optimal path.  ....................G\n.xxxxxxxx...........\n.xxxxxxxxxxxx.......\n.xxxxxxxxxxxxxxx....\n.xxxxxxxxxxxxxxxx...\nSxxxxxxxxxxxxxxxxxx. A* Exploration (Guided) \nThe heuristic \"pulls\" the search toward the goal, creating a much narrower search corridor.  ....................G\n............xxxx....\n.........xxxxx......\n......xxxx..........\n...xxxx.............\nSxxxx............... Why This Matters for Performance  This leads to a crucial trade-off. A*'s worst-case time complexity of  $O(m \\cdot n \\cdot k \\cdot \\log(m \\cdot n \\cdot k))$  looks slower on paper than BFS's  $O(m \\cdot n \\cdot k)$  due to the logarithmic factor from the priority queue.  However, this is misleading. In practice, the number of states A* actually needs to visit is so dramatically smaller than for BFS or Dijkstra that the savings from exploring fewer states far outweigh the small additional cost per node, resulting in a much faster solution.",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/a-star.py#func:aStarShortestPath",
        "fileSource": "backend/algorithms/a-star.py",
        "functionName": "aStarShortestPath"
      },
      {
        "language": "text",
        "content": "....................G\n.xxxxxxxx...........\n.xxxxxxxxxxxx.......\n.xxxxxxxxxxxxxxx....\n.xxxxxxxxxxxxxxxx...\nSxxxxxxxxxxxxxxxxxx."
      },
      {
        "language": "text",
        "content": "....................G\n............xxxx....\n.........xxxxx......\n......xxxx..........\n...xxxx.............\nSxxxx..............."
      }
    ],
    "keyTerms": [
      "accurate",
      "acquired",
      "actual",
      "actually",
      "additional",
      "address",
      "admissible",
      "algorithm",
      "algorithms",
      "allows",
      "almost",
      "already",
      "also",
      "always",
      "answer",
      "appears",
      "area",
      "based",
      "because",
      "best",
      "best-first",
      "between",
      "bfs",
      "blind",
      "block",
      "both",
      "bottom-right",
      "breadth-first",
      "calculates",
      "cdot",
      "cells",
      "checking",
      "choices",
      "circle",
      "city",
      "close",
      "closest",
      "collapse",
      "combines",
      "common",
      "compass",
      "complexity",
      "considers",
      "consistent",
      "contents",
      "contrast",
      "core",
      "corner",
      "correct",
      "corridor",
      "cost",
      "costs",
      "counting",
      "countless",
      "creating",
      "crucial",
      "current",
      "decision",
      "denoted",
      "dependent",
      "depth-first",
      "destination",
      "determine",
      "development",
      "difference",
      "different",
      "differs",
      "dijkstra",
      "direction",
      "distance",
      "don",
      "down",
      "dramatically",
      "each",
      "effectiveness",
      "efficiently",
      "effort",
      "either",
      "eliminate",
      "elimination",
      "empty",
      "entirely",
      "equal",
      "essentially",
      "estimated",
      "estimates",
      "evaluates",
      "ever-expanding",
      "every",
      "example",
      "examples",
      "exists",
      "expanding",
      "expands",
      "exploration",
      "explore",
      "explores",
      "exploring",
      "factor",
      "far",
      "fast",
      "faster",
      "fewer",
      "find",
      "focus",
      "formula",
      "from",
      "function",
      "gets",
      "given",
      "goal",
      "greedy",
      "grid",
      "grid-based",
      "guaranteed",
      "guided",
      "haven",
      "heuristic",
      "however",
      "ignore",
      "ignores",
      "ignoring",
      "incurred",
      "informed",
      "integer",
      "irrelevant",
      "knowledge",
      "layer",
      "lead",
      "leads",
      "leetcode",
      "left",
      "less",
      "like",
      "locations",
      "log",
      "logarithmic",
      "looks",
      "lowest",
      "m-1",
      "magic",
      "manhattan",
      "many",
      "matters",
      "maximum",
      "meaning",
      "means",
      "might",
      "minimum",
      "misleading",
      "misled",
      "more",
      "most",
      "move",
      "moving",
      "much",
      "must",
      "n-1",
      "narrower",
      "nature",
      "needs",
      "never",
      "node",
      "nodes",
      "number",
      "o",
      "obstacle",
      "obstacles",
      "obvious",
      "only",
      "optimal",
      "optimize",
      "other",
      "outwards",
      "outweigh",
      "overestimate",
      "paper",
      "parts",
      "path",
      "paths",
      "performance",
      "plus",
      "points",
      "poor",
      "practice",
      "prioritizes",
      "priority",
      "problem",
      "problem-specific",
      "problems",
      "pulls",
      "quality",
      "queue",
      "reach",
      "reason",
      "remaining",
      "representing",
      "resizable",
      "resulting",
      "return",
      "right",
      "savings",
      "search",
      "searching",
      "sense",
      "short",
      "shortest",
      "single-destination",
      "slower",
      "small",
      "smaller",
      "solution",
      "solutions",
      "speed",
      "start",
      "states",
      "step",
      "steps",
      "strategies",
      "successor",
      "such",
      "summing",
      "superior",
      "sxxxx",
      "sxxxxxxxxxxxxxxxxxx",
      "systematically",
      "table",
      "taken",
      "than",
      "that",
      "their",
      "these",
      "they",
      "three",
      "through",
      "time",
      "timecomplexity",
      "top-left",
      "toward",
      "trade-off",
      "travel",
      "true",
      "type",
      "uniform",
      "uninformed",
      "used",
      "useless",
      "uses",
      "value",
      "values",
      "vast",
      "very",
      "visit",
      "visualizing",
      "walls",
      "wave",
      "when",
      "where",
      "which",
      "while",
      "with",
      "without",
      "words",
      "works",
      "worst-case",
      "xxxx",
      "xxxxx",
      "xxxxxxxx",
      "xxxxxxxxxxxx",
      "xxxxxxxxxxxxxxx",
      "xxxxxxxxxxxxxxxx"
    ],
    "notations": [
      "( 0 )",
      "( 1 )",
      "( x )",
      "(0, 0)",
      "(Blind)",
      "(Guided)",
      "(estimated)",
      "(h)",
      "(m \\cdot n \\cdot k \\cdot \\log(m \\cdot n \\cdot k)",
      "(m \\cdot n \\cdot k)",
      "(m-1, n-1)",
      "(meaning it's guaranteed to find the best solution)",
      "(up, down, left, right)",
      "O(m \\cdot n \\cdot k \\cdot \\log(m \\cdot n \\cdot k))$",
      "O(m \\cdot n \\cdot k)$"
    ],
    "categories": [
      "a-star"
    ],
    "leetcodeProblems": [
      {
        "number": "1293",
        "name": "Shortest Path In A Grid With Obstacles Elimination",
        "url": "https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",
        "section": "1. Shortest Path in a Grid with Obstacles Elimination"
      }
    ]
  },
  "alert": {
    "title": "alert",
    "route": "/notes/alert",
    "filePath": "app/notes/alert/page.mdx",
    "headings": [],
    "text": "Algorithm:  initialize distance estimates,  Relax all edges |V|‚Äì1 times  to compute shortest paths( where each relaxation improves distance estimates ).  Then  do one more pass (the  th):\n3.1. if any edge is relaxable (i.e., violates the triangle inequality) ‚Üí  negative-weight cycle exists .\n3.2. otherwise,  d(s, v) = Œ¥(s, v) for all v ‚àà V  [!note]  Algorithm:  initialize distance estimates,\n Relax all edges |V|‚Äì1 times  to compute shortest paths( where each relaxation improves distance estimates ).\n Then  do one more pass (the  th):\n3.1. if any edge is relaxable (i.e., violates the triangle inequality) ‚Üí  negative-weight cycle exists .\n3.2. otherwise,  d(s, v) = Œ¥(s, v) for all v ‚àà V",
    "sections": [],
    "codeBlocks": [],
    "keyTerms": [
      "algorithm",
      "compute",
      "cycle",
      "d",
      "distance",
      "each",
      "edge",
      "edges",
      "estimates",
      "exists",
      "improves",
      "inequality",
      "initialize",
      "more",
      "negative-weight",
      "note",
      "otherwise",
      "pass",
      "paths",
      "relax",
      "relaxable",
      "relaxation",
      "shortest",
      "then",
      "times",
      "triangle",
      "violates",
      "where"
    ],
    "notations": [
      "( where each relaxation improves distance estimates )",
      "(i.e., violates the triangle inequality)",
      "(s, v)",
      "(the  th)",
      "Œ¥"
    ],
    "categories": [
      "alert"
    ],
    "leetcodeProblems": []
  },
  "backtrack": {
    "title": "Backtracking",
    "route": "/notes/backtrack",
    "filePath": "app/notes/backtrack/page.mdx",
    "headings": [
      "Backtracking",
      "Resizable Table of Contents",
      "Examples",
      "1. N-Queens",
      "2. Word Search",
      "3. Permutations",
      "4. Combination Sum"
    ],
    "text": "Place n queens on an n x n board such that no two queens threaten each other. \n [19:]meaning no two queens share the same row, column, or diagonal.  51. N-Queens   [!insight:collapse]  Backtrack with State Tracking ‚ôõ  ~  Place one queen per row. Track blocked columns, diagonals:  Valid placement ‚Üí recurse to next row  Invalid ‚Üí skip  After recursion, remove queen to try next column  ~  Track state using:  cols  for columns  diag1  for main diagonal  ‚Üò    row - col  diag2  for anti-diagonal  ‚Üô   row + col  [!timecomplexity:collapse]   ‚Ä¢\tFirst row:  $N$  choices\n‚Ä¢\tSecond:  $\\leq N-1$ , and so on\n‚Ä¢\tTotal permutations =  $N!$ \n‚Ä¢\tPruning drastically reduces actual recursion tree  Determine if a word exists in a 2D board by following adjacent letters without reuse.  79. Word Search   [!insight:collapse] DFS with Early Exit on Mismatch  Start DFS from each cell. At each step:\n‚Ä¢\tCheck bounds and character match\n‚Ä¢\tMark visited cell with a temp symbol (e.g. #)\n‚Ä¢\tTry 4 directions (no revisiting)\n‚Ä¢\tRestore cell after backtracking\nStop early if the full word is matched.  [!timecomplexity:collapse]   where:\n‚Ä¢\tM, N = board size\n‚Ä¢\tL = word length\n‚Ä¢\tEach step explores at most 3 directions (excluding the one it came from)\n‚Ä¢\tRuntime improves with early mismatches and pruning  Return all permutations of a list of unique numbers.  46. Permutations   [!insight:collapse] Recursive Tree of Choices  Build permutations by choosing unused elements: \n‚Ä¢\tAt each level, try each remaining number\n‚Ä¢\tRecurse with updated path\n‚Ä¢\tBacktrack to un-choose  Use used list or boolean flags to track chosen elements.  [!timecomplexity:collapse]   ‚Ä¢\tN levels of recursion\n‚Ä¢\tEach level explores N - depth options\n‚Ä¢\tTotal: N! permutations  Return all unique combinations where chosen numbers sum to a target. Numbers can be reused.  39. Combination Sum   [!insight:collapse] DFS with backtracking:  sort  candidates , try each starting from current index (to allow reuse), prune if number exceeds remaining target, and record the path when  rem == 0 .  [!timecomplexity:collapse]   Worst-case exponential ‚Äî  $O(2^n)$  in number of combinations explored ‚Äî but pruning ( if c > rem: break ) reduces branches significantly.",
    "sections": [],
    "codeBlocks": [
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/backtrack.py#method:Backtrack.solveNQueens",
        "fileSource": "backend/algorithms/backtrack.py",
        "className": "Backtrack",
        "methodName": "solveNQueens"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/backtrack.py#method:Backtrack.exist",
        "fileSource": "backend/algorithms/backtrack.py",
        "className": "Backtrack",
        "methodName": "exist"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/backtrack.py#func:permute",
        "fileSource": "backend/algorithms/backtrack.py",
        "functionName": "permute"
      },
      {
        "language": "python",
        "content": "",
        "originalMeta": "file=backend/algorithms/backtrack.py#func:combinationSum",
        "fileSource": "backend/algorithms/backtrack.py",
        "functionName": "combinationSum"
      }
    ],
    "keyTerms": [
      "actual",
      "adjacent",
      "after",
      "allow",
      "anti-diagonal",
      "backtrack",
      "backtracking",
      "blocked",
      "board",
      "boolean",
      "bounds",
      "branches",
      "break",
      "build",
      "came",
      "candidates",
      "cell",
      "character",
      "check",
      "choices",
      "choosing",
      "chosen",
      "col",
      "collapse",
      "cols",
      "column",
      "columns",
      "combination",
      "combinations",
      "contents",
      "current",
      "depth",
      "determine",
      "dfs",
      "diag1",
      "diag2",
      "diagonal",
      "diagonals",
      "directions",
      "drastically",
      "each",
      "early",
      "elements",
      "examples",
      "exceeds",
      "excluding",
      "exists",
      "exit",
      "explored",
      "explores",
      "exponential",
      "first",
      "flags",
      "following",
      "from",
      "full",
      "improves",
      "index",
      "insight",
      "invalid",
      "length",
      "leq",
      "letters",
      "level",
      "levels",
      "list",
      "main",
      "mark",
      "match",
      "matched",
      "meaning",
      "mismatch",
      "mismatches",
      "most",
      "n-1",
      "n-queens",
      "next",
      "number",
      "numbers",
      "o",
      "options",
      "other",
      "path",
      "permutations",
      "place",
      "placement",
      "prune",
      "pruning",
      "queen",
      "queens",
      "record",
      "recurse",
      "recursion",
      "recursive",
      "reduces",
      "rem",
      "remaining",
      "remove",
      "resizable",
      "restore",
      "return",
      "reuse",
      "reused",
      "revisiting",
      "row",
      "runtime",
      "same",
      "search",
      "second",
      "share",
      "significantly",
      "size",
      "skip",
      "sort",
      "start",
      "starting",
      "state",
      "step",
      "stop",
      "such",
      "sum",
      "symbol",
      "table",
      "target",
      "temp",
      "that",
      "threaten",
      "timecomplexity",
      "total",
      "track",
      "tracking",
      "tree",
      "un-choose",
      "unique",
      "unused",
      "updated",
      "used",
      "using",
      "valid",
      "visited",
      "when",
      "where",
      "with",
      "without",
      "word",
      "worst-case"
    ],
    "notations": [
      "( if c > rem: break )",
      "(2^n)",
      "(e.g. #)",
      "(excluding the one it came from)",
      "(no revisiting)",
      "(to allow reuse)",
      "N!$",
      "N$",
      "O(2^n)$",
      "\\leq N-1$",
      "g1",
      "g2"
    ],
    "categories": [
      "backtrack"
    ],
    "leetcodeProblems": [
      {
        "number": "51",
        "name": "N-Queens",
        "url": "https://leetcode.com/problems/n-queens/",
        "section": "1. N-Queens"
      },
      {
        "number": "79",
        "name": "Word Search",
        "url": "https://leetcode.com/problems/word-search/",
        "section": "2. Word Search"
      },
      {
        "number": "46",
        "name": "Permutations",
        "url": "https://leetcode.com/problems/permutations/",
        "section": "3. Permutations"
      },
      {
        "number": "39",
        "name": "Combination Sum",
        "url": "https://leetcode.com/problems/combination-sum/",
        "section": "4. Combination Sum"
      }
    ]
  }
}