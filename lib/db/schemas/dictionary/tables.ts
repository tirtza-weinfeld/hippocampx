/**
 * Table definitions for dictionary schema
 *
 * Architecture (Neuro-Symbolic 2025+):
 * - AI-Curated Graph: sense_relations stores frozen LLM decisions
 * - Hybrid Search: Dense (halfvec) + Sparse (tsvector/trigram)
 * - Verification Pipeline: is_synthetic â†’ verification_status
 * - Edge-Native: Audio stored as URLs, not BLOBs
 *
 * Prerequisites:
 *   CREATE EXTENSION IF NOT EXISTS vector;
 *   CREATE EXTENSION IF NOT EXISTS pg_trgm;
 */

import {
  pgTable,
  index,
  uniqueIndex,
  unique,
  text,
  timestamp,
  integer,
  varchar,
  boolean,
  jsonb,
  real,
  primaryKey,
  foreignKey,
} from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm";
import { z } from "zod";

// Note: embeddings moved to separate vector tables (see vectors.ts)
import {
  partOfSpeechEnum,
  relationTypeEnum,
  sourceTypeEnum,
  creditRoleEnum,
  verificationStatusEnum,
} from "./enums";
import { PolyglotGrammarSchema } from "./validators";

// ============================================================================
// CORE TABLES (Lexical Hierarchy)
// ============================================================================

export const lexicalEntries = pgTable(
  "lexical_entries",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    lemma: varchar("lemma", { length: 255 }).notNull(),
    part_of_speech: partOfSpeechEnum("part_of_speech").notNull(),
    language_code: varchar("language_code", { length: 5 }).notNull().default("en"),

    // Homograph discriminator: distinguishes "bass" (fish) from "bass" (instrument)
    discriminator: integer("discriminator").default(1).notNull(),

    metadata: jsonb("metadata"),

    created_at: timestamp("created_at", { withTimezone: true }).defaultNow(),
    updated_at: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .$onUpdate(() => new Date()),
  },
  (table) => [
    uniqueIndex("uq_lemma_lang_pos_disc").on(
      table.lemma,
      table.language_code,
      table.part_of_speech,
      table.discriminator
    ),
    index("idx_entry_lemma_trgm").using("gin", sql.raw(`"lemma" gin_trgm_ops`)),
  ]
);

export const wordForms = pgTable(
  "word_forms",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    entry_id: integer("entry_id")
      .notNull()
      .references(() => lexicalEntries.id, { onDelete: "cascade" }),

    form_text: varchar("form_text", { length: 255 }).notNull(),
    grammatical_features: jsonb("grammatical_features")
      .$type<z.infer<typeof PolyglotGrammarSchema>>()
      .notNull(),
  },
  (table) => [
    index("idx_form_entry").on(table.entry_id),
    index("idx_form_text").on(table.form_text),
    index("idx_form_text_trgm").using("gin", sql.raw(`"form_text" gin_trgm_ops`)),
    index("idx_grammar").using("gin", table.grammatical_features),
  ]
);

export const senses = pgTable(
  "senses",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    entry_id: integer("entry_id")
      .notNull()
      .references(() => lexicalEntries.id, { onDelete: "cascade" }),

    definition: text("definition").notNull(),
    order_index: integer("order_index").default(0), // Display order (0 = primary sense)

    is_synthetic: boolean("is_synthetic").default(false),
    verification_status: verificationStatusEnum("verification_status")
      .default("unverified")
      .notNull(),

    updated_at: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .$onUpdate(() => new Date()),
  },
  (table) => [
    index("idx_sense_entry").on(table.entry_id),
  ]
);

// ============================================================================
// KNOWLEDGE GRAPH (Relations)
// ============================================================================

export const senseRelations = pgTable(
  "sense_relations",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    source_sense_id: integer("source_sense_id")
      .notNull()
      .references(() => senses.id, { onDelete: "cascade" }),
    target_sense_id: integer("target_sense_id")
      .notNull()
      .references(() => senses.id, { onDelete: "cascade" }),

    relation_type: relationTypeEnum("relation_type").notNull(),
    strength: integer("strength").default(100),
    explanation: text("explanation"),

    // Neuro-Symbolic verification pipeline
    is_synthetic: boolean("is_synthetic").default(true), // AI-generated by default
    verification_status: verificationStatusEnum("verification_status")
      .default("unverified")
      .notNull(),
  },
  (table) => [
    index("idx_relation_source").on(table.source_sense_id),
    index("idx_relation_target").on(table.target_sense_id),
    uniqueIndex("uq_sense_relation").on(
      table.source_sense_id,
      table.target_sense_id,
      table.relation_type
    ),
  ]
);

// ============================================================================
// SOURCES & CITATIONS (Neuro-Symbolic Ready)
// ============================================================================

/**
 * Contributors (authors, composers, etc.)
 * NOTE: No unique constraint on name - multiple people can share names.
 * Use metadata jsonb for disambiguation (wikidata ID, birth year, etc.)
 */
export const contributors = pgTable(
  "contributors",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    name: varchar("name", { length: 255 }).notNull(),
    type: varchar("type", { length: 50 }).default("person"),
    metadata: jsonb("metadata"), // { wikidata: "Q123", imdb: "nm456", born: 1948 }
  },
  () => [index("idx_contributor_name_trgm").using("gin", sql.raw(`"name" gin_trgm_ops`))]
);

export const sources = pgTable(
  "sources",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    type: sourceTypeEnum("type").notNull(),
    title: varchar("title", { length: 255 }).notNull(),
    publication_year: integer("publication_year"),
    reliability_score: real("reliability_score").default(0.5),
    metadata: jsonb("metadata"),
  },
  (table) => [
    index("idx_source_title_trgm").using("gin", sql.raw(`"title" gin_trgm_ops`)),
    unique("uq_source_type_title").on(table.type, table.title),
  ]
);

export const sourceCredits = pgTable(
  "source_credits",
  {
    source_id: integer("source_id")
      .notNull()
      .references(() => sources.id, { onDelete: "cascade" }),
    contributor_id: integer("contributor_id")
      .notNull()
      .references(() => contributors.id, { onDelete: "cascade" }),
    role: creditRoleEnum("role").notNull(),
  },
  (table) => [
    primaryKey({ columns: [table.source_id, table.contributor_id, table.role] }),
    index("idx_credits_lookup").on(table.contributor_id, table.role),
  ]
);

/**
 * RECURSIVE HIERARCHY
 * Allows: Wicked (Source) -> Act 1 (Part) -> Defying Gravity (Part)
 */
export const sourceParts = pgTable(
  "source_parts",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    source_id: integer("source_id")
      .notNull()
      .references(() => sources.id, { onDelete: "cascade" }),

    parent_part_id: integer("parent_part_id"),

    name: varchar("name", { length: 255 }).notNull(),
    type: varchar("type", { length: 50 }),
    order_index: integer("order_index"),
  },
  (table) => [
    index("idx_source_parts_source").on(table.source_id),
    index("idx_source_parts_parent").on(table.parent_part_id),
    unique("uq_source_part").on(table.source_id, table.parent_part_id, table.name).nullsNotDistinct(),
    foreignKey({
      columns: [table.parent_part_id],
      foreignColumns: [table.id],
      name: "fk_source_parts_parent",
    }).onDelete("cascade"),
  ]
);

export const examples = pgTable(
  "examples",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    sense_id: integer("sense_id")
      .notNull()
      .references(() => senses.id, { onDelete: "cascade" }),
    text: text("text").notNull(),
    language_code: varchar("language_code", { length: 5 }).default("en"),
    source_part_id: integer("source_part_id").references(() => sourceParts.id, {
      onDelete: "set null",
    }),

    // NOTE: cached_citation can become stale if source/contributor changes.
    // Sources rarely change; rebuild cache manually if needed.
    cached_citation: varchar("cached_citation", { length: 255 }),

    updated_at: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .$onUpdate(() => new Date()),
  },
  (table) => [
    index("idx_example_sense").on(table.sense_id),
    index("idx_example_source_part").on(table.source_part_id),
    index("idx_example_text_trgm").using("gin", sql.raw(`"text" gin_trgm_ops`)),
    unique("uq_example_sense_text").on(table.sense_id, table.text),
  ]
);

// ============================================================================
// AUDIO & TAGS
// ============================================================================

export const entryAudio = pgTable(
  "entry_audio",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    entry_id: integer("entry_id")
      .notNull()
      .references(() => lexicalEntries.id, { onDelete: "cascade" }),

    audio_url: varchar("audio_url", { length: 512 }).notNull(),
    transcript: text("transcript"),
    duration_ms: integer("duration_ms"),
    accent_code: varchar("accent_code", { length: 10 }).default("en-US"),
    content_type: varchar("content_type", { length: 50 }).default("audio/mpeg"),
  },
  (table) => [index("idx_audio_entry").on(table.entry_id)]
);

/**
 * Categories - Parent "bucket" for organizing tags
 * Uses natural key (varchar id) for readable data: 'register', 'domain'
 */
export const categories = pgTable("categories", {
  id: varchar("id", { length: 50 }).primaryKey(),
  displayName: varchar("display_name", { length: 100 }).notNull(),
  aiDescription: text("ai_description"),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .$onUpdate(() => new Date()),
})

export const tags = pgTable(
  "tags",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    categoryId: varchar("category_id", { length: 50 })
      .notNull()
      .references(() => categories.id, { onDelete: "restrict" }),
    name: varchar("name", { length: 100 }).notNull(),
    metadata: jsonb("metadata"),
  },
  (table) => [uniqueIndex("uq_tag_name_category").on(table.name, table.categoryId)]
);

export const senseTags = pgTable(
  "sense_tags",
  {
    sense_id: integer("sense_id")
      .notNull()
      .references(() => senses.id, { onDelete: "cascade" }),
    tag_id: integer("tag_id")
      .notNull()
      .references(() => tags.id, { onDelete: "cascade" }),
    explanation: text("explanation"),
  },
  (table) => [primaryKey({ columns: [table.sense_id, table.tag_id] })]
);
