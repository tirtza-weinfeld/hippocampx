# Top K Frequent Elements

## Resizable Table Of contents

<DifficultyBadge difficulty="medium" />

<PillList pills={["heap", "min-heap"]} />

[347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements)

## [!(ProblemDefinition)] Definition

Given an integer array `nums` and an integer `k`, return the `k` most **frequent** elements
    *[19!]Algorithm complexity must be better than *[orange!]O(nlogn)* where `n` is the length of the input array,     You may return the answer in any order*

## [!(ProblemSolutionGroup)] Heap Solutions

### [!ProblemSolution] heap.py

#### [!collapsible(ProblemTimeComplexity)] Time Complexity
...

#### [!collapsible(ProblemKeyVariables)] Key Variables
...

#### [!collapsible(ProblemKeyExpressions)] Key Expressions
...

#### [!ProblemCodeTab] Code Tab

```python meta="source=problems/347-top-k-frequent-elements/heap.py"
...
```

### [!Solution] heap-nlargets.py

#### [!collapsible(ProblemTimeComplexity)] Time Complexity
...

#### [!collapsible(ProblemKeyVariables)] Key Variables
...

#### [!collapsible(ProblemKeyExpressions)] Key Expressions
...

#### [!ProblemCodeTab] Code Tab
```python meta="source=problems/347-top-k-frequent-elements/heap-nlargets.py"
...
```


---

## Sort Frequency Bucketing Solution

### [!(ProblemTimeComplexity)] Time Complexity

- $O(n)$:
    - Counter(nums) → $O(n)$
    - Build buckets → $O(n)$ (each element placed once)
    - Flatten in reverse until k → $O(n)$

### [!(ProblemKeyExpressions)] Key Expressions

- `bucket[f].append(n)`: append n to the bucket with frequency f

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/347-top-k-frequent-elements/sort-frequency-bucketing.py"
from collections import Counter

def topKFrequent(nums: list[int], k: int) -> list[int]:

    bucket=[[] for _ in range(len(nums)+1)]
    for n,f in Counter(nums).items():
        bucket[f].append(n)

    return [num for f_bucket in reversed(bucket) for num in f_bucket][:k]
```

