{
  "SolutionAStar": {
    "name": "SolutionAStar",
    "type": "class",
    "language": "python",
    "file": "examples/code/a-star.py",
    "line": 4,
    "signature": "class SolutionAStar:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class SolutionAStar:\n    def shortestPath(self, grid: list[list[int]], k: int) -> int:\n        rows, cols = len(grid), len(grid[0])\n        min_dist = rows + cols - 2\n        if k >= min_dist:\n            return min_dist\n        max_k = [[-1] * cols for _ in range(rows)]\n        max_k[0][0] = k\n        def heuristic(r, c):\n            return (rows - 1 - r) + (cols - 1 - c)\n        pq = [(heuristic(0,0), 0, 0, 0, k)]\n        directions = [(1,0),(-1,0),(0,1),(0,-1)]\n        while pq:\n            f, steps, r, c, rem_k = heapq.heappop(pq)\n            if (r, c) == (rows - 1, cols - 1):\n                return steps\n            if rem_k < max_k[r][c]:\n                continue\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    nk = rem_k - grid[nr][nc]\n                    if nk >= 0 and nk > max_k[nr][nc]:\n                        max_k[nr][nc] = nk\n                        g = steps + 1\n                        f_new = g + heuristic(nr, nc)\n                        heapq.heappush(pq, (f_new, g, nr, nc, nk))\n        return -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "SolutionAStar.shortestPath": {
    "name": "shortestPath",
    "type": "method",
    "language": "python",
    "file": "examples/code/a-star.py",
    "line": 5,
    "signature": "def shortestPath(self, grid: list[list[int]], k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def shortestPath(self, grid: list[list[int]], k: int) -> int:\n        rows, cols = len(grid), len(grid[0])\n        min_dist = rows + cols - 2\n        if k >= min_dist:\n            return min_dist\n        max_k = [[-1] * cols for _ in range(rows)]\n        max_k[0][0] = k\n        def heuristic(r, c):\n            return (rows - 1 - r) + (cols - 1 - c)\n        pq = [(heuristic(0,0), 0, 0, 0, k)]\n        directions = [(1,0),(-1,0),(0,1),(0,-1)]\n        while pq:\n            f, steps, r, c, rem_k = heapq.heappop(pq)\n            if (r, c) == (rows - 1, cols - 1):\n                return steps\n            if rem_k < max_k[r][c]:\n                continue\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    nk = rem_k - grid[nr][nc]\n                    if nk >= 0 and nk > max_k[nr][nc]:\n                        max_k[nr][nc] = nk\n                        g = steps + 1\n                        f_new = g + heuristic(nr, nc)\n                        heapq.heappush(pq, (f_new, g, nr, nc, nk))\n        return -1",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "SolutionAStar"
  },
  "bellman_ford_classic": {
    "name": "bellman_ford_classic",
    "type": "function",
    "language": "python",
    "file": "examples/code/bellman-ford.py",
    "line": 3,
    "signature": "def bellman_ford_classic(vertices:list[str], edges:list[tuple[str, str, float]], source:str)->dict[str, float]:",
    "parameters": [],
    "return_type": "dict[(str, float)]",
    "return_description": "",
    "description": "Classic Bellman-Ford with early exit.",
    "code": "def bellman_ford_classic(vertices:list[str], edges:list[tuple[str, str, float]], source:str)->dict[str, float]:\n    d = [float(\"inf\")] * (V := len(vertices))\n    d[source] = 0\n    for _ in range(V - 1):\n        updated = False\n        for u, v, w in edges:\n            if d[u] + w < d[v]:\n                d[v] = d[u] + w\n                updated = True\n        if not updated:\n            return d    \n    for u, v, w in edges:\n        if d[u] + w < d[v]:\n            raise Exception(\"Negative-weight cycle\")\n    return d",
    "links": [
      {
        "symbol": "v",
        "display": "[v]",
        "target": "v",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": []
  },
  "bellman_ford_layered_dag": {
    "name": "bellman_ford_layered_dag",
    "type": "function",
    "language": "python",
    "file": "examples/code/bellman-ford.py",
    "line": 31,
    "signature": "def bellman_ford_layered_dag(vertices: list[str], edges: list[tuple[str, str, float]], source: str) -> dict[str, float]:",
    "parameters": [
      {
        "name": "vertices",
        "type": "list[str]",
        "description": "All hashable vertex identifiers.",
        "default": null
      },
      {
        "name": "edges",
        "type": "list[tuple[(str, str, float)]]",
        "description": "Iterable of (u, v, weight) tuples.",
        "default": null
      },
      {
        "name": "source",
        "type": "str",
        "description": "Starting vertex.",
        "default": null
      }
    ],
    "return_type": "dict[(str, float)]",
    "return_description": "A dict mapping each vertex to its true shortest-path cost from `source`,",
    "description": "Compute k-edge shortest-path distances and detect negative cycles via layered relaxation.",
    "code": "def bellman_ford_layered_dag(vertices: list[str], edges: list[tuple[str, str, float]], source: str) -> dict[str, float]:\n    d = {v: float(\"inf\") for v in vertices}\n    d[source], V = 0, len(vertices)\n    for k in range(V):  \n        d_k = {**d}  \n        for u, v, w in edges:\n            if d[u] + w < d_k[v]:\n                d_k[v] = d[u] + w\n        d = d_k  \n    witnesses = {v for u, v, w in edges if d[u] + w < d[v]}\n    if not witnesses:\n        return d\n    adj = defaultdict(list)\n    for u, v, _ in edges:\n        adj[u].append(v)\n    stack = list(witnesses)\n    reachable = set(witnesses)\n    while stack:\n        u = stack.pop()\n        d[u] = float(\"-inf\")\n        for v in adj[u]:\n            if v not in reachable:\n                reachable.add(v)\n                stack.append(v)\n    return d",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "findCheapestPrice": {
    "name": "findCheapestPrice",
    "type": "function",
    "language": "python",
    "file": "examples/code/bellman-ford.py",
    "line": 89,
    "signature": "def findCheapestPrice(n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def findCheapestPrice(n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int:\n    d = [float(\"inf\")] * n\n    d[src] = 0\n    for _ in range(k + 1):\n        tmp = d[:]\n        for u, v, w in flights:\n            if d[u] + w < tmp[v]:\n                tmp[v] = d[u] + w\n        d = tmp\n    return d[dst] if d[dst] < float(\"inf\") else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "maxProbability": {
    "name": "maxProbability",
    "type": "function",
    "language": "python",
    "file": "examples/code/bellman-ford.py",
    "line": 104,
    "signature": "def maxProbability(n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float:",
    "parameters": [
      {
        "name": "n",
        "type": "int",
        "description": "number of nodes",
        "default": null
      },
      {
        "name": "edges",
        "type": "list[list[int]]",
        "description": "edges[i] = [u, v] is an undirected edge connecting the nodes u and v with a probability of success of traversing that edge succProb[i].",
        "default": null
      },
      {
        "name": "succProb",
        "type": "list[float]",
        "description": "list of probabilities, e.g. [0.5,0.5,0.2],",
        "default": null
      }
    ],
    "return_type": "float",
    "return_description": "",
    "description": "Bellman-Ford variant to maximize product of probabilities.",
    "code": "def maxProbability(n: int, edges: list[list[int]], succProb: list[float], start: int, end: int) -> float:\n    prob[start] = 1.0  \n    for _ in range(n - 1):  \n        updated = False\n        for (u, v), p in zip(edges, succProb):\n            if prob[u] * p > prob[v]:  \n                prob[v] = prob[u] * p\n                updated = True\n            if prob[v] * p > prob[u]:  \n                prob[u] = prob[v] * p\n                updated = True\n        if not updated:\n            break  \n    return prob[end]",
    "links": [
      {
        "symbol": "i",
        "display": "[i]",
        "target": "i",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "i",
        "display": "[i]",
        "target": "i",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [],
    "expressions": []
  },
  "dijkstra": {
    "name": "dijkstra",
    "type": "function",
    "language": "python",
    "file": "examples/code/dijkstra.py",
    "line": 4,
    "signature": "def dijkstra(graph: dict[str, dict[str, int]], s: str):",
    "parameters": [
      {
        "name": "graph",
        "type": "dict[(str, dict[(str, int)])]",
        "description": "A dictionary representing the graph.",
        "default": null
      },
      {
        "name": "s",
        "type": "str",
        "description": "The source vertex.",
        "default": null
      }
    ],
    "return_type": "",
    "return_description": "",
    "description": "Dijkstra's algorithm for finding the shortest path in a non-negative weighted graph.",
    "code": "def dijkstra(graph: dict[str, dict[str, int]], s: str):\n    d = {v: float('inf') for v in graph} | {s: 0}\n    p = {v: None for v in graph}\n    pq = [(0, s)]\n    while pq:\n        d_u, u = heapq.heappop(pq)\n        if d_u > d[u]:\n            continue\n        for v ,w in graph[u]:\n            if (weight := d_u + w) < d[v]:\n                d[v], p[v] = weight, u\n                heapq.heappush(pq, (weight, v))\n    return d, p",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "networkDelayTime2": {
    "name": "networkDelayTime2",
    "type": "function",
    "language": "python",
    "file": "examples/code/dijkstra.py",
    "line": 34,
    "signature": "def networkDelayTime2(times: list[list[int]], n: int, k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def networkDelayTime2(times: list[list[int]], n: int, k: int) -> int:\n    graph = {v: [] for v in range(1, n + 1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n    d = {v: float(\"inf\") for v in graph} | {k: 0}\n    pq = [(0, k)]\n    while pq:\n        d_u, u = heapq.heappop(pq)\n        if d_u > d[u]:\n            continue\n        for v, w in graph[u]:\n            if (weight := d_u + w) < d[v]:\n                d[v] = weight\n                heapq.heappush(pq, (weight, v))\n    return m if (m := max(d.values())) != float(\"inf\") else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "networkDelayTime": {
    "name": "networkDelayTime",
    "type": "function",
    "language": "python",
    "file": "examples/code/dijkstra.py",
    "line": 57,
    "signature": "def networkDelayTime(times: list[list[int]], n: int, k: int) -> int:",
    "parameters": [
      {
        "name": "times",
        "type": "list[list[int]]",
        "description": "list of lists of integers representing the edges and their weights",
        "default": null
      },
      {
        "name": "n",
        "type": "int",
        "description": "number of nodes",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "starting node",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum time for a signal starting at node `k` to reach *all* nodes or -1 if impossible",
    "description": "Given `n` nodes labeled `1` through `n` and directed travel times between them,",
    "code": "def networkDelayTime(times: list[list[int]], n: int, k: int) -> int:\n    adj = defaultdict(list)\n    for u, v, w in times:\n        adj[u].append((v, w))\n    pq, finalized, time = [(0, k)], set(), 0\n    while pq:\n        t, node = heapq.heappop(pq)\n        if node in finalized:\n            continue\n        finalized.add(node)\n        time = t\n        for neighbor, travel_time in adj[node]:\n            if neighbor not in finalized:\n                heapq.heappush(pq, (time + travel_time, neighbor))\n    return time if len(finalized) == n else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "minimumEffortPath": {
    "name": "minimumEffortPath",
    "type": "function",
    "language": "python",
    "file": "examples/code/dijkstra.py",
    "line": 91,
    "signature": "def minimumEffortPath(heights: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "heights",
        "type": "list[list[int]]",
        "description": "2D list of integers representing the heights of the cells",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum effort to reach the bottom-right cell",
    "description": "Find a path from the top-left to the bottom-right of a height grid that minimizes the \"effort\".",
    "code": "def minimumEffortPath(heights: list[list[int]]) -> int:\n    R, C = len(heights), len(heights[0])\n    pq, resolved = [(0, 0, 0)], set()\n    while pq:\n        effort, r, c = heapq.heappop(pq)\n        if (r, c) in resolved: continue\n        if (r, c) == (R - 1, C - 1): return effort\n        resolved.add((r, c))\n        for nr, nc in [(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)]:\n            if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in resolved:\n                neighbor_effort = max(effort, abs(heights[nr][nc] - heights[r][c]))\n                heapq.heappush(pq, (neighbor_effort, nr, nc))",
    "links": [],
    "variables": [
      {
        "name": "pq",
        "description": "Priority queue stores (max_effort_on_path, r, c)",
        "type": "variable"
      },
      {
        "name": "resolved",
        "description": "set to store the positions that have been resolved",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "swimInWater": {
    "name": "swimInWater",
    "type": "function",
    "language": "python",
    "file": "examples/code/dijkstra.py",
    "line": 120,
    "signature": "def swimInWater(grid: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[int]]",
        "description": "2D list of integers representing the elevations of the cells",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum time to travel from `(0, 0)` to `(N-1, N-1)`",
    "description": "You are given an `N x N` grid of elevations. Find the minimum \"time\" `t` to travel from `(0, 0)` to `(N-1, N-1)`.",
    "code": "def swimInWater(grid: list[list[int]]) -> int:\n    n=len(grid)\n    pq, resolved = [(grid[0][0], 0, 0)], set()\n    while pq:\n        time, r, c = heapq.heappop(pq)\n        if (r, c) in resolved:continue\n        if (r, c) == (n - 1, n - 1):return time\n        resolved.add((r, c))\n        for nr, nc in [(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)]:\n            if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in resolved:\n                bottleneck_time = max(time, grid[nr][nc])\n                heapq.heappush(pq, (bottleneck_time, nr, nc))",
    "links": [],
    "variables": [
      {
        "name": "pq",
        "description": "Priority queue stores (max_elevation_on_path, r, c)",
        "type": "variable"
      },
      {
        "name": "resolved",
        "description": "set to store the cells for which we have found the minimum time required to reach them",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "findCheapestPriceDijkstra": {
    "name": "findCheapestPriceDijkstra",
    "type": "function",
    "language": "python",
    "file": "examples/code/dijkstra.py",
    "line": 152,
    "signature": "def findCheapestPriceDijkstra( flights: list[list[int]], src: int, dst: int, k: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "Variables:",
    "code": "def findCheapestPriceDijkstra( flights: list[list[int]], src: int, dst: int, k: int) -> int:\n    graph = defaultdict(list)\n    for u, v, price in flights:\n        graph[u].append((v, price))\n    pq, min_stops = [(0, src, 0)], {}\n    while pq:\n        cost, city, stops = heapq.heappop(pq)\n        if stops > min_stops.get(city, float(\"inf\")): continue\n        if city == dst: return cost\n        min_stops[city] = stops\n        if stops <= k:\n            for neighbor, price in graph[city]:\n                heapq.heappush(pq, (cost + price, neighbor, stops + 1))\n    return -1",
    "links": [],
    "variables": [
      {
        "name": "pq",
        "description": "Priority queue to store the state (cost, city, stops_taken)",
        "type": "variable"
      },
      {
        "name": "min_stops",
        "description": "Tracks the minimum stops to reach each city",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "simple_bisect_left": {
    "name": "simple_bisect_left",
    "type": "function",
    "language": "python",
    "file": "examples/code/binary_search.py",
    "line": 5,
    "signature": "def simple_bisect_left(a, x):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Return the index where to insert item x in list a, assuming a is sorted.",
    "code": "def simple_bisect_left(a, x):\n    lo, hi = 0, len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if a[mid] < x:\n            lo = mid + 1\n        else:  \n            hi = mid  \n    return lo",
    "links": [],
    "variables": [
      {
        "name": "mid",
        "description": "the middle index of the array",
        "type": "variable"
      }
    ],
    "expressions": [
      {
        "expression": "(lo + hi) // 2",
        "description": "round down to the nearest integer",
        "type": "expression"
      }
    ]
  },
  "simple_bisect_right": {
    "name": "simple_bisect_right",
    "type": "function",
    "language": "python",
    "file": "examples/code/binary_search.py",
    "line": 33,
    "signature": "def simple_bisect_right(a, x):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Return the index where to insert item x in list a, assuming a is sorted.",
    "code": "def simple_bisect_right(a, x):\n    lo, hi = 0, len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if x < a[mid]:\n            hi = mid\n        else: \n            lo = mid + 1 \n    return lo",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "searchRange": {
    "name": "searchRange",
    "type": "function",
    "language": "python",
    "file": "examples/code/binary_search.py",
    "line": 54,
    "signature": "def searchRange(nums: list[int], target: int) -> list[int]:",
    "parameters": [],
    "return_type": "list[int]",
    "return_description": "",
    "description": "",
    "code": "def searchRange(nums: list[int], target: int) -> list[int]:\n    start = bisect_left(nums, target)\n    if start < len(nums) and nums[start] == target:\n        return start, bisect_right(nums, target) - 1\n    return -1, -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "LRUCache": {
    "name": "LRUCache",
    "type": "class",
    "language": "python",
    "file": "examples/code/cache.py",
    "line": 4,
    "signature": "class LRUCache:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "The LRU system is simple. It tracks *when* a book was last used.",
    "code": "class LRUCache:\n        self.cache: OrderedDict[int, int] = OrderedDict()\n        self.capacity = capacity\n    def get(self, key: int) -> int:\n            return -1\n        self.cache.move_to_end(key)\n        return val\n    def put(self, key: int, value: int) -> None:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "LRUCache.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "examples/code/cache.py",
    "line": 8,
    "signature": "def __init__(self, capacity: int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, capacity: int):\n        self.cache: OrderedDict[int, int] = OrderedDict()\n        self.capacity = capacity",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LRUCache"
  },
  "LRUCache.get": {
    "name": "get",
    "type": "method",
    "language": "python",
    "file": "examples/code/cache.py",
    "line": 12,
    "signature": "def get(self, key: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "When an item is accessed, it becomes the most recently used. We fetch the item and move it to the end of the `OrderedDict`.",
    "code": "def get(self, key: int) -> int:\n            return -1\n        self.cache.move_to_end(key)\n        return val",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LRUCache"
  },
  "LRUCache.put": {
    "name": "put",
    "type": "method",
    "language": "python",
    "file": "examples/code/cache.py",
    "line": 21,
    "signature": "def put(self, key: int, value: int) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "When an item is added or updated, it's also considered the most recently used and is moved to the end. If the cache exceeds its capacity, the item at the front of the OrderedDict (the least recently used) is removed.",
    "code": "def put(self, key: int, value: int) -> None:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LRUCache"
  },
  "LFUCache": {
    "name": "LFUCache",
    "type": "class",
    "language": "python",
    "file": "examples/code/cache.py",
    "line": 33,
    "signature": "class LFUCache:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "The LFU system is more sophisticated. It tracks not just *when* a book was last used, but also *how often* it has been used.",
    "code": "class LFUCache:\n        self.capacity    = capacity\n        self.cache       = {}  \n        self.freq        = {}  \n        self.buckets     = defaultdict(OrderedDict)  \n        self.minfreq     = 0\n    def _bump(self, key: int):\n        del self.buckets[f][key]\n        if not self.buckets[f]:\n            del self.buckets[f]\n            if self.minfreq == f:\n                self.minfreq += 1\n        self.freq[key] +=1 \n        self.buckets[f + 1][key] = None\n    def get(self, key: int) -> int:\n            return -1\n        self._bump(key)\n        return self.cache[key]\n    def put(self, key: int, value: int) -> None:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._bump(key)\n            return\n        if len(self.cache) >= self.capacity:\n            old_key, _ = self.buckets[self.minfreq].popitem(last=False)\n            del self.cache[old_key]\n            del self.freq[old_key]\n        self.cache[key] = value\n        self.freq[key] = 1\n        self.buckets[1][key] = None\n        self.minfreq = 1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "LFUCache.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "examples/code/cache.py",
    "line": 37,
    "signature": "def __init__(self, capacity: int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, capacity: int):\n        self.capacity    = capacity\n        self.cache       = {}  \n        self.freq        = {}  \n        self.buckets     = defaultdict(OrderedDict)  \n        self.minfreq     = 0",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "LFUCache._bump": {
    "name": "_bump",
    "type": "method",
    "language": "python",
    "file": "examples/code/cache.py",
    "line": 44,
    "signature": "def _bump(self, key: int):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "Move key from freq f to f+1.",
    "code": "def _bump(self, key: int):\n        del self.buckets[f][key]\n        if not self.buckets[f]:\n            del self.buckets[f]\n            if self.minfreq == f:\n                self.minfreq += 1\n        self.freq[key] +=1 \n        self.buckets[f + 1][key] = None",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "LFUCache.get": {
    "name": "get",
    "type": "method",
    "language": "python",
    "file": "examples/code/cache.py",
    "line": 58,
    "signature": "def get(self, key: int) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "When an item is accessed (get or put), its frequency count is incremented, and it moves from its current frequency bucket to the next, becoming the most recent item in that new bucket. For eviction, we remove the least recently used item from the lowest frequency bucket.",
    "code": "def get(self, key: int) -> int:\n            return -1\n        self._bump(key)\n        return self.cache[key]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "LFUCache.put": {
    "name": "put",
    "type": "method",
    "language": "python",
    "file": "examples/code/cache.py",
    "line": 67,
    "signature": "def put(self, key: int, value: int) -> None:",
    "parameters": [],
    "return_type": "None",
    "return_description": "",
    "description": "When an item is added or updated, its frequency count is set to 1, and it's added to the lowest frequency bucket. If the cache exceeds its capacity, the least recently used item from the lowest frequency bucket is removed.",
    "code": "def put(self, key: int, value: int) -> None:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._bump(key)\n            return\n        if len(self.cache) >= self.capacity:\n            old_key, _ = self.buckets[self.minfreq].popitem(last=False)\n            del self.cache[old_key]\n            del self.freq[old_key]\n        self.cache[key] = value\n        self.freq[key] = 1\n        self.buckets[1][key] = None\n        self.minfreq = 1",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "LFUCache"
  },
  "Solution": {
    "name": "Solution",
    "type": "class",
    "language": "python",
    "file": "examples/code/stack.py",
    "line": 1,
    "signature": "class Solution:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class Solution:\n    def decodeString(self, s: str) -> str:\n        stack, s = [], \"1[\" + s + \"]\"\n        for c in s:\n            if c == \"]\":\n                curr = []\n                while stack[-1] != \"[\":\n                    curr.append(stack.pop())\n                stack.pop()  \n                num = []\n                while stack and stack[-1].isdigit():\n                    num.append(stack.pop())\n                stack.append(\"\".join(reversed(curr)) * int(\"\".join(reversed(num))))\n            else:\n                stack.append(c)\n        return stack[0]",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Solution.decodeString": {
    "name": "decodeString",
    "type": "method",
    "language": "python",
    "file": "examples/code/stack.py",
    "line": 2,
    "signature": "def decodeString(self, s: str) -> str:",
    "parameters": [],
    "return_type": "str",
    "return_description": "",
    "description": "",
    "code": "def decodeString(self, s: str) -> str:\n        stack, s = [], \"1[\" + s + \"]\"\n        for c in s:\n            if c == \"]\":\n                curr = []\n                while stack[-1] != \"[\":\n                    curr.append(stack.pop())\n                stack.pop()  \n                num = []\n                while stack and stack[-1].isdigit():\n                    num.append(stack.pop())\n                stack.append(\"\".join(reversed(curr)) * int(\"\".join(reversed(num))))\n            else:\n                stack.append(c)\n        return stack[0]",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Solution"
  },
  "TreeNode": {
    "name": "TreeNode",
    "type": "class",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 4,
    "signature": "class TreeNode:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "TreeNode.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 5,
    "signature": "def __init__(self, val=0, left=None, right=None):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "TreeNode"
  },
  "levelOrder": {
    "name": "levelOrder",
    "type": "function",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 11,
    "signature": "def levelOrder(root: TreeNode | None) -> list[list[int]]:",
    "parameters": [],
    "return_type": "list[list[int]]",
    "return_description": "",
    "description": "",
    "code": "def levelOrder(root: TreeNode | None) -> list[list[int]]:\n    if not root:\n        return []\n    queue, result = deque([root]), []\n    while queue:\n        level = [] \n        for _ in range(len(queue)):  \n            node = queue.popleft()\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level)\n    return result",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "numIslands": {
    "name": "numIslands",
    "type": "function",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 29,
    "signature": "def numIslands(grid: list[list[str]]) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[str]]",
        "description": "`m x n` 2D grid of `1`s (land) and `0`s (water), assume all four edges of the grid are all surrounded by water.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "number of islands",
    "description": "Args:",
    "code": "def numIslands(grid: list[list[str]]) -> int:\n        return 0\n    m, n = len(grid), len(grid[0])\n    dirs = ((1,0),(-1,0),(0,1),(0,-1))\n    islands = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                islands += 1\n                grid[i][j] = \"0\" \n                q = deque([(i, j)])\n                while q:\n                    r, c = q.popleft()\n                    for dr, dc in dirs:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == \"1\":\n                            grid[nr][nc] = \"0\" \n                            q.append((nr, nc)) \n    return islands",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "orangesRotting": {
    "name": "orangesRotting",
    "type": "function",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 60,
    "signature": "def orangesRotting(grid: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[int]]",
        "description": "`m x n` 2D grid of $0_{(empty)}$ , $1_{(fresh)}$ , $2_{(rotten)}$",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minutes required until no fresh oranges remain. If it's impossible, return -1.",
    "description": "Args:",
    "code": "def orangesRotting(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    q, fresh = deque(), 0\n    dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append((i, j))\n            elif grid[i][j] == 1:\n                fresh += 1\n    if fresh == 0:\n        return 0\n    minutes = 0\n    while q and fresh:\n        minutes += 1\n        for _ in range(len(q)):\n            x, y = q.popleft()\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh -= 1\n                    q.append((nx, ny))\n    return minutes if fresh == 0 else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Node": {
    "name": "Node",
    "type": "class",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 97,
    "signature": "class Node:",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "Node.__init__": {
    "name": "__init__",
    "type": "method",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 98,
    "signature": "def __init__(self, val=0, neighbors=None):",
    "parameters": [],
    "return_type": "",
    "return_description": "",
    "description": "",
    "code": "def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []",
    "links": [],
    "variables": [],
    "expressions": [],
    "parent": "Node"
  },
  "cloneGraph": {
    "name": "cloneGraph",
    "type": "function",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 103,
    "signature": "def cloneGraph(node: Node | None) -> Node | None:",
    "parameters": [
      {
        "name": "node",
        "type": "Node | None",
        "description": "reference to a node in a connected undirected graph",
        "default": null
      }
    ],
    "return_type": "Node | None",
    "return_description": "deep copy of the graph",
    "description": "Args:",
    "code": "def cloneGraph(node: Node | None) -> Node | None:\n        return None\n    cloned = {node: Node(node.val)}\n    queue = deque([node])\n    while queue:\n        cur = queue.popleft()\n        for n in cur.neighbors:\n            if n not in cloned:\n                cloned[n] = Node(n.val)\n                queue.append(n)\n            cloned[cur].neighbors.append(cloned[n])\n    return cloned[node]",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "snakesAndLadders": {
    "name": "snakesAndLadders",
    "type": "function",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 127,
    "signature": "def snakesAndLadders(board: list[list[int]]) -> int:",
    "parameters": [
      {
        "name": "board",
        "type": "list[list[int]]",
        "description": "`n x n` 2D grid of `-1`s (normal squares) or [`1` , `n*n`] (snake/ladder)",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum number of moves to reach the final square `n*n`",
    "description": "Args:",
    "code": "def snakesAndLadders(board: list[list[int]]) -> int:\n    flat_board =  [0] \n    for r, row in enumerate(reversed(board)):\n        flat_board.extend(row[::1 if r % 2 == 0 else -1])\n    target =(n:= len(board)) * n \n    moves, queue =  {1: 0}, deque([1])\n    while queue:\n        current = queue.popleft()\n        for roll in range(1, 7):\n            nxt = current + roll\n            if nxt > target:\n                break\n            landing = flat_board[nxt] if flat_board[nxt] != -1 else nxt\n            if landing not in moves:\n                moves[landing] = moves[current] + 1\n                if landing == target:\n                    return moves[landing]\n                queue.append(landing)\n    return -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "updateMatrix": {
    "name": "updateMatrix",
    "type": "function",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 157,
    "signature": "def updateMatrix(mat : list[list[int]]) -> list[list[int]]:",
    "parameters": [],
    "return_type": "list[list[int]]",
    "return_description": "",
    "description": "",
    "code": "def updateMatrix(mat : list[list[int]]) -> list[list[int]]:\n    m, n = len(mat), len(mat[0])\n    dist = [[-1] * n for _ in range(m)]\n    q = deque()\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and dist[ni][nj] < 0:\n                dist[ni][nj] = dist[i][j] + 1\n                q.append((ni, nj))\n    return dist",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "shortestPath": {
    "name": "shortestPath",
    "type": "function",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 180,
    "signature": "def shortestPath(grid: list[list[int]], k: int) -> int:",
    "parameters": [
      {
        "name": "grid",
        "type": "list[list[int]]",
        "description": "`m x n` 2D grid of `0`s (empty) and `1`s (obstacle)",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "maximum number of eliminations allowed",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "minimum number of steps to reach the bottom-right corner, or -1 if it's impossible",
    "description": "Args:",
    "code": "def shortestPath(grid: list[list[int]], k: int) -> int:\n    rows, cols = len(grid), len(grid[0])\n    min_steps = rows + cols - 2  \n    if k >= min_steps:\n        return min_steps\n    max_k = [[-1] * cols for _ in range(rows)]\n    max_k[0][0] = k\n    q = deque([(0, 0, 0, k)])\n    directions = [(1,0), (-1,0), (0,1), (0,-1)]\n    while q:\n        r, c, steps, remaining_k = q.popleft()\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                new_remaining_k = remaining_k - grid[nr][nc]\n                if new_remaining_k > max_k[nr][nc]:\n                    if (nr, nc) == (rows - 1, cols - 1):\n                        return steps + 1\n                    max_k[nr][nc] = new_remaining_k\n                    q.append((nr, nc, steps + 1, new_remaining_k))\n    return -1",
    "links": [
      {
        "symbol": "r",
        "display": "[r]",
        "target": "r",
        "valid": false,
        "target_symbol": null
      },
      {
        "symbol": "c",
        "display": "[c]",
        "target": "c",
        "valid": false,
        "target_symbol": null
      }
    ],
    "variables": [
      {
        "name": "max_k",
        "description": "max_k[r][c] = maximum eliminations remaining when visiting (r,c)",
        "type": "variable"
      },
      {
        "name": "q",
        "description": "queue items: (row, col, steps, remaining_k)",
        "type": "variable"
      },
      {
        "name": "min_steps",
        "description": "Manhattan distance lower bound",
        "type": "variable"
      }
    ],
    "expressions": []
  },
  "ladderLength": {
    "name": "ladderLength",
    "type": "function",
    "language": "python",
    "file": "examples/code/bfs.py",
    "line": 223,
    "signature": "def ladderLength(beginWord: str, endWord: str, wordList: list[str]) -> int:",
    "parameters": [],
    "return_type": "int",
    "return_description": "",
    "description": "",
    "code": "def ladderLength(beginWord: str, endWord: str, wordList: list[str]) -> int:\n    if endWord not in wordList:\n        return 0\n    L = len(beginWord)\n    combos: dict[str, list[str]] = defaultdict(list)\n    for w in wordList:\n        for i in range(L):\n            combos[w[:i] + \"*\" + w[i+1:]].append(w)\n    front, back = {beginWord}, {endWord}\n    dist_front, dist_back = {beginWord: 1}, {endWord: 1}\n    while front and back:\n        if len(front) > len(back):\n            front, back = back, front\n            dist_front, dist_back = dist_back, dist_front\n        next_front = set()\n        for word in front:\n            for i in range(L):\n                for n in combos[word[:i] + \"*\" + word[i+1:]]: \n                    if n in dist_back:\n                        return dist_front[word] + dist_back[n]\n                    if n not in dist_front:\n                        dist_front[n] = dist_front[word] + 1\n                        next_front.add(n)\n        front = next_front\n    return 0",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "mod": {
    "name": "mod",
    "type": "function",
    "language": "python",
    "file": "examples/code/modular-arithmetic.py",
    "line": 1,
    "signature": "def mod(a: int, b: int) -> int:",
    "parameters": [
      {
        "name": "a",
        "type": "int",
        "description": "the first number1",
        "default": null
      },
      {
        "name": "b",
        "type": "int",
        "description": "the second number",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "int",
    "description": "a mod b",
    "code": "def mod(a: int, b: int) -> int:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "congruent1": {
    "name": "congruent1",
    "type": "function",
    "language": "python",
    "file": "examples/code/modular-arithmetic.py",
    "line": 14,
    "signature": "def congruent1(a: int, b: int, n: int) -> bool:",
    "parameters": [
      {
        "name": "a",
        "type": "int",
        "description": "the first number2",
        "default": null
      },
      {
        "name": "b",
        "type": "int",
        "description": "the second number",
        "default": null
      },
      {
        "name": "n",
        "type": "int",
        "description": "the modulus, the number by which we are dividing",
        "default": null
      }
    ],
    "return_type": "bool",
    "return_description": "bool",
    "description": "a ≡ b (mod n)",
    "code": "def congruent1(a: int, b: int, n: int) -> bool:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "congruent2": {
    "name": "congruent2",
    "type": "function",
    "language": "python",
    "file": "examples/code/modular-arithmetic.py",
    "line": 27,
    "signature": "def congruent2(a: int, b: int, n: int) -> bool:",
    "parameters": [
      {
        "name": "a",
        "type": "int",
        "description": "the first number3",
        "default": null
      },
      {
        "name": "b",
        "type": "int",
        "description": "the second number",
        "default": null
      },
      {
        "name": "n",
        "type": "int",
        "description": "the modulus, the number by which we are dividing",
        "default": null
      }
    ],
    "return_type": "bool",
    "return_description": "bool",
    "description": "a ≡ b (mod n)",
    "code": "def congruent2(a: int, b: int, n: int) -> bool:",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "maxSubArrayLen": {
    "name": "maxSubArrayLen",
    "type": "function",
    "language": "python",
    "file": "examples/code/prefix_sum.py",
    "line": 3,
    "signature": "def maxSubArrayLen(segments: list[int], k: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "Target sum.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The length of the longest subarray with sum == k.",
    "description": "Find the maximum length of a subarray that sums to exactly k.",
    "code": "def maxSubArrayLen(segments: list[int], k: int) -> int:\n    marker_idx = {0: -1}\n    prefix_sum = max_length = 0\n    for i, segment in enumerate(segments):\n        prefix_sum += segment\n        if (target_marker := prefix_sum - k) in marker_idx:\n            max_length = max(max_length, i - marker_idx[target_marker])\n        if prefix_sum not in marker_idx:\n            marker_idx[prefix_sum] = i\n    return max_length",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "subarraySum": {
    "name": "subarraySum",
    "type": "function",
    "language": "python",
    "file": "examples/code/prefix_sum.py",
    "line": 30,
    "signature": "def subarraySum(segments: list[int], k: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "Target sum.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The count of subarrays with sum == k.",
    "description": "Count the number of subarrays that sum to exactly k.",
    "code": "def subarraySum(segments: list[int], k: int) -> int:\n    marker_frequency = defaultdict(int, {0: 1})\n    prefix_sum = count = 0\n    for segment in segments:\n        prefix_sum += segment\n        count += marker_frequency[prefix_sum - k]\n        marker_frequency[prefix_sum] += 1\n    return count",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "findMaxLength": {
    "name": "findMaxLength",
    "type": "function",
    "language": "python",
    "file": "examples/code/prefix_sum.py",
    "line": 52,
    "signature": "def findMaxLength(segments: list[int]) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers (positive for forward, negative/zero for backward).",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The length of the longest balanced subarray.",
    "description": "Find the maximum length of a contiguous subarray with an equal number of positive and negative values.",
    "code": "def findMaxLength(segments: list[int]) -> int:\n    return maxSubArrayLen(normalized_segments, 0)",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "checkSubarraySum": {
    "name": "checkSubarraySum",
    "type": "function",
    "language": "python",
    "file": "examples/code/prefix_sum.py",
    "line": 65,
    "signature": "def checkSubarraySum(segments: list[int], k: int) -> bool:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "The divisor.",
        "default": null
      }
    ],
    "return_type": "bool",
    "return_description": "True if such a subarray exists, False otherwise.",
    "description": "Check if the array contains a subarray of at least length 2 whose sum is a multiple of k.",
    "code": "def checkSubarraySum(segments: list[int], k: int) -> bool:\n    remainder_idx = {0: -1}\n    prefix_remainder = 0\n    for i, segment in enumerate(segments):\n        prefix_remainder = (prefix_remainder + segment) % k\n        if prefix_remainder in remainder_idx:\n            if i - remainder_idx[prefix_remainder] > 1:\n                return True\n        else:\n            remainder_idx[prefix_remainder] = i\n    return False",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "subarraysDivByK": {
    "name": "subarraysDivByK",
    "type": "function",
    "language": "python",
    "file": "examples/code/prefix_sum.py",
    "line": 89,
    "signature": "def subarraysDivByK(segments: list[int], k: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "k",
        "type": "int",
        "description": "The divisor.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The count of subarrays with sum divisible by k.",
    "description": "Count the number of subarrays whose sum is divisible by k.",
    "code": "def subarraysDivByK(segments: list[int], k: int) -> int:\n    remainder_frequency = defaultdict(int, {0: 1})\n    prefix_remainder = count = 0\n    for segment in segments:\n        prefix_remainder = (prefix_remainder + segment) % k\n        count += remainder_frequency[prefix_remainder]\n        remainder_frequency[prefix_remainder] += 1\n    return count",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "minSubarray": {
    "name": "minSubarray",
    "type": "function",
    "language": "python",
    "file": "examples/code/prefix_sum.py",
    "line": 110,
    "signature": "def minSubarray(segments: list[int], p: int) -> int:",
    "parameters": [
      {
        "name": "segments",
        "type": "list[int]",
        "description": "List of integers representing trip segments.",
        "default": null
      },
      {
        "name": "p",
        "type": "int",
        "description": "The divisor.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The length of the shortest subarray to remove, or -1 if not possible.",
    "description": "Find the length of the shortest subarray to remove so that the sum of the remaining elements is divisible by p.",
    "code": "def minSubarray(segments: list[int], p: int) -> int:\n    total_remainder = sum(segments) % p\n    if total_remainder == 0:\n        return 0\n    remainder_idx = {0: -1}\n    prefix_remainder, min_length = 0, len(segments)\n    for i, segment in enumerate(segments):\n        prefix_remainder = (prefix_remainder + segment) % p\n        need = (prefix_remainder - total_remainder + p) % p\n        if need in remainder_idx:\n            min_length = min(min_length, i - remainder_idx[need])\n        remainder_idx[prefix_remainder] = i\n    return min_length if min_length < len(segments) else -1",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "getModifiedArray": {
    "name": "getModifiedArray",
    "type": "function",
    "language": "python",
    "file": "examples/code/prefix_sum.py",
    "line": 138,
    "signature": "def getModifiedArray(length: int, updates: list[list[int]]) -> list[int]:",
    "parameters": [
      {
        "name": "length",
        "type": "int",
        "description": "The number of days in the itinerary.",
        "default": null
      },
      {
        "name": "updates",
        "type": "list[list[int]]",
        "description": "List of [start_day, end_day, change_in_km] updates.",
        "default": null
      }
    ],
    "return_type": "list[int]",
    "return_description": "The final daily travel plan after all updates.",
    "description": "Apply a list of range updates to an array and return the modified array.",
    "code": "def getModifiedArray(length: int, updates: list[list[int]]) -> list[int]:\n    delta = [0] * (length + 1)\n    for start_day, end_day, change_in_km in updates:\n        delta[start_day] += change_in_km\n        delta[end_day + 1] -= change_in_km\n    prefix_sum = 0\n    return [prefix_sum := prefix_sum + change for change in delta[:-1]]",
    "links": [],
    "variables": [],
    "expressions": []
  },
  "numberOfArrays": {
    "name": "numberOfArrays",
    "type": "function",
    "language": "python",
    "file": "examples/code/prefix_sum.py",
    "line": 159,
    "signature": "def numberOfArrays(differences: list[int], lower: int, upper: int) -> int:",
    "parameters": [
      {
        "name": "differences",
        "type": "list[int]",
        "description": "List of daily changes (trip segments).",
        "default": null
      },
      {
        "name": "lower",
        "type": "int",
        "description": "Lower bound for any marker on the highway.",
        "default": null
      },
      {
        "name": "upper",
        "type": "int",
        "description": "Upper bound for any marker on the highway.",
        "default": null
      }
    ],
    "return_type": "int",
    "return_description": "The number of valid starting values.",
    "description": "Count the number of valid starting values for a hidden sequence given the differences and bounds.",
    "code": "def numberOfArrays(differences: list[int], lower: int, upper: int) -> int:\n    prefix_sum = min_marker = max_marker = 0\n    for diff in differences:\n        prefix_sum += diff\n        min_marker = min(min_marker, prefix_sum)\n        max_marker = max(max_marker, prefix_sum)\n    return max(0, (upper - max_marker) - (lower - min_marker) + 1)",
    "links": [],
    "variables": [],
    "expressions": []
  }
}