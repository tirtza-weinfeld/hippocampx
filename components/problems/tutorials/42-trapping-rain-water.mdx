# Trapping Rain Water

## Resizable Table Of contents

<DifficultyBadge difficulty="hard" />

<PillList pills={["two-pointer"]} />

[42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

## [!(ProblemDefinition)] Definition

Given a list of n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

## Two Pointer Solution

### [!(ProblemIntuition)] Intuition

- Water trapped above each bar depends on the smaller of the tallest walls to its left and right:
    - By keeping two pointers—one at each end—and always moving the smaller side inward, we ensure that the limiting wall for that side is already known.
        - When the left bar is shorter, we can safely compute water at left using lmax (its tallest left wall), because a taller or equal wall must exist on the right.
        - Symmetrically, when the right bar is shorter, we compute water using rmax.
    - This invariant guarantees every position’s water level is computed exactly once in O(n) time and O(1) space

### [!(ProblemTimeComplexity)] Time Complexity

- $O(n)$

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/42-trapping-rain-water/two-pointer.py"
def trap(height: list[int]) -> int:
    l, r = 0, len(height) - 1
    lmax = rmax = water = 0

    while l < r:
        if (hl:=height[l]) < (hr:=height[r]):
            lmax = max(lmax, hl)
            water += lmax - hl
            l += 1
        else:
            rmax = max(rmax, hr)
            water += rmax - hr
            r -= 1
    return water
```


---

## Forward Fill With Tail Closure Solution

### [!(ProblemTimeComplexity)] Time Complexity

- $O(n)$

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/42-trapping-rain-water/forward-fill-with-tail-closure.py"
def trapping_rain_water(height: list[int]) -> int:
    l = trapped = 0

    for r, h in enumerate(height):
        if h >= (wall := height[l]):
            for v in height[l:r]:
                trapped += wall - v
            l = r

    maxr = height[-1]
    for v in reversed(height[l:]):
        maxr = max(maxr, v)
        trapped += max(0, maxr - v)

    return trapped
```

