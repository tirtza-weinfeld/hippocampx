# Snakes and Ladders

## Resizable Table Of contents

<DifficultyBadge difficulty="medium" />

<PillList pills={["bfs"]} />

[909. Snakes and Ladders](https://leetcode.com/problems/snakes-and-ladders)

## [!ProblemDefinition] Definition

Given an `n Ã— n` integer board where cells are numbered from `1` to `nÂ²` in a Boustrophedonical style. Each cell's value is either **[3!]-1** for a *[3!]normal* square or a **[16!]destination** number for a *[16!]snake/ladder*. Starting from square `1`, return the least number of moves to reach square `nÂ²`. You must take any snake or ladder you land on.

## [!ProblemIntuition] Intuition

- Flatten the Board First ðŸŽ²:
    - The key insight here is to **pre-process the 2D `board` into a 1D `flat_board` list**. This powerful first step handles all the complex Boustrophedonical logic upfront. By doing this, the BFS loop becomes exceptionally clean and avoids the need for a coordinate conversion function. The search can then operate on a simple 1D array, treating the board as the simple, linear graph it truly represents.

## [!ProblemTimeComplexity] Time Complexity

- O(n^2):
    - where n is the dimension of the board. The initial flattening of the board takes O(n^2) time. The subsequent BFS visits each of the n^2 squares at most once.

## [!ProblemCodeSnippet] Code Snippet

```python meta="source=problems/909-snakes-and-ladders/solution.py"
from collections import deque

def snakes_and_ladders(board: list[list[int]]) -> int:

    flat_board =  [0] # Dummy 0 for 1-based indexing
    for r, row in enumerate(reversed(board)):
        flat_board.extend(row[::1 if r % 2 == 0 else -1])

    target =(n:= len(board)) * n 
    moves, queue =  {1: 0}, deque([1])

    while queue:
        current = queue.popleft()
        for roll in range(1, 7):
            nxt = current + roll
            if nxt > target:
                break
            landing = flat_board[nxt] if flat_board[nxt] != -1 else nxt
            if landing not in moves:
                moves[landing] = moves[current] + 1
                if landing == target:
                    return moves[landing]
                queue.append(landing)
    return -1
```

