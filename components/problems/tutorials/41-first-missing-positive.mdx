# First Missing Positive

## Resizable Table Of contents

<DifficultyBadge difficulty="hard" />

<PillList pills={["TODO"]} />

[41. First Missing Positive](https://leetcode.com/problems/first-missing-positive/description/)

## [!(ProblemDefinition)] Definition

Given an unsorted array nums, return the smallest missing positive integer (the smallest integer >0 not appearing in nums).Your solution must run in O(n) time and use O(1) extra space.

## [!(ProblemIntuition)] Intuition

- The goal is to place every number x at its 'natural' index (x - 1).
    - Since the first missing positive must fall within the range [1, n + 1],
    - we treat the input array as a makeshift hash map. By swapping numbers             into their correct positions in-place, we achieve O(n) time and O(1) space.
    - Values outside [1, n] are ignored as they cannot be the first missing positive.

## [!(ProblemTimeComplexity)] Time Complexity

- O(n)
1. Phase 1 (Cyclic Sort):
    - At first glance, the nested 'while' loop inside the 'for' loop might look like O(n^2). However, we use amortized analysis to show it is O(n).
    - Each execution of the swap 'nums[i], nums[j] = nums[j], nums[i]' places at least one number into its final, correct position (where nums[i] == i + 1).
    - Once a number is in its correct position, it is never moved again.
    - Since there are at most n positions to fill, there can be at most n swaps in total across the entire execution of the program.
    - Therefore, Phase 1 is O(n + n) = O(2n), which simplifies to O(n).
2. Phase 2 (Inspection):
    - We iterate through the array once to find the first index where the value doesn't match. This is a simple linear scan: O(n).

## [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/41-first-missing-positive/solution.py"
class Solution:
    def firstMissingPositive(self, nums: list[int]) -> int:

        for i in range(n := len(nums)):
            while 1 <= nums[i] <= n and nums[i] != nums[nums[i]-1]:
                j = nums[i] - 1
                nums[i], nums[j] = nums[j], nums[i]

        for i, val in enumerate(nums):
            if val != i + 1:
                return i + 1

        return n + 1
```

