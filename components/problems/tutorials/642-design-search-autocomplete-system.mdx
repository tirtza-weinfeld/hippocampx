# Design Search Autocomplete System

## Resizable Table Of contents

<DifficultyBadge difficulty="hard" />

<PillList pills={["trie"]} />

[642. Design Search Autocomplete System](https://leetcode.com/problems/design-search-autocomplete-system/description/)

## [!(ProblemDefinition)] Definition

Given historical sentences with frequencies,     design an autocomplete system that:
    - On each typed character, returns the top 3 sentences starting with the current prefix (sorted by frequency, then lexicographically).
    - On #, treats the typed string as a full sentence, stores it, and resets.

## [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/642-design-search-autocomplete-system/solution.py"
from collections import defaultdict

class TrieNode:
    __slots__ = ("children", "hot")
    def __init__(self):
        self.children = defaultdict(TrieNode)
        self.hot: list[str] = []

class AutocompleteSystem:
    def __init__(self, sentences: list[str], times: list[int]):
        self.root = TrieNode()                 
        self.freq = defaultdict(int)          
        self.cur: TrieNode | None = self.root  
        self.buf = ""                          
        for s, t in zip(sentences, times):
            self._add(s, t)

    def _add(self, s: str, delta: int) -> None:
        self.freq[s] += delta
        node = self.root
        for ch in s:
            node = node.children[ch]
            self._update_hot(node, s)

    def _update_hot(self, node: TrieNode, s: str) -> None:
        if s not in node.hot:
            node.hot.append(s)
        node.hot.sort(key=lambda x: (-self.freq[x], x))
        if len(node.hot) > 3:
            node.hot.pop()

    def input(self, c: str) -> list[str]:
        if c == "#":
            if self.buf:
                self._add(self.buf, 1)
            self.buf = ""
            self.cur = self.root
            return []

        self.buf += c
        self.cur = self.cur.children[c]
        return self.cur.hot
```

