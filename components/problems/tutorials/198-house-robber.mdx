# House Robber

## Resizable Table Of contents

<DifficultyBadge difficulty="medium" />

<PillList pills={["dynamic_programming", "dynamic_programming-1D"]} />

[198. House Robber](https://leetcode.com/problems/house-robber)

## [!(ProblemDefinition)] Definition

Given houses[i] = money in house i, return the maximum amount you can rob without robbing two adjacent house.

## Top Down Suffix Solution

### [!(ProblemIntuition)] Intuition

- Deep Dive: Subproblems: dp(i) = maximum money obtainable robbing **suffix** `houses[i..n-1]`,             for 0 ≤ i ≤ n.  (*[4!]suffix ≙ starting from i until the end*)

- Deep Dive: Relation: dp(i) = max(dp(i+1), houses[i] + dp(i+2))
        - Either skip house `i` (best stays `dp(i+1)`)
        - or rob it and skip `i+1` (best is `houses[i] + dp(i+2)`)

- Deep Dive: Topo. order: Decreasing i
        - Subproblems `dp(i)` depend solely on strictly larger `i` so acyclic

- Deep Dive: Base: dp(n)
        - max money obtainable robbing the empty suffix `houses[n..n]`

- Deep Dive: Original: dp(0)
        - maximum money obtainable robbing suffix `houses[0..n-1]` (the whole array)

### [!(ProblemTimeComplexity)] Time Complexity

- $O(n)$:
    - *$\Theta(n)$* subproblems, *$\Theta(1)$* work each → *$\Theta(n)$* total (with memoization)

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/198-house-robber/top-down-suffix.py"
def rob(houses: list[int]) -> int:

    memo = {}
    def dp(i: int) -> int:
        if i >= len(houses):
            return 0
        if i not in memo:
            memo[i] = max(dp(i + 1), houses[i] + dp(i + 2))
        return memo[i]

    return dp(0)
```


---

## Bottom Up Suffix Solution

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/198-house-robber/bottom-up-suffix.py"
def rob(houses: list[int]) -> int:
    h1 = h2 = 0
    for i in reversed(range(len(houses))):
        h1, h2 = max(h1, houses[i] + h2), h1
    return h1
```


---

## Bottom Up Prefix Solution

### [!(ProblemIntuition)] Intuition

- Deep Dive: Subproblems: dp(i) = maximum money obtainable robbing prefix `houses[0..i]
    - for 0 ≤ i < n.  (*[14!]prefix ≙ starting from 0 until i*)

- Deep Dive: Relation: dp(i) = max(dp(i-1), houses[i] + dp(i-2))
        - Either skip house `i` (best stays `dp(i-1)`)
        - or rob it and skip `i-1` (best is `houses[i] + dp(i-2)`)

- Deep Dive: Topo. order: Increasing i
        - Increasing i  (i = 0, 1, ..., n-1)

- Deep Dive: Base: dp(0)
        - max money obtainable robbing the empty prefix `houses[0..0]`

- Deep Dive: Original: dp(n)
        - maximum money obtainable robbing prefix `houses[0..n-1]` (the whole array)

### [!(ProblemTimeComplexity)] Time Complexity

- $O(n)$:
    - *$\Theta(n)$* subproblems, *$\Theta(1)$* work each → *$\Theta(n)$* total

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/198-house-robber/bottom-up-prefix.py"
def rob(houses: list[int]) -> int:
    h1, h2 = 0, 0
    for h in houses:
        h2, h1 = h1, max(h1, h2 + h)
    return h1
```

