# Koko Eating Bananas

## Resizable Table Of contents

<DifficultyBadge difficulty="medium" />

<PillList pills={["binary_search", "binary_search_on_answer"]} />

[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas)

## [!ProblemDefinition] Definition

Given banana piles `piles` and hour limit `h`, find the minimum eating speed
**$k\in\mathbb{N}$** such that **$\sum_{i=1}^{|piles|} \lceil \frac{p_i}{k} \rceil \leq h$** where each hour Koko eats up to `k` bananas from one pile (any leftover hour is wasted)

## [!ProblemIntuition] Intuition

- Binary searching the answer space, (eating speed `k`):
    - The range of possible speeds is from `1` to `max(piles)`
    - The key property is that the problem is **monotonic** (if a speed `k` is fast enough, any speed greater than `k` will also be fast enough)
    - This allows us to binary search for the *minimum* valid speed
    - We test a mid speed (`k = (l + r) // 2`)
        - If it's valid (`hours(k) <= h`), we try to find a smaller valid speed by searching the lower half (`r = k`)
        - If it's too slow, we must increase the speed by searching the upper half (`l = k + 1`)
    - The loop converges on the smallest `k` that works 🍌

## [!ProblemTimeComplexity] Time Complexity

- O(n log m):
    - n is the number of piles
    - m is the maximum pile size

## [!ProblemArguments] Key Arguments

- `piles: list[int]`: The banana piles
- `h: int`: The hour limit

## [!ProblemKeyVariables] Key Variables

- `l`: The left pointer of the binary search
- `r`: The right pointer of the binary search
- `k`: The mid pointer of the binary search

## [!ProblemReturns] Returns

`int`: The minimum eating speed

## [!ProblemCodeSnippet] Code Snippet

```python meta="source=problems/875-koko-eating-bananas/solution.py"
def koko_eating_bananas(piles: list[int], h: int) -> int:

    def hours(k:int) -> int:
        return sum((p + k - 1) // k for p in piles)
        # return sum(math.ceil(pile / k) for pile in piles)

    l, r = 1, max(piles)
    while l < r:
        k = (l + r) // 2
        if hours(k) <= h:
            r = k
        else:
            l = k + 1
    return l
```

