# Max Sum of Rectangle No Larger Than K

## Resizable Table Of contents

<DifficultyBadge difficulty="hard" />

<PillList pills={["kadane"]} />

[363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k)

## [!ProblemDefinition] Definition

Given a 2D matrix and a target sum, return the maximum sum of any submatrix no larger than K.

## [!ProblemCodeSnippet] Code Snippet

```python meta="source=problems/363-max-sum-of-rectangle-no-larger-than-k/solution.py"
from bisect import bisect_left, insort

def max_sum_of_rectangle_no_larger_than_k(mat: list[list[int]], k: int) -> int:
    # [Opt Loop Ordering] transpose so outer loops iterate the smaller dim (fewer (l,r) pairs)
    m, n = len(mat), len(mat[0])
    if m > n:
        mat = [list(r) for r in zip(*mat)]
        m, n = n, m

    # [Kadane Fast-Path] classic Kadane; return value if ≤ k, else None → fall back to constrained step
    def kadane_leq(arr: list[int], K: int) -> int | None:
        best = cur = arr[0]
        for x in arr[1:]:
            cur = x if cur < 0 else cur + x  # Kadane "extend or restart"
            best = max(best, cur)
            if best == K:
                return K  # [Early Exit] cannot beat K
        return best if best <= K else None

    ans = float("-inf")

    # ------------------- Technique 1: Column-Pair Compression (2D → 1D) -------------------
    # Fix left/right columns; accumulate row sums inside this strip → a 1D array `row`.
    # Any contiguous subarray of `row` == some rectangle between columns [l..r].
    for l in range(n):
        row = [0] * m
        for r in range(l, n):
            for i in range(m):
                row[i] += mat[i][r]

            # Example: if mat = [[1,2,3],[4,5,6],[7,8,9]], (l,r)=(0,1) → row=[1+2,4+5,7+8]=[3,9,15]

            # ------------------- Technique 2: Kadane (fast path, unconstrained) -------------------
            fast = kadane_leq(row, k)
            if fast is not None:
                ans = max(ans, fast)
                if ans == k:
                    return k  # [Early Exit]
                continue

            # ------------------- Technique 3: Ordered Prefix Sums + Binary Search -------------------
            # 1D target: max subarray sum ≤ k on `row` with negatives allowed.
            # Keep sorted prefix sums; for running sum s, find smallest prefix p ≥ s-k → s - p ≤ k and as large as possible.
            # Example: row=[3,-2,5], k=6:
            # pref=[0]; s=3→need ≥ -3→pick 0→cand=3; s=1→≥ -5→0→cand=1; s=6→≥ 0→0→cand=6 (best)
            s, pref = 0, [0]
            for v in row:
                s += v
                j = bisect_left(pref, s - k)  # find smallest prefix ≥ s-k
                if j < len(pref):
                    ans = max(ans, s - pref[j])
                    if ans == k:
                        return k  # [Early Exit]
                insort(pref, s)  # keep prefixes sorted for future queries

    return ans
```

