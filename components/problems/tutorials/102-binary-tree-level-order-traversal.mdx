# Binary Tree Level Order Traversal

## Resizable Table Of contents

<DifficultyBadge difficulty="medium" />

<PillList pills={["binary-tree", "bfs"]} />

[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal)

## [!(ProblemDefinition)] Definition

Given the root of a binary tree, return its nodes values organized by level , from left to right

## Solution Solution

### [!(ProblemIntuition)] Intuition

- The core logic hinges on the inner `for` loop
    - The expression `len(queue)` takes a "snapshot" of the number of nodes on the current level before the loop begins. The loop then dequeues and processes exactly that many nodes, ensuring that only nodes from the current level are handled while their children are queued up for the next iteration. This technique is the key to cleanly separating the levels.

### [!(ProblemTimeComplexity)] Time Complexity

- O(n)
    - where n is the total number of nodes in the tree. This is optimal as every node must be visited once.

### [!(ProblemReturns)] Returns

`list[list[int]]`: List of lists, where each inner list contains values of nodes at the same level

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/102-binary-tree-level-order-traversal/solution.py"
from collections import deque
from core.Tree.binary_tree_node import TreeNode

class Solution:
    def levelOrder(self, root: TreeNode | None) -> list[list[int]]:
        if not root:
            return []
        q, result = deque([root]), []
        while q:
            level = []
            for _ in range(len(q)):
                u = q.popleft()
                level.append(u.val)
                if u.left:
                    q.append(u.left)
                if u.right:
                    q.append(u.right)
            result.append(level)
        return result
```


---

## Similar Solution

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/102-binary-tree-level-order-traversal/similar.py"
from collections import deque

class Solution:
    def levelOrder(self, root):
        if not root:
            return [] 

        result, q = [], deque([root])
        while q:
            result.append([n.val for n in q])
            for _ in range(len(q)):
                node = q.popleft()
                if node.left: 
                    q.append(node.left)
                if node.right:  
                    q.append(node.right)
        return result
```

