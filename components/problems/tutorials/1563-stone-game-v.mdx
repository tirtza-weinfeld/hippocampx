# Stone Game V

## Resizable Table Of contents

<DifficultyBadge difficulty="hard" />

<PillList pills={["dp", "game"]} />

[1563. Stone Game V](https://leetcode.com/problems/stone-game-v/)

## [!(ProblemDefinition)] Definition

Given an array of stone values, split it into two non-empty parts repeatedly. You gain the sum of the chosen side if its total is not smaller than the other’s. Return the maximum score achievable by optimal play

## Bottom Up Solution

### [!(ProblemIntuition)] Intuition

- Split i..j into two parts; you can only keep the smaller-sum side,
    - or either if equal. dp[i][j] = best score in a[i..j].
    - mx[i][j] = best score + sum for a[i..j], to reuse quickly.

- Deep Dive:
    - Each move divides the array into left and right parts. You can only continue with the side whose total sum is smaller; if equal, you may choose either. The goal is to maximize the total score gained from chosen parts.
    - We iterate over all subarrays i..j, expanding outward and adjusting a pointer mid so that the right part stays as large as possible without exceeding half of the total. This ensures we check only balanced splits instead of every possible index.
    - dp[i][j] stores the best score for i..j, while mx[i][j] caches the best “score + sum” prefix or suffix to quickly reuse.

### [!(ProblemTimeComplexity)] Time Complexity

- O(n^2):
    - Because each subarray `i..j` is processed once and the middle pointer `mid` moves **monotonically** (never resets for a fixed `j`), every index is advanced at most O(1) times per outer loop.
    - Thus the total work is roughly proportional to the number of `(i, j)` pairs, giving **O(n²)** time and **O(n²)** space (for `dp` and `mx`).

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/1563-stone-game-v/bottom-up.py"
def stone_game_v(a: list[int]) -> int:
    n = len(a)
    dp = [[0] * n for _ in range(n)]
    mx = [[0] * n for _ in range(n)]
    for i, v in enumerate(a):
        mx[i][i] = v

    for j in range(1, n):
        mid = j
        left = a[j]
        right = 0
        for i in range(j - 1, -1, -1):
            left += a[i]

            while (right + a[mid]) * 2 <= left:
                right += a[mid]
                mid -= 1

            best = 0
            if right * 2 == left:
                best = mx[i][mid]
            if mid != i:
                best = max(best, mx[i][mid - 1])
            if mid != j:
                best = max(best, mx[j][mid + 1])

            dp[i][j] = best
            mx[i][j] = max(mx[i][j - 1], best + left)
            mx[j][i] = max(mx[j][i + 1], best + left)

    return dp[0][n - 1]
```


---

## Top Down Solution

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/1563-stone-game-v/top-down.py"
def stone_game_v(a: list[int]) -> int:
    n = len(a)
    memo: dict[tuple[int, int], int] = {}
    mx: dict[tuple[int, int], int] = {}
    built = [False] * n

    for i, v in enumerate(a):
        memo[(i, i)] = 0
        mx[(i, i)] = v

    def build(j: int) -> None:
        if built[j]:
            return
        if j:
            build(j - 1)
        built[j] = True

        mid = j
        left = a[j]
        right = 0

        for i in range(j - 1, -1, -1):
            left += a[i]

            while mid >= i and (right + a[mid]) * 2 <= left:
                right += a[mid]
                mid -= 1

            best = 0
            if right * 2 == left and mid >= i:
                best = mx[(i, mid)]
            if mid > i:
                best = max(best, mx[(i, mid - 1)])
            if mid < j:
                best = max(best, mx[(j, mid + 1)])

            memo[(i, j)] = best

            cur = best + left
            mx[(i, j)] = max(mx[(i, j - 1)], cur)
            mx[(j, i)] = max(mx.get((j, i + 1), 0), cur)

    def dp(i: int, j: int) -> int:
        if i >= j:
            return 0
        build(j)
        return memo[(i, j)]

    return dp(0, n - 1)
```

