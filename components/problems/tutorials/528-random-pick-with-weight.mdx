# Random Pick with Weight

## Resizable Table Of contents

<DifficultyBadge difficulty="medium" />

<PillList pills={["probability", "prefix-sum"]} />

[528. Random Pick with Weight](https://leetcode.com/problems/random-pick-with-weight/)

## [!(ProblemDefinition)] Definition

Given an array `weights` of positive weights, build a class that returns an index `i` with probability `P(i) = weights[i] / sum(weights)`

## Prefix sums + binary search Solution

### [!(ProblemIntuition)] Intuition

- Prefix sums:
        - Each weight `weights[i]` represents how "wide" index `i` should be on a number line.
        - Build prefix sums so that:
            - `prefix[i] = weights[0] + ... + weights[i]`
        - This turns the array of weights into contiguous segments on [1, total].
        - Example:
            - weights = [2, 5, 3] -> `prefix = [2, 7, 10]`
            - Segments:
                - 1-2   → index 0
                - 3-7   → index 1
                - 8-10  → index 2
        - To pick an index with probability proportional to its weight:
            - Draw a random integer `target ∈ [1, total]`.
            - Find the first `prefix[i] ≥ target`.
            - That `i` is the index whose segment contains `target`.
        - Bigger weight → bigger segment → higher chance of being hit.

### [!(ProblemTimeComplexity)] Time Complexity

- $O(n)$

### [!(ProblemSpaceComplexity)] Space Complexity

- $O(n)$
    - Store only the prefix sum array of length n

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/528-random-pick-with-weight/prefix sums + binary search.py"
import bisect
import random

class Solution:

    def __init__(self, weights: list[int]):
        self.prefix, total = [], 0
        for w in weights:
            total += w
            self.prefix.append(total)
        self.total = total

    def pickIndex(self) -> int:
        return bisect.bisect_left(self.prefix, random.randint(1, self.total))
```


---

## Naive Solution

### [!(ProblemTimeComplexity)] Time Complexity

- $O(sum(weights)$)

### [!(ProblemSpaceComplexity)] Space Complexity

- $O(sum(weights)$):
    - which may be inefficient for large weights.
    - A more efficient solution uses prefix sums + binary search ($O(n)$ space)

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/528-random-pick-with-weight/naive.py"
import random

class Solution:
    def __init__(self, w: list[int]):
        self.p = []
        for i, weight in enumerate(w):
            self.p.extend([i] * (weight))

    def pickIndex(self) -> int:
        index = random.randint(1, len(self.p) - 1)
        return self.p[index]
```

