# Minimum Cost to Merge Stones

## Resizable Table Of contents

<DifficultyBadge difficulty="hard" />

<PillList pills={["dp"]} />

[1000. Minimum Cost to Merge Stones](https://leetcode.com/problems/minimum-cost-to-merge-stones/)

## [!(ProblemDefinition)] Definition

Merge exactly k adjacent piles at a time (cost = sum of those piles). Return the minimum total cost to end with one pile, or -1 if impossible

## [!(ProblemTimeComplexity)] Time Complexity

- O(n^3):
    - There are **O(n²)** subproblems (`l, r` pairs)
    - For each subproblem, the loop `[language="python"]for t in range(l, r, K - 1)`
        - tries up to **O(n / (K - 1))** split points.
        - Each operation inside is *O(1)* (thanks to *[2!]prefix sums*)
    - So the time complexity is O(n^3 / (K - 1))

## [!(ProblemSpaceComplexity)] Space Complexity

- O(n²) for memoization

## [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/1000-minimum-cost-to-merge-stones/solution.py"
class Solution:
    def mergeStones(self, stones: list[int], K: int) -> int:
        if ((n := len(stones)) - 1) % (K - 1):return -1

        prefix, memo = [0], {}
        for x in stones: prefix.append(prefix[-1] + x)
        cost = lambda l, r: 0 if (r - l) % (K - 1) else prefix[r + 1] - prefix[l]

        def dp(l, r):
            if (key := (l, r)) not in memo:
                memo[key] = min(
                    (dp(l, t) + dp(t + 1, r) + cost(l, r) for t in range(l, r, K - 1)),
                    default=0,
                )
            return memo[key]

        return dp(0, n - 1)
```

