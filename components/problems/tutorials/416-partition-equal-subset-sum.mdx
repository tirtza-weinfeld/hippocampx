# Partition Equal Subset Sum

## Resizable Table Of contents

<DifficultyBadge difficulty="medium" />

<PillList pills={["dynamic-programming"]} />

[416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum)

## [!(ProblemDefinition)] Definition

Given an integer array `nums`, determine if you can partition it into two subsets with an equal sum    `1 <= nums.length <= 200` , `1 <= nums[i] <= 100`

## [!(ProblemIntuition)] Intuition

- This is the **0/1 Knapsack** decision problem in disguise:
    - The problem transforms from partitioning an array into a simpler question:             can a subset of "items" (`nums`) perfectly fill a "knapsack" with capacity `total_sum // 2`?             Each item's weight is equal to its value.

## [!(ProblemTimeComplexity)] Time Complexity

- $O(n * target)$

## [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/416-partition-equal-subset-sum/solution.py"
def canPartition(nums: list[int]) -> bool:

    if (total := sum(nums)) & 1:
        return False

    nums.sort(reverse=True)
    if nums[0] > (target := total // 2):
        return False

    memo = {}

    def dp(i: int, r: int) -> bool:
        if r == 0:
            return True
        if r < 0 or i == len(nums):
            return False
        if (k := (i, r)) not in memo:
            memo[k] = dp(i + 1, r - nums[i]) or dp(i + 1, r)
        return memo[k]

    return dp(0, target)
```

