# Paint House

## Resizable Table Of contents

<DifficultyBadge difficulty="medium" />

<PillList pills={["dp"]} />

[256. Paint House](https://leetcode.com/problems/paint-house/)

## [!(ProblemDefinition)] Definition

Paint n houses using colors `{red, blue, green}` with costs given by an `nx3` matrix `costs[i][c]`.Find the minimum total cost so no two adjacent houses share the same color

## Vector Solution

### [!(ProblemIntuition)] Intuition

- Deep Dive:Paint House (k=3) — Top-down DP with explicit memoization:
    - **Subproblems:** dp(i, c) = min total cost to paint houses *[2!]suffix [i:]* given house i is painted color c
    - **Relate:** *$dp(i, c) = costs[i][c] + \min_{c'!=c} dp(i+1, c')$*
    - **Topological order:** *[2!]decreasing i*, subproblem `dp(i)` depends only on strictly larger i, `dp(i+1)`, so acyclic
    - **Base case:** `dp(n) = [0, 0, 0]` (no houses left)
    - **Original problem:** `answer = min(dp(0))`

### [!(ProblemTimeComplexity)] Time Complexity

- $O(n)$:
    - number of subproblems is n (We compute dp(i) once for each i)
    - time per subproblem is $O(1)$ (k=3).
    - → *$\Theta(n)$* total

### [!(ProblemReturns)] Returns

`int`: Minimum total cost to paint all houses with no adjacent equal colors.

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/256-paint-house/vector.py"
class Solution:
    def minCost(self, costs: list[list[int]]) -> int:
        n, memo = len(costs), {}

        def dp(i: int) -> list[int]:
            if i == n:
                return [0, 0, 0]  

            if i not in memo:
                nxt = dp(i + 1)  

                m1 = m2 = float("inf"); c1 = -1
                for c, v in enumerate(nxt):
                    if v < m1:
                        m2, m1, c1 = m1, v, c
                    elif v < m2:
                        m2 = v
                memo[i] = [costs[i][c] + (m2 if c == c1 else m1) for c in range(3)]
            return memo[i]

        return min(dp(0))
```


---

## Scalar Solution

### [!(ProblemIntuition)] Intuition

- Deep Dive:Paint House (k=3) — Top-down DP with explicit memoization:
    - **Subproblems:** dp(i, c) = min total cost to paint houses *[2!]suffix [i:]* given house i is painted color c.
    - **Relate:** `[language="python"]dp(i, c) = costs[i][c] + min(dp(i+1, other_color_1), dp(i+1, other_color_2))`                 *[19!]Choose the cheaper of the two other colors for the next house.*
    - **Topological order:** *[2!]decreasing i*, subproblem `dp(i, c)` depends only on strictly larger i, `dp(i+1, other_color_1)` and `dp(i+1, other_color_2)`, so acyclic
    - **Base case:**`dp(n, c) = 0` → no houses left to paint.
    - **Original problem:** return `min(dp(0, 0), dp(0, 1), dp(0, 2))` — start with any first color.
    - **Time complexity:** *O(n)*: each `(i, c)` computed once, constant work per state.
    - **Space:** *O(n)* for memo and recursion depth.
    - **Returns:** Minimum total cost to paint all houses so that no two adjacent share a color

### [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/256-paint-house/scalar.py"
class Solution:
    def minCost(self, costs: list[list[int]]) -> int:
        n, memo = len(costs), {}

        def dp(i: int, c: int) -> int:
            if i == n:
                return 
            if (i, c) not in memo:

                memo[i, c] = costs[i][c] + min(
                    dp(i + 1, (c + 1) % 3), dp(i + 1, (c + 2) % 3)
                )
            return memo[i, c]

        return min(dp(0, 0), dp(0, 1), dp(0, 2))
```

