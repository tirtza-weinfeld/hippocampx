# Pow(x, n)

## Resizable Table Of contents

<DifficultyBadge difficulty="medium" />

<PillList pills={["math", "binary exponentiation"]} />

[50. Pow(x, n)](https://leetcode.com/problems/powx-n/)

## [!(ProblemDefinition)] Definition

Given a floating-point number x and an integer n, return xⁿ (i.e., x raised to the power n). Constraints: -100.0 < x < 100.0, -2³¹ ≤ n ≤ 2³¹ − 1, and -10⁴ ≤ xⁿ ≤ 10⁴

## [!(ProblemIntuition)] Intuition

- Compute $(x^n)$ using **binary exponentiation**:
    - Each iteration inspects the lowest bit of n:
        - if the bit is 1 → include the current power (base) in the result,
        - square the base for the next power-of-two,
        - shift n right to move to the next bit.
    - For negative n, take the reciprocal and reuse the same logic.

- Example:
        - x = 2, n = 13 → 13 (1101₂):
            - bit 1 → multiply 2¹
            - bit 0 → skip 2²
            - bit 1 → multiply 2⁴
            - bit 1 → multiply 2⁸
        - Result = 2¹ × 2⁴ × 2⁸ = 8192

## [!(ProblemTimeComplexity)] Time Complexity

- O(log n):
    - one step per binary digit of n, (The number of bits in n is *$\lfloor \log₂ n \rfloor + 1$* — fixed by the value of n itself.
    - It doesn’t matter whether those bits are 0 or 1; the loop processes one bit per iteration, so the total work is always proportional to the bit-length of n, not the bit pattern.)

## [!(ProblemReturns)] Returns

`float`: x raised to the power n.

## [!(ProblemCodeSnippet)] Code Snippet

```python meta="source=problems/50-pow/solution.py"
def myPow(x: float, n: int) -> float:
    if n == 0: return 1.0
    if n < 0: return 1.0 / myPow(x, -n)

    result, base = 1.0, x
    while n:
        if n & 1:
            result *= base
        base *= base
        n >>= 1     
    return result
```

