```python meta="source=problems/1293-shortest-path-in-a-grid-with-obstacles-elimination/a_star.py"
import heapq

def shortest_path_in_a_grid_with_obstacles_elimination(grid: list[list[int]], k: int) -> int:

    rows, cols = len(grid), len(grid[0])

    def h(r: int, c: int) -> int:
        return manhattan_distance((r, c), (rows - 1, cols - 1))

    if k >= (md:= h(0, 0)) - 1:
        return md

    pq = [(md, 0, 0, 0, k)]

    max_k = [[-1] * cols for _ in range(rows)]
    max_k[0][0] = k

    while pq:
        _, steps, r, c, remaining_k = heapq.heappop(pq)

        if (r, c) == (rows - 1, cols - 1):
            return steps

        if remaining_k < max_k[r][c]:
            continue

        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            if 0 <= (nr:= r + dr) < rows and 0 <= (nc:= c + dc) < cols:
                if (new_remaining_k := remaining_k - grid[nr][nc] ) > max_k[nr][nc]:
                    max_k[nr][nc] = new_remaining_k
                    heapq.heappush(pq, ((steps + 1) + h(nr, nc), steps + 1, nr, nc, new_remaining_k))

    return -1

def manhattan_distance(a: tuple[int, int], b: tuple[int, int]) -> int:
    return abs(a[0] - b[0]) + abs(a[1] - b[1])
```