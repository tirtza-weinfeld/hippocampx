```python meta="source=problems/1000-minimum-cost-to-merge-stones/similar.py"
class Solution:
    def mergeStones(self, stones: list[int], K: int) -> int:
        if ((n := len(stones)) - 1) % (K - 1):
            return -1

        prefix = [0]
        for x in stones:
            prefix.append(prefix[-1] + x)
        cost = lambda l, r: prefix[r + 1] - prefix[l] if (r - l) % (K - 1) == 0 else 0

        memo = {}

        def dp(l, r):
            if r - l < K - 1:
                return 0
            if (key := (l, r)) not in memo:
               
                memo[key] = cost + min(dp(l, t) + dp(t + 1, r) for t in range(l, r, K - 1))
            return memo[key]

        return dp(0, n - 1)
```