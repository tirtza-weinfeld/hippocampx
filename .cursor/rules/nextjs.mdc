---
alwaysApply: true
---
# Next.js

## CONFIG

```ts
const config: NextConfig = {
  cacheComponents: true,
  typedRoutes: true,
  reactCompiler: true,
}
```

## CACHE VARIANTS

| Directive | Runtime APIs | Prerender | Storage | Use Case |
|-----------|-------------|-----------|---------|----------|
| `'use cache'` | No | Yes | In-memory | Static shared content |
| `'use cache: private'` | Yes | No | Browser | User-specific data |
| `'use cache: remote'` | No | Yes | External KV | Shared across instances |

## CACHE DECISION

1. Static content, no runtime APIs → `'use cache'`
2. User-specific with cookies/headers/searchParams → `'use cache: private'`
3. Shared data, serverless/multi-instance → `'use cache: remote'`
4. Non-deterministic (Math.random, crypto) → `'use cache'`

**Rules:**
- `'use cache'` requires `cacheLife()`
- `'use cache: private'` requires `cacheTag()` + `cacheLife({ stale: 30+ })`
- No runtime APIs inside `'use cache'` or `'use cache: remote'`
- File-level directive: ALL exports must be async
- `<Suspense>` required for uncached async components

## CACHED (file-level)

```tsx
'use cache'

import { cacheLife, cacheTag } from 'next/cache'

export default async function Page() {
  cacheLife('hours')
  cacheTag('page')
  return <div>...</div>
}
```

## CACHED (function-level)

```tsx
import { cacheLife, cacheTag } from 'next/cache'

export async function getData() {
  'use cache'
  cacheLife('hours')
  cacheTag('data')
  return await fetch('...')
}
```

## CACHED PRIVATE (user-specific)

```tsx
import { cookies } from 'next/headers'
import { cacheLife, cacheTag } from 'next/cache'

async function getRecommendations(productId: string) {
  'use cache: private'
  cacheTag(`recs-${productId}`)
  cacheLife({ stale: 60 })  // min 30s for runtime prefetch

  const session = (await cookies()).get('session')?.value || 'guest'
  return getPersonalizedRecs(productId, session)
}
```

## CACHED REMOTE (external storage)

```tsx
import { cacheLife, cacheTag } from 'next/cache'

async function getGlobalStats() {
  'use cache: remote'
  cacheTag('global-stats')
  cacheLife({ expire: 60 })

  return db.analytics.aggregate({ users: 'count', revenue: 'sum' })
}
```

## RUNTIME + CACHE (extract pattern)

```tsx
import { cookies } from 'next/headers'
import { cacheLife } from 'next/cache'

export default async function Page() {
  const currency = (await cookies()).get('currency')?.value ?? 'USD'
  return <CachedPrice productId="123" currency={currency} />
}

async function CachedPrice({ productId, currency }: Props) {
  'use cache'
  cacheLife('hours')
  const price = await getPrice(productId, currency)
  return <div>{price} {currency}</div>
}
```

## PASS-THROUGH (non-serializable)

```tsx
import { cacheLife } from 'next/cache'
import type { ReactNode } from 'react'

async function CachedWrapper({ children }: { children: ReactNode }) {
  'use cache'
  cacheLife('hours')
  const data = await fetch('...')
  return (
    <div>
      <header>{data.title}</header>
      {children}
    </div>
  )
}
```

## REVALIDATION

```tsx
'use server'
import { cacheTag, updateTag, revalidateTag, revalidatePath } from 'next/cache'

async function getCart() {
  'use cache'
  cacheTag('cart')
  return await fetchCart()
}

updateTag('cart')                 // immediate (Server Actions only)
revalidateTag('posts', 'max')     // stale-while-revalidate
revalidatePath('/dashboard')
```

## CACHE PROFILES

```tsx
cacheLife('hours')   // stale: 1h, revalidate: 1h, expire: 1h
cacheLife('days')    // stale: 1d, revalidate: 1d, expire: 1d
cacheLife('weeks')   // stale: 1w, revalidate: 1w, expire: 1w
cacheLife('max')     // stale: 1y, revalidate: 1y, expire: 1y

cacheLife({ stale: 3600, revalidate: 7200, expire: 86400 })
```

## ASYNC PROPS

```tsx
export default async function Page(props: {
  params: Promise<{ id: string }>
  searchParams: Promise<{ q: string }>
}) {
  const { id } = await props.params
  const { q } = await props.searchParams
}
```

## FORM

```tsx
import Form from 'next/form'

<Form action={serverAction}>
  <input name="q" />
</Form>
```

## ERROR BOUNDARY

```tsx
'use client'

export default function Error({ error, reset }: { error: Error; reset: () => void }) {
  return <button onClick={reset}>Retry</button>
}
```

## AUTH

```tsx
import { forbidden, unauthorized } from 'next/navigation'

if (!session) unauthorized()
if (!session.isAdmin) forbidden()
```

## PROXY

```ts
import { NextRequest, NextResponse } from 'next/server'

export function proxy(request: NextRequest) {
  if (!request.cookies.get('token')) return NextResponse.redirect(new URL('/login', request.url))
  return NextResponse.next()
}

export const config = { matcher: ['/dashboard/:path*'] }
```

## ROUTE HANDLERS

```tsx
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  return Response.json({ q: searchParams.get('q') })
}

export async function POST(request: Request) {
  const data = await request.json()
  return Response.json(data, { status: 201 })
}
```

## NAVIGATION

```tsx
import Link from 'next/link'
import { redirect, notFound } from 'next/navigation'

<Link href="/dashboard">Dashboard</Link>
redirect('/login')
notFound()
```

```tsx
'use client'
import { useRouter } from 'next/navigation'

const router = useRouter()
router.push('/settings')
router.refresh()
```
