---
alwaysApply: true
---
# ReactRules

**Definitive guide for React 19 + Next.js App Router + React Compiler RC**

## Strictly Banned 
@.cursor/rules/zeroEffect.mdc 

## SERVER/CLIENT ARCHITECTURE

### Server Components: The Default
Server Components render ahead of time on the server, not sent to browser.

**Server Components excel at:**
- Data fetching (`await fetch`, database queries, filesystem)
- SEO (meta tags, initial content)
- Reducing bundle size (expensive libraries stay on server)
- Static animations (page load, reveals via motion/react-client)
- Rendering without interactivity

**Correct Server Component patterns:**
```tsx
// Direct async/await in components
async function ProductPage({ id }: { id: string }) {
  const product = await db.products.findById(id)
  const reviews = await db.reviews.findByProduct(id)

  return (
    <>
      <title>{product.name}</title>
      <ProductDisplay product={product} />
      <Suspense fallback={<ReviewsSkeleton />}>
        <ReviewsList reviews={reviews} />
      </Suspense>
    </>
  )
}

// Pass data as props to client components
async function Dashboard() {
  const stats = await getStats()
  return <InteractiveChart data={stats} /> // data must be serializable
}

// Compose with client components for interactivity
async function Page() {
  const items = await getItems()
  return (
    <div>
      {items.map(item => (
        <ExpandableCard key={item.id}>
          <ItemDisplay item={item} />
        </ExpandableCard>
      ))}
    </div>
  )
}
```

### Client Components: Add Interactivity
Mark with `"use client"` directive at top of file. Creates module boundary.

**Client Components excel at:**
- User interaction (clicks, forms, state)
- Browser APIs (localStorage, geolocation, window)
- Real-time updates (websockets, polling)
- Interactive animations (hover, drag, gestures)
- Third-party widgets with client dependencies
- Hooks (useState, useEffect, useContext)

**Correct Client Component patterns:**
```tsx
"use client"

// Interactive state and events
function ExpandableCard({ children }: { children: React.ReactNode }) {
  const [expanded, setExpanded] = useState(false)

  return (
    <div>
      <button onClick={() => setExpanded(!expanded)}>
        Toggle
      </button>
      {expanded && children}
    </div>
  )
}

// Receive server data via props
function InteractiveChart({ data }: { data: ChartData }) {
  const [view, setView] = useState<'bar' | 'line'>('bar')

  return (
    <div>
      <button onClick={() => setView('bar')}>Bar</button>
      <button onClick={() => setView('line')}>Line</button>
      <Chart data={data} type={view} />
    </div>
  )
}

// Receive server components as children
function ClientWrapper({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState('light')

  return (
    <ThemeContext.Provider value={theme}>
      {children} {/* Can be server components */}
    </ThemeContext.Provider>
  )
}
```

### Serialization: Props Between Boundaries
Props passed from Server → Client Components must be serializable.

**Serializable types:**
- Primitives: `string`, `number`, `boolean`, `null`, `undefined`
- Iterables: `Array`, `Map`, `Set`
- Plain objects (JSON-compatible)
- Promises (streamed and resolved on client)
- JSX elements (Server Component output)
- Server Actions (functions with `"use server"`)

**Correct serialization patterns:**
```tsx
// ✓ Pass plain data
<ClientComponent user={{ name: "Alice", age: 30 }} />

// ✓ Pass JSX (server components as children)
<ClientComponent>
  <ServerRenderedContent />
</ClientComponent>

// ✓ Pass promises (resolved on client with use())
<ClientComponent dataPromise={fetchData()} />

// ✓ Pass server actions
<ClientForm onSubmit={serverAction} />
```

### Server Actions: Server Functions Called from Client
Mark with `"use server"` to create functions executable on server.

**Correct Server Action patterns:**
```tsx
// Define in server component file
async function createProduct(formData: FormData) {
  "use server"
  const product = await ProductSchema.parse({
    name: formData.get('name'),
    price: formData.get('price')
  })
  await db.insert(products).values(product)
  revalidatePath('/products')
}

// Define in dedicated file with top-level directive
"use server"

export async function updateQuantity(id: string, quantity: number) {
  await db.update(cart).set({ quantity }).where(eq(cart.id, id))
  revalidateTag('cart')
  return { success: true }
}

// Pass to client components
<ProductForm createAction={createProduct} />

// Use in client components
"use client"
function ProductForm({ createAction }) {
  const [state, formAction] = useActionState(createAction, null)

  return (
    <form action={formAction}>
      <input name="name" required />
      <SubmitButton />
    </form>
  )
}
```

### Composition: Mixing Server and Client
**Correct composition patterns:**

```tsx
// Pattern 1: Server wraps Client, passes data down
async function ServerPage() {
  const data = await fetchData()
  return <ClientComponent data={data} />
}

// Pattern 2: Client wraps Server via children prop
function ClientLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="layout">
      {children} {/* Can be server components */}
    </div>
  )
}

// Usage: Server passes Server to Client via children
async function Page() {
  return (
    <ClientLayout>
      <ServerContent /> {/* Rendered on server, passed as JSX */}
    </ClientLayout>
  )
}

// Pattern 3: Server component adds interactivity via Client wrapper
async function ProductList() {
  const products = await getProducts()

  return (
    <div>
      {products.map(product => (
        // Server renders ProductCard, wraps in interactive Client
        <ExpandableWrapper key={product.id}>
          <ProductCard product={product} />
        </ExpandableWrapper>
      ))}
    </div>
  )
}
```

**Data Flow:**
Server fetches → Client interacts → Server Actions mutate → Client optimistic updates

## WHEN TO USE NEW FEATURES

**Use Activity when:**
- Tabs/panels need to preserve state when hidden (form inputs, scroll position)
- Pre-rendering likely next routes for instant navigation
- Sidebar/drawer that opens/closes frequently
- Avoid unmounting/remounting expensive components
- DON'T use for: Components that rarely reappear, simple show/hide

**Use useEffectEvent when:**
- Effect needs latest props/state without re-running the effect
- Analytics/logging that shouldn't trigger reconnections
- Event handlers inside effects that read current values
- Separating "event" logic from reactive dependencies
- DON'T use for: Regular event handlers, shortcut for proper dependencies, or as escape hatch
- WARNING: useEffectEvent cannot be in dependency arrays (React will error)

**Use cacheSignal when:**
- Server Component fetching with auto-cancellation
- Need to differentiate real errors from abort errors
- Want to clean up in-flight requests on render failure
- Works only in RSC, returns null in Client Components
- DON'T use for: Client-side fetching, manual abort control

**Use Partial Pre-rendering (prerender/resume) when:**
- Need hybrid static shell + dynamic content
- Building CDN-friendly apps with per-request data
- Want to split build-time static generation from request-time rendering
- DON'T use in Next.js (use Next.js PPR instead), for fully static sites (use prerender alone), or fully dynamic pages (use streaming SSR)

**SSR Streaming choices:**
- Node.js: Always use renderToPipeableStream/resumeToPipeableStream (faster, supports compression)
- Edge/Deno: Use renderToReadableStream/resume (Web Streams)
- DON'T use Web Streams in Node.js (slower, no compression)

## SERVER PATTERNS

### Server Components + Cache + cacheSignal
```tsx
import { cache, cacheSignal } from 'react'
import * as motion from 'motion/react-client'

// Cache prevents duplicate API calls across components
const getProduct = cache(async (id: string) => {
  return await fetch(`/api/products/${id}`, {
    signal: cacheSignal() // Auto-abort when render completes/fails
  }).then(r => r.json())
})

const getUser = cache(async (userId: string) => {
  return await fetch(`/api/users/${userId}`, {
    signal: cacheSignal()
  }).then(r => r.json())
})

export default async function ProductPage({ id }: { id: string }) {
  // These calls are cached - won't duplicate if called elsewhere
  const product = await getProduct(id)
  const user = await getUser(product.sellerId)

  return (
    <>
      <title>{product.name} - sold by {user.name}</title>
      <meta name="description" content={product.description} />

      {/* Motion works in Server Components via react-client */}
      <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
        <ProductDisplay product={product} seller={user} />
      </motion.div>

      <Suspense fallback={<ReviewsLoading />}>
        <ProductReviews productId={id} />
      </Suspense>
    </>
  )
}

// This will reuse the cached getProduct call - no duplicate API request
async function ProductReviews({ productId }: { productId: string }) {
  const product = await getProduct(productId) // Cache hit!
  const reviews = await fetch(`/api/reviews/${productId}`, {
    signal: cacheSignal()
  }).then(r => r.json())

  return (
    <motion.section initial={{ y: 20 }} animate={{ y: 0 }}>
      <h2>Reviews for {product.name}</h2>
      <ReviewsList reviews={reviews} />
    </motion.section>
  )
}
```

### cacheSignal for Request Management
```tsx
import { cache, cacheSignal } from 'react'

// Auto-abort fetch requests when render completes/fails
const fetchProductData = cache(async (id: string) => {
  const response = await fetch(`/api/products/${id}`, {
    signal: cacheSignal() // Aborts on render completion/failure
  })
  return response.json()
})

// Error handling with cacheSignal
async function getProductWithAnalytics(id: string) {
  try {
    const [product, analytics] = await Promise.all([
      db.query.products.findFirst({ where: eq(products.id, id) }),
      db.query.analytics.findMany({ where: eq(analytics.productId, id) })
    ])
    return { product, analytics }
  } catch (error) {
    // Only log real errors, not cancellation errors
    if (!cacheSignal()?.aborted) {
      logError('Product fetch failed:', error)
    }
    return null
  }
}

// Returns AbortSignal during rendering, null outside rendering or in Client Components
async function Component() {
  const signal = cacheSignal() // AbortSignal or null
  if (signal) {
    // Running in Server Component during render
    await fetchProductData('123')
  }
}
```

### Server Actions
```tsx
// Form actions
async function createProduct(formData: FormData) {
  "use server"
  const product = await ProductSchema.parse({
    name: formData.get('name'),
    price: formData.get('price')
  })
  await db.insert(products).values(product)
  revalidatePath('/products')
}

// Called from client
async function updateQuantity(productId: string, quantity: number) {
  "use server"
  await db.update(cart).set({ quantity }).where(eq(cart.productId, productId))
  revalidateTag('cart')
}
```

## SSR & PARTIAL PRE-RENDERING

### Streaming SSR - Node.js (Preferred)
```tsx
import { renderToPipeableStream } from 'react-dom/server'

async function handler(req: Request, res: Response) {
  const { pipe, abort } = renderToPipeableStream(<App />, {
    bootstrapModules: ['/client.js'],
    onShellReady() {
      // Stream HTML as soon as shell (above Suspense) is ready
      res.statusCode = 200
      res.setHeader('content-type', 'text/html')
      pipe(res)
    },
    onAllReady() {
      // All content ready - use for crawlers
    },
    onShellError(error) {
      // Shell failed - send error page
      res.statusCode = 500
      res.send('<h1>Server Error</h1>')
    },
    onError(error) {
      console.error('Render error:', error)
    }
  })

  // Abort on client disconnect
  req.on('close', abort)
}

// Suspense boundaries automatically batch for better UX
// React batches reveals for short time to show more content together
// Auto-stops batching if approaching 2.5s LCP threshold
```

### Streaming SSR - Edge/Deno
```tsx
import { renderToReadableStream } from 'react-dom/server'

async function handler(request: Request) {
  const stream = await renderToReadableStream(<App />, {
    bootstrapModules: ['/client.js'],
    signal: request.signal, // Auto-abort on disconnect
    onError(error) {
      console.error('Render error:', error)
    }
  })

  // Wait for shell before responding
  await stream.allReady

  return new Response(stream, {
    status: 200,
    headers: { 'content-type': 'text/html' }
  })
}
```

### Partial Pre-rendering - Build + Runtime
```tsx
import { prerender } from 'react-dom/static'
import { resumeToPipeableStream } from 'react-dom/server'

// 1. Build time: Generate static shell
async function buildStaticShell() {
  const controller = new AbortController()

  const { prelude, postponed } = await prerender(<App />, {
    signal: controller.signal,
    bootstrapModules: ['/client.js']
  })

  // Save postponed state (JSON-serializable)
  await fs.writeFile('build/postponed.json', JSON.stringify(postponed))

  // Deploy prelude (static HTML) to CDN
  await fs.writeFile('build/index.html', prelude)
}

// 2. Runtime: Resume with dynamic content (Node.js)
async function handleRequest(req: Request, res: Response) {
  const postponed = JSON.parse(await fs.readFile('build/postponed.json', 'utf-8'))

  const { pipe } = resumeToPipeableStream(<App />, postponed, {
    bootstrapModules: ['/client.js'],
    onShellReady() {
      res.setHeader('content-type', 'text/html')
      pipe(res)
    },
    onError(error) {
      console.error('Resume error:', error)
    }
  })
}

// Alternative: Edge/Deno with Web Streams
import { resume } from 'react-dom/static'

async function handleRequestEdge(request: Request) {
  const postponed = await getPostponedState()

  const stream = await resume(<App />, postponed, {
    bootstrapModules: ['/client.js']
  })

  return new Response(stream, {
    headers: { 'content-type': 'text/html' }
  })
}
```

### Static Generation with Resume
```tsx
import { resumeAndPrerender } from 'react-dom/static'

// Generate fully static HTML from postponed state
async function generateStaticPage(params: { id: string }) {
  const postponed = await getPostponedState(params)

  const { prelude } = await resumeAndPrerender(<ProductPage {...params} />, postponed, {
    bootstrapModules: ['/client.js'],
    onError(error) {
      console.error('Static gen error:', error)
    }
  })

  // Fully static HTML ready for CDN
  return prelude
}
```

## CLIENT PATTERNS

### Client Components
```tsx
"use client"

// Interactive component with state
export default function ProductForm({ createAction }: { createAction: any }) {
  const [state, formAction] = useActionState(createAction, null)
  const [optimisticProducts, addOptimistic] = useOptimistic(products, reducer)
  const { pending } = useFormStatus()

  return (
    <form action={formAction}>
      <input name="name" required />
      <input name="price" type="number" required />
      <button disabled={pending}>
        {pending ? "Creating..." : "Create Product"}
      </button>
      {state?.error && <p className="text-red-500">{state.error}</p>}
    </form>
  )
}

// Event handling
function Counter() {
  const [count, setCount] = useState(0)

  return (
    <button onClick={() => setCount(c => c + 1)}>
      Count: {count}
    </button>
  )
}
```

### useEffectEvent for Non-Reactive Logic
```tsx
"use client"
import { useEffectEvent } from 'react'

// Extract non-reactive logic from effects
function ChatRoom({ roomId, theme }: { roomId: string, theme: string }) {
  const [message, setMessage] = useState('')

  // Event reads latest props without causing re-renders
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme) // Uses latest theme
  })

  useEffect(() => {
    const connection = createConnection(roomId)
    connection.on('connected', onConnected)
    connection.connect()
    return () => connection.disconnect()
  }, [roomId]) // Only re-run on roomId change, not theme

  return <input value={message} onChange={e => setMessage(e.target.value)} />
}

// Analytics example - read latest values without triggering effects
function Page({ url }: { url: string }) {
  const { items } = useContext(ShoppingCartContext)
  const numberOfItems = items.length

  const onNavigate = useEffectEvent((visitedUrl: string) => {
    logVisit(visitedUrl, numberOfItems) // Always uses current cart size
  })

  useEffect(() => {
    onNavigate(url)
  }, [url]) // Only track on URL change, not cart updates

  return <PageContent />
}
```

### Using Promises from Server
```tsx
"use client"

// Reading server data in client
function ProductDetails({ productPromise }: { productPromise: Promise<Product> }) {
  const product = use(productPromise)
  const [isExpanded, setExpanded] = useState(false)

  return (
    <article>
      <h1>{product.name}</h1>
      <button onClick={() => setExpanded(!isExpanded)}>
        {isExpanded ? "Collapse" : "Expand"}
      </button>
      {isExpanded && <ProductSpecs product={product} />}
    </article>
  )
}
```

## DATA FLOW PATTERNS

### Smart Server → Client Streaming
```tsx
import { cache, cacheSignal } from 'react'

// Cached expensive computation - prevents duplicate work
const getProductAnalytics = cache(async (productId: string) => {
  // Complex query that hits multiple tables
  const analytics = await db.query(`
    SELECT p.*, AVG(r.rating), COUNT(r.id) as review_count,
           SUM(o.quantity) as total_sold
    FROM products p
    LEFT JOIN reviews r ON r.product_id = p.id
    LEFT JOIN order_items o ON o.product_id = p.id
    WHERE p.id = ?
  `, [productId])

  return processAnalytics(analytics)
})

const getProduct = cache(async (id: string) => {
  return await fetch(`/api/products/${id}`, {
    signal: cacheSignal()
  }).then(r => r.json())
})

export default async function ProductPage({ id }: { id: string }) {
  // Start multiple fetches in parallel
  const productPromise = getProduct(id)  // Fast
  const analyticsPromise = getProductAnalytics(id)  // Slow

  // Render what we can immediately
  const product = await productPromise

  return (
    <>
      <title>{product.name}</title>
      <ProductHeader product={product} />

      {/* Stream in slow data */}
      <Suspense fallback={<AnalyticsSkeleton />}>
        <ProductAnalytics analyticsPromise={analyticsPromise} />
      </Suspense>

      {/* Interactive client component */}
      <AddToCartClient productId={id} />
    </>
  )
}

// Client reads promise and adds interactivity
"use client"
function ProductAnalytics({ analyticsPromise }: { analyticsPromise: Promise<Analytics> }) {
  const analytics = use(analyticsPromise)
  const [view, setView] = useState<'sales' | 'reviews'>('sales')

  return (
    <div>
      <div className="flex gap-2">
        <button
          onClick={() => setView('sales')}
          className={view === 'sales' ? 'bg-blue-500 text-white' : ''}
        >
          Sales: {analytics.totalSold}
        </button>
        <button
          onClick={() => setView('reviews')}
          className={view === 'reviews' ? 'bg-blue-500 text-white' : ''}
        >
          Reviews: {analytics.reviewCount}
        </button>
      </div>

      {view === 'sales' ? <SalesChart data={analytics.sales} /> : <ReviewsChart data={analytics.reviews} />}
    </div>
  )
}
```

### Form Actions with Optimism
```tsx
"use client"
function TodoList({ todos, addAction }: { todos: Todo[], addAction: any }) {
  const [optimisticTodos, addOptimistic] = useOptimistic(
    todos,
    (state, newTodo: Todo) => [...state, { ...newTodo, pending: true }]
  )

  async function handleSubmit(formData: FormData) {
    const newTodo = { id: Date.now(), text: formData.get('text'), pending: false }
    addOptimistic(newTodo)
    await addAction(formData)
  }

  return (
    <>
      <form action={handleSubmit}>
        <input name="text" required />
        <button>Add Todo</button>
      </form>
      <ul>
        {optimisticTodos.map(todo => (
          <li key={todo.id} className={todo.pending ? 'opacity-50' : ''}>
            {todo.text}
          </li>
        ))}
      </ul>
    </>
  )
}
```

## STATE MANAGEMENT

### Complex State with Reducer
```tsx
type GameState = {
  score: number
  level: number
  isPlaying: boolean
  lives: number
}

type GameAction =
  | { type: 'START_GAME' }
  | { type: 'SCORE_POINT'; points: number }
  | { type: 'LOSE_LIFE' }
  | { type: 'LEVEL_UP' }

function gameReducer(state: GameState, action: GameAction): GameState {
  switch (action.type) {
    case 'START_GAME':
      return { ...state, isPlaying: true, lives: 3 }
    case 'SCORE_POINT':
      return { ...state, score: state.score + action.points }
    case 'LOSE_LIFE':
      const newLives = state.lives - 1
      return { ...state, lives: newLives, isPlaying: newLives > 0 }
    case 'LEVEL_UP':
      return { ...state, level: state.level + 1 }
    default:
      return state
  }
}

function Game() {
  const [state, dispatch] = useReducer(gameReducer, {
    score: 0, level: 1, isPlaying: false, lives: 3
  })

  return (
    <div>
      <div>Score: {state.score} | Level: {state.level} | Lives: {state.lives}</div>
      {!state.isPlaying ? (
        <button onClick={() => dispatch({ type: 'START_GAME' })}>
          Start Game
        </button>
      ) : (
        <GameBoard onScore={(points) => dispatch({ type: 'SCORE_POINT', points })} />
      )}
    </div>
  )
}
```

### External Store Subscriptions
```tsx
"use client"

// Store wrapper
function useStore<T>(store: { subscribe: (fn: () => void) => () => void, getSnapshot: () => T }) {
  return useSyncExternalStore(store.subscribe, store.getSnapshot)
}

// Usage
function ThemeToggle() {
  const theme = useStore(themeStore)

  return (
    <button onClick={() => themeStore.toggle()}>
      Current theme: {theme}
    </button>
  )
}
```

## LOADING & ERROR PATTERNS

### Suspense Boundaries
```tsx
export default function ProductPage() {
  return (
    <>
      <ProductHeader />
      <Suspense fallback={<ProductDetailsSkeleton />}>
        <ProductDetails />
      </Suspense>
      <Suspense fallback={<ReviewsSkeleton />}>
        <ProductReviews />
      </Suspense>
    </>
  )
}
```

### Progressive Loading with Deferred Values
```tsx
"use client"
function SearchResults({ query }: { query: string }) {
  const deferredQuery = useDeferredValue(query)
  const results = useSearchResults(deferredQuery)

  return (
    <div>
      {query !== deferredQuery && <div className="opacity-50">Searching...</div>}
      <ResultsList results={results} />
    </div>
  )
}
```

## ANIMATION PATTERNS

### Server Component Animations (Static)
```tsx
import * as motion from 'motion/react-client'

// Server-rendered with initial animation state
function HeroSection() {
  return (
    <motion.section
      initial={{ opacity: 0, y: 50 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.8 }}
    >
      <h1>Welcome to our site</h1>
    </motion.section>
  )
}

// Works great for page transitions, loading states
async function ProductGrid() {
  const products = await getProducts()

  return (
    <motion.div className="grid grid-cols-3 gap-4">
      {products.map((product, i) => (
        <motion.div
          key={product.id}
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: i * 0.1 }}
        >
          <ProductCard product={product} />
        </motion.div>
      ))}
    </motion.div>
  )
}
```

### Client Component Animations (Interactive)
```tsx
"use client"
import { motion, useReducedMotion, AnimatePresence } from "motion/react"

// Interactive animations need client components
function InteractiveCard({ children }: { children: React.ReactNode }) {
  const [isHovered, setHovered] = useState(false)
  const shouldReduceMotion = useReducedMotion()

  return (
    <motion.div
      onHoverStart={() => setHovered(true)}
      onHoverEnd={() => setHovered(false)}
      whileHover={shouldReduceMotion ? {} : { scale: 1.02 }}
      whileTap={shouldReduceMotion ? {} : { scale: 0.98 }}
    >
      {children}

      <AnimatePresence>
        {isHovered && (
          <motion.div
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute top-0 right-0 bg-blue-500 text-white p-2"
          >
            Quick Actions
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  )
}

// Layout animations for dynamic lists
function TaskManager() {
  const [tasks, setTasks] = useState<Task[]>([])

  return (
    <motion.ul layout className="space-y-2">
      <AnimatePresence>
        {tasks.map(task => (
          <motion.li
            key={task.id}
            layout
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: 20 }}
            whileHover={{ x: 5 }}
          >
            <TaskItem task={task} onComplete={() => removeTask(task.id)} />
          </motion.li>
        ))}
      </AnimatePresence>
    </motion.ul>
  )
}
```

## REF PATTERNS

### Direct Ref Props (No forwardRef)
```tsx
// Modern: ref as prop
function Input({ ref, ...props }: { ref?: React.Ref<HTMLInputElement> }) {
  return <input ref={ref} {...props} />
}

// Usage
function Form() {
  const inputRef = useRef<HTMLInputElement>(null)

  return (
    <form onSubmit={() => inputRef.current?.focus()}>
      <Input ref={inputRef} autoFocus />
    </form>
  )
}
```

### Fragment Refs (React 19+)
```tsx
import { Fragment, useRef } from 'react'

// Attach refs directly to Fragments - no wrapper div needed
// Fragment ref resolves to first child element
function List({ items }: { items: Item[] }) {
  const listRef = useRef<HTMLElement>(null)

  return (
    <Fragment ref={listRef}>
      {items.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </Fragment>
  )
}

// Useful for managing focus without wrapper divs
function MenuItems({ items, onSelect }: { items: MenuItem[], onSelect: (id: string) => void }) {
  const firstItemRef = useRef<HTMLElement>(null)

  return (
    <Fragment ref={firstItemRef}>
      {items.map(item => (
        <li
          key={item.id}
          tabIndex={0}
          onClick={() => onSelect(item.id)}
        >
          {item.label}
        </li>
      ))}
    </Fragment>
  )
}

// Passing Fragment refs through components
function Dialog({ children, contentRef }: {
  children: React.ReactNode
  contentRef?: React.Ref<HTMLElement>
}) {
  return (
    <Fragment ref={contentRef}>
      <h2>Dialog Title</h2>
      <div>{children}</div>
    </Fragment>
  )
}
```

### Ref Callbacks with Cleanup
```tsx
function VideoPlayer() {
  const videoRef = useCallback((video: HTMLVideoElement | null) => {
    if (video) {
      video.play()
      return () => video.pause() // Cleanup function
    }
  }, [])

  return <video ref={videoRef} />
}
```

## CONTEXT PATTERNS

### Modern Context (No Provider)
```tsx
// Create context
const ThemeContext = createContext<'light' | 'dark'>('light')

// Provider component
function App() {
  const [theme, setTheme] = useState<'light' | 'dark'>('light')

  return (
    <ThemeContext value={theme}>
      <Layout />
    </ThemeContext>
  )
}

// Consumer
function ThemeToggle() {
  const theme = use(ThemeContext)
  return <div>Current theme: {theme}</div>
}
```

## RESPONSIVE & PERFORMANCE

### Resource Preloading
```tsx
export default function ProductPage() {
  // Preload critical resources
  preload('/api/product-data', { as: 'fetch' })
  preinit('/styles/product.css', { as: 'style' })

  return <ProductDisplay />
}
```

### View Transitions
```tsx
import { ViewTransition } from 'react'

// Page transitions
function Router({ currentPage }) {
  return (
    <ViewTransition>
      {currentPage === 'home' ? <HomePage /> : <ProductPage />}
    </ViewTransition>
  )
}

// List reordering
"use client"
function TaskList({ tasks, onReorder }) {
  return (
    <ViewTransition>
      <ul>
        {tasks.map(task => (
          <li key={task.id} style={{ viewTransitionName: `task-${task.id}` }}>
            {task.title}
          </li>
        ))}
      </ul>
    </ViewTransition>
  )
}

// Shared element transitions
function ProductCard({ product, isExpanded, onToggle }) {
  return (
    <ViewTransition>
      <div style={{ viewTransitionName: `product-${product.id}` }}>
        <img src={product.image} />
        <h3>{product.name}</h3>
        {isExpanded && <ProductDetails product={product} />}
      </div>
    </ViewTransition>
  )
}
```

### Activity Component - State Preservation
```tsx
import { Activity } from 'react'

// Preserve component state when hiding (better than conditional rendering)
function TabsContainer({ activeTab }: { activeTab: string }) {
  return (
    <div>
      <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>
        <HomeTab /> {/* State preserved when switching tabs */}
      </Activity>
      <Activity mode={activeTab === 'profile' ? 'visible' : 'hidden'}>
        <ProfileTab /> {/* Form inputs, scroll position maintained */}
      </Activity>
      <Activity mode={activeTab === 'settings' ? 'visible' : 'hidden'}>
        <SettingsTab /> {/* Video playback position preserved */}
      </Activity>
    </div>
  )
}

// Pre-render background content at lower priority
function ProductPage({ id, relatedProducts }: { id: string, relatedProducts: any[] }) {
  return (
    <div>
      <ProductDisplay id={id} />

      {/* Pre-render likely next route for instant navigation */}
      <Activity mode="hidden">
        <ProductPage id={relatedProducts[0].id} />
      </Activity>
    </div>
  )
}

// Expandable sidebar with state preservation
function Layout({ isShowingSidebar }: { isShowingSidebar: boolean }) {
  return (
    <div className="flex">
      <Activity mode={isShowingSidebar ? 'visible' : 'hidden'}>
        <Sidebar /> {/* Maintains scroll position, expanded sections */}
      </Activity>
      <MainContent />
    </div>
  )
}

// Hidden components:
// - Use display: none (visually hidden)
// - Re-render at lower priority
// - Effects are cleaned up
// - Internal state is preserved
// Use for components likely to become visible again
```

### Container Queries with Tailwind
```tsx
function ResponsiveCard() {
  return (
    <div className="@container">
      <div className="@sm:flex @md:grid @md:grid-cols-2">
        <div className="@lg:col-span-1">Content</div>
      </div>
    </div>
  )
}
```

## REACT COMPILER PATTERNS

### The Compiler Just Works
```tsx
// OLD: Manual optimization hell
function ProductList({ products, onSelect, filters }) {
  const filteredProducts = useMemo(() =>
    products.filter(p => p.category === filters.category),
    [products, filters.category]
  )

  const handleSelect = useCallback((id) => {
    onSelect(id)
  }, [onSelect])

  return (
    <div>
      {filteredProducts.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onSelect={handleSelect}
        />
      ))}
    </div>
  )
}

// NEW: Just write normal code - compiler optimizes everything
function ProductList({ products, onSelect, filters }) {
  // Compiler automatically memoizes this when needed
  const filteredProducts = products.filter(p => p.category === filters.category)

  // Compiler automatically stabilizes this callback
  const handleSelect = (id) => onSelect(id)

  return (
    <div>
      {filteredProducts.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onSelect={handleSelect}
        />
      ))}
    </div>
  )
}
```

### Rare Cases Requiring Manual Optimization

**Stop and rethink first** - hitting these cases often means you made a mistake somewhere.

```tsx
// External stores (no alternative)
const theme = useSyncExternalStore(store.subscribe, store.getSnapshot)

// Legacy third-party libraries (check for modern alternatives first)
const callback = useCallback(fn, deps) // When library requires stable reference

// Manual equality when compiler is too conservative with deep objects
const processed = useMemo(() => transform(data), [data.id, data.version])

// Proven performance bottleneck (profile first, let compiler try first)
const expensive = useMemo(() => heavyCalculation(data), [data.id])
```

### Compiler Configuration
```tsx
// babel.config.js - Production setup
module.exports = {
  plugins: [
    ['babel-plugin-react-compiler', {
      target: '19',
      compilationMode: 'infer' // Let compiler decide
    }]
  ]
}

// Only use directives for temporary debugging - remove after fixing
function TemporaryDebugComponent() {
  "use no memo" // Find root cause, then remove this

  // Fix the actual issue instead of disabling compilation
  return <ProperlyWrittenComponent />
}
```

### React Compiler ESLint (Canary)
```js
// eslint.config.js - Use official React Compiler ESLint rules
import reactCompiler from 'eslint-plugin-react-compiler'

export default [
  {
    plugins: {
      'react-compiler': reactCompiler
    },
    rules: {
      'react-compiler/react-compiler': 'error'
    }
  }
]

// Catches patterns that break compiler assumptions:
// - Invalid hook usage
// - Unsafe mutations
// - Rules of React violations
// Helps ensure code is compiler-compatible
```

## FORM PATTERNS

### Modern Form Handling
```tsx
async function updateProfileAction(formData: FormData) {
  "use server"
  const profile = ProfileSchema.parse({
    name: formData.get('name'),
    email: formData.get('email')
  })
  await updateProfile(profile)
  revalidatePath('/profile')
}

"use client"
function ProfileForm() {
  const [state, formAction] = useActionState(updateProfileAction, null)

  return (
    <form action={formAction}>
      <input name="name" required />
      <input name="email" type="email" required />
      <SubmitButton />
      {state?.error && <ErrorMessage error={state.error} />}
    </form>
  )
}

function SubmitButton() {
  const { pending } = useFormStatus()
  return (
    <button disabled={pending}>
      {pending ? "Saving..." : "Save Profile"}
    </button>
  )
}
```

## DEPLOYMENT PATTERNS

### Metadata in Components
```tsx
export default async function BlogPost({ slug }: { slug: string }) {
  const post = await getPost(slug)

  return (
    <>
      <title>{post.title}</title>
      <meta name="description" content={post.excerpt} />
      <meta property="og:title" content={post.title} />
      <meta property="og:image" content={post.coverImage} />
      <link rel="canonical" href={`https://blog.com/posts/${slug}`} />

      <article>
        <h1>{post.title}</h1>
        <PostContent content={post.content} />
      </article>
    </>
  )
}
```

