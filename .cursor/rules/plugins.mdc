---
description: Plugin Rules
alwaysApply: false
---
# Plugin Development Rules 

## üöÄ Core Technology Stack (Latest)

### Runtime & Language
- **Node.js 23+** with native ESM require() support enabled by default
- **TypeScript 5.9+** with deferred imports, stable Node.js v20 resolution, and enhanced editor experience
- **ES2025** with JSON modules, Set methods, RegExp.escape(), and duplicate named capturing groups

### Build & Bundling
- **Vite 6+** with Environment API for multi-environment development
- **esbuild** for dependency pre-bundling in development
- **Rollup** for production builds with tree-shaking

### Testing & Quality
- **Vitest 3.1+** with conditional skipping, test scoping, and fixture system
- **TypeScript strict mode** with `noUncheckedSideEffectImports`
- **ESLint 9+** with flat config and typescript-eslint

## üî• Modern JavaScript ES2025 Patterns

### JSON Module Imports
```javascript
import config from './plugin-config.json' with { type: 'json' }
import metadata from './package.json' with { type: 'json' }

export const pluginVersion = metadata.version
```

### Enhanced Set Operations
```javascript
const supportedFeatures = new Set(['syntax-highlighting', 'line-numbers', 'copy-button'])
const requestedFeatures = new Set(['syntax-highlighting', 'tooltips'])

const enabledFeatures = supportedFeatures.intersection(requestedFeatures)
const missingFeatures = requestedFeatures.difference(supportedFeatures)
```

### RegExp Pattern Modifiers & Escape
```javascript
// Case-insensitive pattern matching for specific parts
const codeBlockPattern = /^(?i:```(?<lang>\w+))\s*(?<code>[\s\S]*?)```$/

// Safe regex construction with user input
const escapeUserInput = (input: string) => new RegExp(RegExp.escape(input))
```

### Iterator Helper Methods
```javascript
function* processCodeBlocks(nodes: Iterable<Node>) {
  yield* nodes
    .filter(node => node.type === 'code')
    .map(node => enhanceCodeBlock(node))
    .take(10)
}
```

## ‚ö° TypeScript 5.9+ Modern Patterns

### Import Defer for Performance
```typescript
// Deferred module evaluation - only loads when actually used
import defer * as heavyLibrary from './heavy-computation-library'

const processData = (data: unknown) => {
  if (needsAdvancedProcessing(data)) {
    // Module only executes when this path is taken
    return heavyLibrary.processAdvanced(data)
  }
  return simpleProcess(data)
}
```

### Modern `tsc --init` Configuration
```typescript
// Modern minimal tsconfig.json generated by TypeScript 5.9+
{
  "compilerOptions": {
    "target": "ES2025",
    "module": "node20",  // Stable Node.js v20 resolution
    "moduleResolution": "node20",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

### Plugin Interface with Strict Typing
```typescript
import type { Plugin, Transformer } from 'unified'
import type { Root, Code } from 'mdast'
import type { VFile } from 'vfile'

interface PluginConfig {
  readonly features: ReadonlySet<string>
  readonly strictMode: boolean
  readonly metadata: Record<string, unknown>
}

export const remarkEnhancer: Plugin<[PluginConfig?], Root> = (
  config: PluginConfig = {
    features: new Set(['highlighting']),
    strictMode: true,
    metadata: {}
  }
) => {
  return (tree: Root, file: VFile): Transformer<Root> => {
    // Plugin implementation
    return tree
  }
}
```

### Modern Error Handling with Cause Chains
```typescript
class PluginError extends Error {
  constructor(
    message: string,
    options?: ErrorOptions & {
      pluginName?: string
      context?: Record<string, unknown>
    }
  ) {
    super(message, options)
    this.name = 'PluginError'
  }
}

const processNode = async (node: Code): Promise<Code> => {
  try {
    return await enhanceCode(node)
  } catch (error) {
    throw new PluginError('Code enhancement failed', {
      cause: error,
      pluginName: 'remark-enhancer',
      context: { nodeType: node.type, lang: node.lang }
    })
  }
}
```

### Iterator Helpers with TypeScript
```typescript
const processNodes = (nodes: readonly Node[]): Code[] => {
  return nodes
    .values()
    .filter((node): node is Code => node.type === 'code')
    .map(node => ({ ...node, enhanced: true }))
    .toArray()
}
```

## üõ†Ô∏è Vite 6 Environment API Patterns

### Environment-Aware Plugin Development
```typescript
import type { Plugin } from 'vite'

interface PluginState {
  modules: Map<string, ModuleInfo>
  cache: Map<string, unknown>
}

export const modernVitePlugin = (): Plugin => {
  const stateMap = new Map<Environment, PluginState>()

  return {
    name: 'modern-plugin',
    configureServer(server) {
      // Environment-specific configuration
      server.environments.forEach((env, name) => {
        stateMap.set(env, {
          modules: new Map(),
          cache: new Map()
        })
      })
    },
    buildStart() {
      const state = stateMap.get(this.environment)
      if (!state) {
        throw new Error('Environment state not initialized')
      }
      // Use environment-specific state
    }
  }
}
```

### Multi-Environment Module Resolution
```typescript
export const resolveForEnvironment = (id: string, environment: string) => {
  switch (environment) {
    case 'client':
      return resolveClientModule(id)
    case 'ssr':
      return resolveServerModule(id)
    case 'edge':
      return resolveEdgeModule(id)
    default:
      return resolveDefaultModule(id)
  }
}
```

## üß™ Vitest 3.1+ Modern Testing Patterns

### Conditional Test Skipping
```typescript
import { test, expect } from 'vitest'

test('plugin integration', (context) => {
  context.skip(
    !process.env.INTEGRATION_TESTS,
    'Integration tests disabled'
  )

  const result = processWithPlugin(input)
  expect(result).toBeDefined()
})
```

### Test Fixtures with Modern Syntax
```typescript
import { test, expect } from 'vitest'

const pluginTest = test.extend({
  processor: async ({}, use) => {
    const processor = unified()
      .use(remarkParse)
      .use(remarkEnhancer, { strictMode: true })

    await use(processor)
  },

  sampleMarkdown: `
    # Test Document
    \`\`\`javascript
    console.log('hello')
    \`\`\`
  `
})

pluginTest('enhances code blocks', async ({ processor, sampleMarkdown }) => {
  const result = await processor.process(sampleMarkdown)
  expect(result.toString()).toContain('enhanced')
})
```

### Parameterized Tests with Type Safety
```typescript
test.each([
  { input: '```js\ncode\n```', lang: 'js', expected: true },
  { input: '```ts\ncode\n```', lang: 'ts', expected: true },
  { input: '```\ncode\n```', lang: null, expected: false },
] as const)('processes $lang code blocks', ({ input, expected }) => {
  const result = parseCodeBlock(input)
  expect(result.isValid).toBe(expected)
})
```

## üåü Unified/Remark/MDX Modern Architecture

### ESM-Only Plugin Structure
```typescript
import type { Root, Code, Paragraph, Text } from 'mdast'
import type { Plugin, Transformer } from 'unified'
import { visit, SKIP, CONTINUE } from 'unist-util-visit'

interface EnhancementOptions {
  readonly enableSyntaxHighlighting: boolean
  readonly enableLineNumbers: boolean
  readonly enableCopyButton: boolean
}

export const remarkCodeEnhancer: Plugin<[EnhancementOptions?], Root> = (
  options: EnhancementOptions = {
    enableSyntaxHighlighting: true,
    enableLineNumbers: false,
    enableCopyButton: true
  }
) => {
  return (tree: Root, file: VFile): Transformer<Root> => {
    visit(tree, 'code', (node: Code, index, parent) => {
      if (!parent || index === null) return SKIP

      const enhanced = enhanceCodeNode(node, options)
      parent.children[index] = enhanced

      return CONTINUE
    })

    return tree
  }
}

const enhanceCodeNode = (node: Code, options: EnhancementOptions): Code => {
  const metadata = {
    enhanced: true,
    features: Object.entries(options)
      .filter(([_, enabled]) => enabled)
      .map(([feature]) => feature),
    timestamp: Date.now()
  }

  return {
    ...node,
    data: {
      ...node.data,
      hProperties: {
        ...node.data?.hProperties,
        'data-enhanced': 'true',
        'data-features': metadata.features.join(',')
      }
    }
  }
}
```

### Async Plugin Processing
```typescript
export const remarkAsyncEnhancer: Plugin<[], Root> = () => {
  return async (tree: Root, file: VFile): Promise<Root> => {
    const promises: Promise<void>[] = []

    visit(tree, 'code', (node: Code) => {
      promises.push(processCodeAsync(node))
    })

    await Promise.allSettled(promises)
    return tree
  }
}

const processCodeAsync = async (node: Code): Promise<void> => {
  if (!node.lang) return

  try {
    const highlighted = await highlightCode(node.value, node.lang)
    node.data = { ...node.data, highlighted }
  } catch (error) {
    // Handle error gracefully
    console.warn('Failed to highlight code:', error)
  }
}
```

## üì¶ Modern Package Configuration

### Package.json with ES2025 Support
```json
{
  "type": "module",
  "engines": {
    "node": ">=23.0.0"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./config": {
      "types": "./dist/config.d.ts",
      "import": "./dist/config.js"
    }
  },
  "dependencies": {
    "unified": "^11.0.0",
    "mdast": "^3.0.0",
    "@types/unist": "^3.0.0"
  }
}
```

### TypeScript 5.9+ Configuration
```json
{
  "compilerOptions": {
    "target": "ES2025",
    "module": "node20",
    "moduleResolution": "node20",
    "strict": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noUncheckedSideEffectImports": true,
    "useDefineForClassFields": true,
    "verbatimModuleSyntax": true,
    "allowImportingTsExtensions": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### Vitest Configuration
```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json-summary', 'html'],
      exclude: ['**/*.d.ts', '**/*.test.ts']
    },
    typecheck: {
      tsconfig: './tsconfig.json'
    }
  }
})
```

## üéØ Plugin Lifecycle Management

### Modern Plugin Registration
```typescript
const createPlugin = (options: PluginOptions) => {
  const plugin = {
    name: 'modern-plugin',
    version: '1.0.0',

    initialize: async () => {
      // Async initialization
      await loadConfiguration()
    },

    process: (content: string) => {
      return enhanceContent(content, options)
    },

    cleanup: async () => {
      // Cleanup resources
      await closeConnections()
    }
  }

  return plugin
}
```

### Performance Monitoring
```typescript
const withPerformanceTracking = <T>(fn: () => T, name: string): T => {
  const start = performance.now()
  try {
    const result = fn()
    const duration = performance.now() - start
    console.debug(`${name} completed in ${duration.toFixed(2)}ms`)
    return result
  } catch (error) {
    const duration = performance.now() - start
    console.error(`${name} failed after ${duration.toFixed(2)}ms:`, error)
    throw error
  }
}
```