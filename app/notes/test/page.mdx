# Bellman-Ford Variants and Implementation

## Resizable Table of Contents


## Variant 1: Classical Bellman-Ford

> **Definition**: Given a directed graph $G = (V, E)$, edge weights $w: E \to \mathbb{R}$, and source node $s$, compute $\delta(s, v)$ for all $v \in V$, or detect a negative-weight cycle reachable from $s$.

This in-place Bellman-Ford:

1. Initializes distances.
2. **Relaxes all edges** $|V|-1$ times to compute shortest paths.
3. Performs a **$V$th pass**:

   1. If any edge is still relaxable, a negative-weight cycle exists.
   2. Otherwise, $d(s, v) = \delta(s, v)$ for all $v \in V$.

```python file=examples/code/bellman-ford.py#func:bellman_ford_classic stripDocstring
```

* **Time**: $O(|V|\times|E|)$
* **Space**: $O(|V|)$

---

## Variant 2: DAG-Relaxation with Graph Duplication (more powerful)

> **Definition**: Let $\delta_k(s, v)$ be the shortest path cost from $s$ to $v$ using $\le k$ edges. Build a layered DAG $G'$ with levels $k = 0,1,\dots,|V|$, duplicating each vertex across layers. Relaxing edges from layer $k-1$ to $k$ tracks $\delta_k(s,v)$, and if
>
> $$
> \delta_{|V|}(s,v) < \delta_{|V|-1}(s,v)
> $$
>
> then $v$ is a negative-cycle witness.

```python file=examples/code/bellman-ford.py#func:bellman_ford_layered_dag stripDocstring
```

* **Time**: $O(|V|\times|E|)$
* **Space**: $O(|V|\times|E|)$

### Deep Dive: Mapping `bellman_ford_layered_dag` to the Algorithm

Below are the five conceptual steps of the layered-DAG variant, with the exact code snippets that implement each step.

1. **Initialize $\delta_0$ (distance 0 at `source`, $\infty$ elsewhere)**

   ```python
   d = {v: float("inf") for v in vertices}
   d[source], V = 0, len(vertices)
   ```

   * Sets

   $$
   d[v] = \delta_0(s, v) = \begin{cases}0,&v=s\\\infty,&\text{otherwise}\end{cases}
   $$

2. **Layered relaxation: compute $\delta_1,\dots,\delta_V$**

   ```python
   for k in range(V):            # k = 0…V-1
       d_k = {**d}               # snapshot of \delta_k
       for u, v, w in edges:
           if d[u] + w < d_k[v]:
               d_k[v] = d[u] + w  # build \delta_{k+1}(s,v)
       d = d_k                   # now holds \delta_{k+1}
   ```

   * After iteration $k$:

   $$
   d[v] = \delta_{k+1}(s,v)
   $$

3. **Detect direct witnesses ($\delta_V < \delta_{V-1}$)**

   ```python
   witnesses = {
       v
       for u, v, w in edges
       if d[u] + w < d[v]
   }
   if not witnesses:
       return d
   ```

   * A vertex $v$ with

   $$
   \delta_V(s,v) < \delta_{V-1}(s,v)
   $$

   is a negative-cycle witness.

4. **Build successor list for propagation**

   ```python
   adj = defaultdict(list)
   for u, v, _ in edges:
       adj[u].append(v)
   ```

   * `adj[u]` holds all $v$ such that $(u\to v) \in E$.

5. **Flood-fill $-\infty$ from each witness**

   ```python
   stack = list(witnesses)
   reachable = set(witnesses)

   while stack:
       u = stack.pop()
       d[u] = float("-inf")
       for v in adj[u]:
           if v not in reachable:
               reachable.add(v)
               stack.append(v)
   return d
   ```

   * Marks each witness and any vertex reachable from it with $-\infty$.

---

## Comparison

| Feature                   | Classical BF | Layered-DAG Duplication |
| ------------------------- | ------------ | ----------------------- |
| Negative-cycle detection  | ✅ Yes        | ✅ Yes                   |
| Recover cycle             | ❌ No         | ✅ Yes                   |
| Space complexity          | $O(|V|)$      | $O(|V| \cdot |E|)$        |
| Time complexity           | $O(|V| \cdot |E|)$ | $O(|V| \cdot |E|)$ |
| Tracks $\delta_k(s,v)$    | ❌ No         | ✅ Yes                   |
| Early termination         | ✅ Possible   | ❌ No                    |
| Implementation complexity | ✅ Simple     | ❌ More complex          |

---

## Problems

### 1. Cheapest Flight Within K Stops

**LeetCode 787**: Cheapest Flights Within K Stops
Find the cheapest flight from `src` to `dst` using at most $k$ stops.

```python file=examples/code/bellman-ford.py#func:findCheapestPrice stripDocstring
```

> **Key**: relax edges exactly $k+1$ times to enforce at most $k$ stops.
> **Time**: $O(k \cdot E)$

### 2. Path with Maximum Probability

**LeetCode 1514**: Path with Maximum Probability
Find the path in a graph that maximizes product of edge probabilities.

```python file=examples/code/bellman-ford.py#func:maxProbability stripDocstring
```
