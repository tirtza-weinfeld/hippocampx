## Resizable Table of Contents

Binary search is a powerful algorithm for searching within data that has a **monotonic property** (e.g., a sorted array). It works by repeatedly halving the search space, achieving exceptional efficiency. Its patterns can be applied to a wide range of problems beyond simple lookups.

-----
## simple
Binary search is a highly efficient algorithm for finding an item in a **sorted** list. It works by repeatedly dividing the search interval in half. Its time complexity is $O(\\log n)$, making it significantly faster than a linear search ($O(n)$) for large lists.

The core idea is to compare the target value with the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated, and the search continues on the remaining half.

-----

### `bisect_left`: Finding the Leftmost Insertion Point

`bisect_left` determines the index at which a target `x` should be inserted into a sorted list `a` to maintain order. It finds the **first** position `i` where `a[i] >= x`.

```python
def simple_bisect_left(a, x):
    """Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e < x, and all e in
    a[i:] have e >= x.  So if x already appears in the list, a.insert(i, x) will
    insert just before the leftmost x already there.

    """
    lo, hi = 0, len(a)
    while lo < hi:
        mid = (lo + hi) // 2
        # If the middle element is less than the target, the insertion point
        # must be in the right half.
        if a[mid] < x:
            lo = mid + 1
        # If the middle element is >= target, the insertion point could be `mid`
        # or to its left. We shrink the search space to the left half, including mid.
        else:
            hi = mid
    return lo
```

**Key Logic**: When `a[mid]` is greater than or equal to `x`, we set `hi = mid`. This ensures we keep considering the `mid` index as a potential answer and forces the search to converge on the leftmost possible index.

-----

### `bisect_right`: Finding the Rightmost Insertion Point

`bisect_right` is similar but finds the insertion point to the **right** of any existing entries of `x`. It finds the first position `i` where `a[i] > x`.

```python
def simple_bisect_right(a, x):
    """Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e <= x, and all e in
    a[i:] have e > x.  So if x already appears in the list, a.insert(i, x) will
    insert just after the rightmost x already there.

    """
    lo, hi = 0, len(a)
    while lo < hi:
        mid = (lo + hi) // 2
        # If the target is less than the middle element, the insertion point could be
        # `mid` or to its left. Shrink search space to the left half.
        if x < a[mid]:
            hi = mid
        # If the target is >= middle element, the insertion point must be
        # to the right of `mid`.
        else:
            lo = mid + 1
    return lo
```

**Key Logic**: When `a[mid]` is less than or equal to `x`, we set `lo = mid + 1`. This effectively pushes the search past all elements equal to `x`, ensuring the final index is just after the rightmost occurrence.

-----

### Application: Finding a Target's Range

We can combine `bisect_left` and `bisect_right` to find the starting and ending indices of a target in a sorted list with duplicates. Python's `bisect` module provides optimized versions of these functions.

```python
from bisect import bisect_left, bisect_right

def searchRange(nums: list[int], target: int) -> list[int]:
    # Find the index of the first element >= target.
    start = bisect_left(nums, target)
    
    # Check if the target was actually found. `start` must be a valid index,
    # and the element at that index must be the target.
    if start < len(nums) and nums[start] == target:
        # If the start is valid, the target exists.
        # Find the insertion point after all occurrences of the target.
        # The last occurrence is at the index just before this insertion point.
        end = bisect_right(nums, target) - 1
        return [start, end]
        
    # Target was not found in the list.
    return [-1, -1]
```

**Example**: For `nums = [5, 7, 7, 8, 8, 10]` and `target = 8`:

1.  `bisect_left(nums, 8)` returns `3`. `nums[3]` is `8`, so the target exists.
2.  `bisect_right(nums, 8)` returns `5` (the index where a new `8` would be inserted).
3.  The last occurrence is at index `5 - 1 = 4`.
4.  The function returns `[3, 4]`.

## Patters
### Pattern 1: Search on Index

This is the classic binary search, used to find an element's position in a sorted collection.

**Problem**: Search Insert Position (LeetCode 35)

  * **Definition**: Given a sorted array of distinct integers and a target value, find the index of the target. If the target is not found, return the index where it would be inserted to maintain order.


```python
def searchInsert(nums: list[int], target: int) -> int:
    low, high = 0, len(nums) - 1
    while low <= high:
        mid = low + (high - low) // 2
        if nums[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return low
```

**Tip** ðŸ’¡: This is a search on an array's **index**. The key is that after the loop terminates (`low > high`), the `low` pointer will always indicate the first position that is greater than or equal to the target, which is the correct insertion index.

  * **Time Complexity**: $O(\\log n)$

-----

### Pattern 2: Search on a Modified Condition

This pattern applies when the data isn't strictly sorted but has a discoverable monotonic property, such as in a rotated array. The search condition is adapted to exploit this property.

**Problem**: Find Minimum in Rotated Sorted Array (LeetCode 153)

  * **Definition**: Given an array of unique elements, sorted and then rotated at an unknown pivot, find its minimum value. Example: `[4, 5, 6, 7, 0, 1, 2]` was `[0, 1, 2, 4, 5, 6, 7]`.


```python
def findMin(nums: list[int]) -> int:
    low, high = 0, len(nums) - 1
    while low < high:
        mid = low + (high - low) // 2
        if nums[mid] > nums[high]:
            # The minimum must be in the unsorted right part.
            low = mid + 1
        else:
            # The minimum is either mid or in the sorted left part.
            high = mid
    return nums[low]
```

**Tip** ðŸ’¡: Instead of comparing `nums[mid]` to a target, you compare it to an endpoint (like `nums[high]`) to determine which half of the array contains the rotation point. This allows you to discard the cleanly sorted half in each step and zero in on the "break" where the minimum element lies.

  * **Time Complexity**: $O(\\log n)$

-----

### Pattern 3: Search on the Answer Space

This advanced pattern solves optimization problems. Instead of searching over an array, you search within a range of possible **answers** to find the optimal one that satisfies certain constraints.

**Problem**: Koko Eating Bananas (LeetCode 875)

  * **Definition**: Given `n` piles of bananas and `h` hours, find the minimum integer eating speed `k` (bananas/hour) to finish all bananas within `h` hours.


```python
import math

def minEatingSpeed(piles: list[int], h: int) -> int:
    # The answer must be between 1 and the largest pile.
    low, high = 1, max(piles)
    min_speed = high

    while low <= high:
        k = low + (high - low) // 2
        # `k` cannot be zero, handle potential division by zero if low can be 0.
        if k == 0:
            low = 1
            continue
        
        hours_taken = sum(math.ceil(p / k) for p in piles)

        if hours_taken <= h:
            # This speed works; try for an even slower one.
            min_speed = k
            high = k - 1
        else:
            # This speed is too slow; must go faster.
            low = k + 1

    return min_speed
```

**Tip** ðŸ’¡: Here, the binary search is on the **answer space** (the range of possible speeds `k`). For any given speed `k`, you can check if it's a valid solution (`True` or `False`). This creates a conceptual boolean array like `[F, F, ..., T, T, T]`, and your goal is to find the first `True`, which corresponds to the minimum valid speed.

  * **Time Complexity**: $O(n \\log m)$, where $n$ is the number of piles and $m$ is the range of possible answers (e.g., the max pile size).

