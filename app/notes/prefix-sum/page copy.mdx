Of course. Here is the complete document with a more detailed introduction and extensive inline comments in each code block to clarify the logic.

# Prefix Sums: Trip Segments & Highway Markers

## The Power of a Head Start

Imagine you're on a long highway road trip. You pass mile marker 75 and want to know exactly how far you'll drive to get to the exit at mile marker 180. You wouldn't reset your car's trip odometer at marker 75; you'd do a simple calculation: `180 - 75 = 105` miles.

The mile markers are a perfect real-world example of a pre-calculated system. Each marker gives the total distance from the start of the highway, allowing you to find the distance between *any* two points with one subtraction. This is the core idea behind **prefix sums**.

For an array of numbers `nums`, its prefix sum array (let's call it `prefix`) stores the running total at each position. `prefix[i]` is the sum of all elements from `nums[0]` through `nums[i]`.

  * **Original Segments:** `[120, -30, 200, -50, 150]`
  * **Prefix Sum Odometer:** `[120, 90, 290, 240, 390]`

The magic trick is that the sum of any "segment" (a subarray) from index `i` to `j` is simply `prefix[j] - prefix[i-1]`. This allows us to answer any range query in constant $O(1)$ time after an initial $O(n)$ pass to build the prefix sum array.

By combining this technique with a hash map to remember past sums and their locations, we can solve a huge range of otherwise complex problems with surprising efficiency. Let's see it in action, casting eight classic challenges in our road-trip world.

-----

## 1 Longest Streak Covering Exactly k Kilometers

**[LeetCode 325: Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/)**

*You need a sightseeing record: find the **maximum number of consecutive days** whose net distance exactly totals **k km**.*

```python
class Solution:
    def maxSubArrayLen(self, nums: list[int], k: int) -> int:
        
        # Map to store the first index where a prefix sum is seen.
        # Initialize with {0: -1} to handle subarrays that start from index 0.
        sum_index = {0: -1}
        curr_sum = 0
        max_length = 0
        
        for i, num in enumerate(nums):
            # Update the running total (our current odometer reading).
            curr_sum += num
            
            # We are looking for a subarray ending at i that sums to k.
            # This means curr_sum - previous_sum = k.
            # So, we search for previous_sum = curr_sum - k.
            if (target := curr_sum - k) in sum_index:
                # If found, calculate the length from that point to the current index.
                max_length = max(max_length, i - sum_index[target])
            
            # Only store the first time we see a prefix sum.
            # This ensures we always get the longest possible subarray.
            if curr_sum not in sum_index:
                sum_index[curr_sum] = i
        
        return max_length
```

-----

## 2 Count of Streaks Covering k Kilometers

**[LeetCode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)**

*How many **distinct** consecutive-day intervals sum to exactly **k km**?*

```python
from collections import defaultdict

def subarraySum(self, nums: list[int], k: int) -> int:

    # Map to store the frequency of each prefix sum.
    # Initialize with {0: 1} for subarrays that start from index 0.
    sum_freq = defaultdict(int, {0: 1})
    curr_sum = 0
    count = 0

    for num in nums:
        # Update the running total.
        curr_sum += num
        
        # Look for a previous sum of `curr_sum - k`.
        # The number of times we've seen it is the number of new subarrays found.
        count += sum_freq[curr_sum - k]
        
        # Increment the frequency of the current prefix sum.
        sum_freq[curr_sum] += 1
        
    return count
```

-----

## 3 Longest Balanced Forward/Backward Day-Count

**[LeetCode 525: Contiguous Array](https://leetcode.com/problems/contiguous-array/)**

*To balance your driving, find the longest stretch of days with an **equal number** of forward (+1) and backward (-1) segments. This is equivalent to finding the longest subarray that sums to zero after converting driving days to +/- 1.*

```python
class Solution:
    def findMaxLength(self, nums: list[int]) -> int:
        # Map to store the first index where a "count" (our prefix sum) is seen.
        # Initialize with {0: -1} to handle cases where the balanced array starts at index 0.
        count_map = {0: -1}
        max_len = 0
        count = 0
        
        for i, num in enumerate(nums):
            # Treat 1s as +1 and 0s as -1 to find a zero-sum subarray.
            count += 1 if num == 1 else -1
            
            # If we've seen this count before, the subarray between the two occurrences is balanced.
            if count in count_map:
                max_len = max(max_len, i - count_map[count])
            else:
                # Store the first time we see this count.
                count_map[count] = i
                
        return max_len
```

-----

## 4 Detecting a ≥2-Day Multiple-of-k Windfall

**[LeetCode 523: Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/)**

*Did you ever cover a total distance that’s an exact **multiple of k km** over at least 2 consecutive days?*

```python
class Solution:
    def checkSubarraySum(self, nums: list[int], k: int) -> bool:

        # Map to store the first index of a given prefix sum remainder (mod k).
        # (A - B) % k == 0  if and only if  A % k == B % k.
        # Initialize with {0: -1} to handle subarrays starting at index 0.
        mod_index = {0: -1}
        prefix_mod = 0

        for i, num in enumerate(nums):
            # Calculate the running prefix sum modulo k.
            prefix_mod = (prefix_mod + num) % k

            # If we've seen this remainder before...
            if prefix_mod in mod_index:
                # ...check if the subarray has at least 2 elements.
                if i - mod_index[prefix_mod] > 1:
                    return True
            else:
                # Otherwise, store the first time we see this remainder.
                mod_index[prefix_mod] = i
                
        return False
```

-----

## 5 Counting All Spans Divisible by k

**[LeetCode 974: Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/)**

*How many consecutive-day intervals have a total distance that is an exact multiple of k?*

```python
from collections import defaultdict

def subarraysDivByK(self, nums: list[int], k: int) -> int:

    # Map to store the frequency of each prefix sum remainder.
    # Initialize with {0: 1} to count subarrays starting at index 0.
    mod_freq = defaultdict(int, {0: 1})
    curr_mod = 0
    count = 0

    for num in nums:
        # Update the running prefix sum remainder.
        curr_mod = (curr_mod + num) % k
        
        # If we've seen this remainder `m` times before, it means we can form
        # `m` new subarrays ending at the current position that are divisible by k.
        count += mod_freq[curr_mod]
        
        # Increment the frequency for the current remainder.
        mod_freq[curr_mod] += 1
        
    return count
```

-----

## 6 Minimal Skip to Align on k

**[LeetCode 1590: Make Sum Divisible by P](https://leetcode.com/problems/make-sum-divisible-by-p/)**

*If your **total trip distance** isn’t divisible by k, what’s the **shortest consecutive segment** to skip so that the remaining distance is exactly a multiple of k?*

```python
class Solution:
    def minSubarray(self, nums: list[int], k: int) -> int:

        # The subarray we remove must have a sum remainder equal to the total remainder.
        total_mod = sum(nums) % k
        if total_mod == 0:
            return 0 # Nothing to remove.

        # Map: remainder -> last seen index.
        mod_index = {0: -1}
        curr_mod = 0
        min_len = len(nums)

        for i, num in enumerate(nums):
            curr_mod = (curr_mod + num) % k
            
            # We need to find a previous prefix_sum `P_i` such that (curr_mod - P_i) % k == total_mod.
            # Rearranging, we look for a `P_i` where `P_i % k == (curr_mod - total_mod) % k`.
            need = (curr_mod - total_mod + k) % k
            
            if need in mod_index:
                min_len = min(min_len, i - mod_index[need])
                
            mod_index[curr_mod] = i
            
        return min_len if min_len < len(nums) else -1
```

-----

## 7 Batch Calibration Corrections (Difference Array)

**[LeetCode 370: Range Addition](https://leetcode.com/problems/range-addition/)**

*You start with a trip log of `length` days, all reading 0. You are given a list of `updates`, where each `[start, end, change]` requires adding a value to all days in that range. What is the final state of the trip log after all adjustments?*

```python
class Solution:
    def getModifiedArray(self, length: int, updates: list[list[int]]) -> list[int]:
        
        # This is a "difference" or "delta" array. It stores only changes.
        result = [0] * length
        
        for start, end, val in updates:
            # Mark the start of the range with a positive change.
            result[start] += val
            # Mark the point just after the end with a negative change to cancel it out.
            if end + 1 < length:
                result[end + 1] -= val
        
        # Now, take the prefix sum of the difference array to get the final values.
        # The effect of `val` will carry forward from `start` and be cancelled after `end`.
        for i in range(1, length):
            result[i] += result[i-1]
            
        return result
```

  * **Time Complexity:** $O(n + k)$, where $k$ = `len(updates)`
  * **Space Complexity:** $O(n)$

-----

## 8 Counting Valid Starting Odometer Readings

**[LeetCode 2145: Count the Hidden Sequences](https://leetcode.com/problems/count-the-hidden-sequences/)**

*You have an array of daily `differences` in your odometer readings but have lost the initial reading. Knowing every reading must stay within `[lower, upper]`, how many possible initial integer values could there have been?*

```python
class Solution:
    def numberOfArrays(self, differences: list[int], lower: int, upper: int) -> int:
        
        # Find the journey's path relative to a starting point of 0.
        prefix_sum = 0
        min_sum = 0
        max_sum = 0
        
        for diff in differences:
            prefix_sum += diff
            # Track the lowest and highest points of the relative journey.
            min_sum = min(min_sum, prefix_sum)
            max_sum = max(max_sum, prefix_sum)
            
        # Let H be the unknown start. The sequence is [H + min_sum, H + max_sum].
        # We need: H + min_sum >= lower AND H + max_sum <= upper.
        # This gives us a valid range for H: [lower - min_sum, upper - max_sum].
        # The number of integers in this range is the answer.
        valid_start_range = (upper - max_sum) - (lower - min_sum) + 1
        return max(0, valid_start_range)
```

  * **Time Complexity:** $O(n)$
  * **Space Complexity:** $O(1)$