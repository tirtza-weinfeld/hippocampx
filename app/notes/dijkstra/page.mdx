
import TransitMapAnimation from '@/components/notes/trip';

# Dijkstra's Algorithm

## Resizable table of contents



## Description

Given a directed or undirected graph with **non-negative edge weights**  
($\forall e \in E,\ w(e) \geq 0$), and a source vertex $s$,  
compute the **shortest path distance** to every vertex:  
$\delta(s, v),\ \forall v \in V$.

---

### Code Snippet (Binary Heap)

```python file=examples/code/dijkstra.py#func:dijkstra stripDocstring
```

---

### Runtime Analysis

Let $|V|$ be the number of vertices and $|E|$ the number of edges.
Let $T_i$, $T_e$, and $T_d$ be the costs of insert, extract-min, and decrease-key:

$$
T_{\text{Dijkstra}} = O(|V| \cdot T_i + |V| \cdot T_e + |E| \cdot T_d)
$$

| Priority Queue | Build    | Extract-Min   | Decrease-Key  | Total Time           |
| -------------- | -------- | ------------- | ------------- | -------------------- |
| Array          | $O(V)$ | $O(V)$      | $O(1)$      | $O(V^2 + E)$       |
| Binary Heap    | $O(V)$ | $O(\log V)$ | $O(\log V)$ | **$O((V + E)\log V)$** |
| Fibonacci Heap | $O(V)$ | $O(\log V)$ | $O(1)_a$  | $O(V \log V + E)$  |


> In practice, **binary heaps** are preferred: they offer near-optimal performance with simple, efficient implementations.
> Fibonacci heaps achieve better asymptotic bounds but are rarely used due to large constant factors and implementation complexity.



---

### Example: Your Personal Transit Map

You're planning the fastest routes from **Home** to various destinations:
`Work`, the `Gym`, and the nearby transit `Stations`.

**The Map:**
`Home → Station A: 5`
`Home → Station B: 12`
`Station A → Gym: 10`
`Station B → Gym: 2`
`Station B → Work: 20`

<TransitMapAnimation />




-----

## Problems



### 1\. The Classic Broadcast: Network Delay Time
[743. Network Delay Time](https://leetcode.com/problems/network-delay-time/)


*Given `n` nodes labeled `1` through `n` 
and directed travel times between them, find the minimum time for a signal starting at node `k` 
to reach *all* nodes. If impossible, return -1*



```python file=examples/code/dijkstra.py#func:networkDelayTime stripDocstring stripDocstring 
```

> [!note:collapse]
> This is Dijkstra's canonical use case: finding the shortest time for a signal to reach every node from a single source.
>
> This is a direct application where **"distance" is time**. The algorithm finds the shortest time from `k` to every other node. The final answer is the **maximum** of these shortest times, which represents the moment the *last* node receives the signal.
 
**Time Complexity:** **$O(E \log V)$**

