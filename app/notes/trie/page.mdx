# Trie (Prefix Tree)

## Resizable table of contents

## Problems


### 1. Implement Trie (Prefix Tree)

*Design a Trie with `insert`, `search`, and `startsWith` methods. Support only lowercase English letters.*

[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)

```python file=backend/algorithms/trie.py#class:Trie
```

> [!insight:collapse] *One Node per Character*
>
> A Trie is a tree where each node maps a character to its child. Every word is stored by following or creating one node per character. A `is_end` flag marks the end of a valid word. Prefix queries traverse as far as possible; search only succeeds if `is_end` is true at the last node.

> [!timecomplexity:collapse] `$O(L)$` ,where `$L$` is the length of the word. 
>
> All operations — insert, search, and startsWith — take time proportional to the word's length.


---

### 2. Design Add and Search Words Data Structure

*Implement a Trie that supports adding words and searching with `.` as a wildcard matching any single letter.*
*[19:]There will be at most 2 dots in word for search queries.*

[211. Design Add and Search Words](https://leetcode.com/problems/design-add-and-search-words-data-structure/)

```python file=backend/algorithms/trie.py#class:WordDictionary
```

> [!insight:collapse] *DFS on Wildcards `.`*
>
> `addWord` is identical to `insert` in a normal Trie. The key difference is in `search`: when encountering a `.`, explore all children recursively. This naturally requires DFS. A match is valid only if any path leads to a terminal `is_end = True`.

> [!timecomplexity:collapse]
>
> * `addWord(word)`: `$O(n)$`, where `$n$` = word length
> * `search(word)`: `$O(26ᵏ · n)$`, where `$k$` = number of wildcards `.` in the query
>    * If `$k = 0$` ⇒ `$O(n)$`
>    * Worst‐case `$k = n$` ⇒ `$O(26^n · n)$`
>    * Since `$k ≤ 2$` by problem constraints, this is effectively `$O(n)$`

---

### 3. Replace Words

*Given a dictionary of root words, replace all words in a sentence with the shortest root that is a prefix of the word.*

[648. Replace Words](https://leetcode.com/problems/replace-words/)

```python file=backend/algorithms/trie.py#func:replaceWords
```

> [!insight:collapse] *Shortest Prefix Wins*
>
> Build a Trie from all root words. For each word in the sentence, scan its prefix in the Trie. Stop as soon as you hit a node with `is_end = True` — that’s the shortest valid replacement.

> \[!timecomplexity\:collapse] `O(D + S)` where `$D$` = total characters in dictionary, `$S$` = total characters in sentence.
>
> * Build trie: `$O(\sum_{r\in\text{dictionary}}|r|)$` — you walk each root’s characters, stopping early if you hit a terminal.
> * Search & replace: `$O(\sum_{w\in\text{sentence}}|w|)$` — for each word, you scan until you hit `is_end = True` or exhaust the word.
>
> Overall: `$O(\sum_{r\in\text{dictionary}}|r|\;+\;\sum_{w\in\text{sentence}}|w|)$`

---

### 4. Word Search II

*Find all words in a 2D board that exist in a given word list.*

[212. Word Search II](https://leetcode.com/problems/word-search-ii/)

```python file=backend/algorithms/trie.py#func:findWords
```

> [!insight:collapse] Prefix rails
>
> - The trie lays down “prefix rails” across the grid: you only move where a rail continues; off‑rail steps end instantly.
> - A terminal is a station: record the word once, close that spur, and drop empty rails as you pass. In one walk, a cell is used at most once.

> [!example:collapse] Quick example
>
> Board:
>
> ```
> o a a n
> e t a e
> i h k r
> i f l v
> ```
>
> Words: `oath`, `eat`, `rain`
>
> - Rails start at root letters `o`, `e`, `r`.
> - From `o`: o→a→t→h forms “oath” (station) → collect once, close that spur.
> - From `e`: e→a→t forms “eat” → collect once, close that spur.
> - From `r`: `ra` has no continuing rail nearby → that walk ends immediately.

> [!timecomplexity\:collapse] `$O(m n \cdot 4^{L})$`
>
> - **Symbols:** `$m\times n$` board, `$W=\sum_{w\in\text{dict}}|w|$`, `$L=\max|w|$`.
> - **Build trie:** `$O(W)$`.
> - **DFS (worst case):** first step ≤ 4 choices, then ≤ 3 per step ⇒ `$O(m n \cdot 4 \cdot 3^{L-1})$`. Coarse bound: `$O(m n \cdot 4^{L})$`.
> - **Space:** trie `$O(W)$`; recursion/visited path `$O(L)$`.



