# Dynamic Programming(DP)

## Resizable Table Of contents


> Dynamic Programming (DP) is an algorithmic technique for **optimization** or **counting** problems that exibit the following properties:
> - ~ **Optimal substructure**: the best solution for the whole problem is formed from optimal solutions to its subproblems.
> - ~ **Overlapping subproblems**: identical subproblems recur multiple times, allowing reuse of results to avoid exponential recomputation.


> DP can be implemented in two equivalent ways:
> 
> - ~ **Top-down (memoization)**: start from the **root state** (the full problem), recursively compute only needed subproblems, cache results, and implicitly traverse the subproblem DAG in **reverse topological order**.
> - ~ **Bottom-up (tabulation)**: explicitly define a **topological order** over all states (e.g., by increasing substring length or decreasing index) and iteratively fill a table from base cases up to the root—eliminating recursion overhead and directly matching the memoized logic.
> 
> Both methods yield identical results. Top-down is **straightforward to write**, while bottom-up is typically **more efficient in practice** and easy to derive by unrolling memoized recursion in topological order.


---

## Examples


### 1. Partition Equal Subset Sum

*Given an integer array `nums`, determine if you can partition it into two subsets with an equal sum.*

[416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)

```python file=problems/416-partition-equal-subset-sum/solution.py
```

> [\!Intuition:collapse]
>
> **Paradigm**: This is the **0/1 Knapsack** decision problem in disguise.
>
> **Insight**: The problem transforms from partitioning an array into a simpler question: can a subset of "items" (`nums`) perfectly fill a "knapsack" with capacity `total_sum / 2`? Each item's weight is equal to its value.

> [\!timecomplexity:collapse] **$O(N \cdot \text{Sum})$**
>
> where `N` is the number of elements and `Sum` is the target subset sum.

-----

### 2. Coin Change II

*Given an array of coin denominations and a total amount, return the number of combinations of coins that make up that amount. You can assume an infinite number of each coin.*

[518. Coin Change II](https://leetcode.com/problems/coin-change-ii/)

```python file=problems/518-coin-change-ii/solution.py
```

> [\!Intuition:collapse]
>
> **Paradigm**: This is a classic **Unbounded Knapsack** counting problem.
>
> **Insight**: To count *combinations* without overcounting *permutations* (`1+2` vs `2+1`), the DP imposes a strict processing order on the coins. This ensures that combinations are always built in the same sequence (e.g., using smaller denomination coins before larger ones), elegantly eliminating duplicates.

> [\!timecomplexity:collapse] **$O(n \cdot \text{amount})$**
>
> where `n` is the number of coins and `amount` is the target.


-----

### 3. Solving Questions With Brainpower

*Given a list of `questions` where `questions[i] = [pointsᵢ, brainpowerᵢ]`, you process from i=0 and at each i choose to either solve (gain `pointsᵢ` and jump `brainpowerᵢ + 1`) or skip (move to `i + 1`). Return the maximum points achievable.*

[2140. Solving Questions With Brainpower](https://leetcode.com/problems/solving-questions-with-brainpower/)

```python file=problems/2140-solving-questions-with-brainpower/solution.py
```

> [\!Intuition:collapse]
>
> **Paradigm**: This is a **longest path problem on a Directed Acyclic Graph (DAG)**.
>
> **Insight**: The maximum score obtainable *from* any question `i` is a fixed value, regardless of past choices. This allows a backward pass from the end of the exam (where the future score is 0), calculating the optimal future score for each question by simply choosing the `max()` of two pre-computed paths: the one from "solving" vs. the one from "skipping".

> [\!timecomplexity:collapse] **$O(n)$**
>
> where `n` is the number of questions.



----
### See Also
* [Stone Game IV](./games#21-stone-game-iv)
* [Stone Game III](./games#22-stone-game-iii)


---





