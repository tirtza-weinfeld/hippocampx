# Prefix Sums: Trip Segments & Highway Markers

## Resizable Table of Contents
You’re on a solo road trip, and each day you note your **net distance** traveled—sometimes you backtrack a little (negative), other days you make big leaps forward (positive):

```python
# segments[i] = net kilometers driven on Day i+1
segments = [120, -30, 200, -50, 150]

# After one pass, build your odometer readings (prefix sums):
# odometer[i] = total km from the start through Day i+1
odometer = [120,  90, 290, 240, 390]
```

Like highway mile markers, your `odometer` array tells you **exactly** how far you’ve gone from Day 1 to any given day. To find how many kilometers you covered between **Day i…j inclusive**, you simply subtract:

```
odometer[j] – (odometer[i–1] if i>0 else 0)
```

That one subtraction answers **any** “range distance” question in **O(1)** after an **O(n)** setup. With that in hand, let’s tackle eight classic subarray challenges—each cast in our road-trip world.

---

## 1 Longest Streak Covering Exactly k Kilometers

**LeetCode 325: Maximum Size Subarray Sum Equals k**
*You need a sightseeing record: find the **maximum number of consecutive days** whose net distance exactly totals **k km**.*

```python
class Solution:
    def maxSubArrayLen(self, nums: list[int], k: int) -> int:
        
        sum_index = {0: -1}  # odometer reading → earliest day index
        max_length = curr_sum = 0
        
        for i, num in enumerate(nums):
            curr_sum += num  # update odometer reading
            
            # if we've seen (curr_sum - k) on day d,
            # then days d+1…i cover exactly k km
            if (curr_sum - k) in sum_index:
                max_length = max(max_length,
                                 i - sum_index[curr_sum - k])
            
            # record the first time we hit this odometer reading
            if curr_sum not in sum_index:
                sum_index[curr_sum] = i
        
        return max_length
```

---

## 2 Count of Streaks Covering k Kilometers

**LeetCode 560: Subarray Sum Equals K**
*How many **distinct** consecutive-day intervals sum to exactly **k km**?*

```python
def subarraySum(self, nums: list[int], k: int) -> int:
    count = curr_sum = 0
    sum_freq = defaultdict(int, {0: 1})
    for num in nums:
        curr_sum += num
        count += sum_freq[curr_sum - k]
        sum_freq[curr_sum] += 1
    return count
```

---



## 3 Finding the Longest Balanced Forward/Backward Day-Count

**LeetCode 525: Contiguous Array**

**Problem Description:**
Given an array of daily driving segments (positive for forward, negative for backtrack), find the **maximum length** of a contiguous subarray with an **equal number of forward days and backward days**.

**Road-Trip Scenario:**
Convert each day to `+1` if you drove forward, or `–1` if you backtracked:

```python
segments = [120, -30, 200, -50, 150]
# mapped → [ +1, -1, +1, -1, +1 ]
```

A subarray summing to **0** **means** you had exactly the **same count** of forward and backward days during that stretch—your driving days were perfectly balanced.

**Code Snippet:**

```python
class Solution:
    def findMaxLength(self, nums: list[int]) -> int:
        nums = [1 if num > 0 else -1 for num in nums]
        return self.maxSubArrayLen(nums, 0) 
```

---

## 4 Detecting a ≥2-Day Multiple-of-k Windfall

**LeetCode 523: Continuous Subarray Sum**
*Did you ever cover a total distance that’s an exact **multiple of k km** over at least 2 consecutive days?*

```python
class Solution:
    def checkSubarraySum(self, nums: list[int], k: int) -> bool:
        prefix_mod = 0
        mod_seen = {0: -1}
        for i, num in enumerate(nums):
            prefix_mod = (prefix_mod + num) % k
            # same remainder at day d and i ⇒ days d+1…i total ≡0 (mod k)
            if prefix_mod in mod_seen:
                if i - mod_seen[prefix_mod] > 1:
                    return True
            else:
                mod_seen[prefix_mod] = i
        return False
```

> **Tip:** For k=0, this simply checks for any zero-sum run of length ≥2.

---

## 5 Counting All Spans Divisible by k

**LeetCode 974: Subarray Sums Divisible by K**
*How many intervals end on a day where your **cumulative distance** is an exact multiple of k?*

```python
def subarraysDivByK(self, nums: list[int], k: int) -> int:
    curr_mod = count = 0
    mod_freq = defaultdict(int, {0: 1})
    for num in nums:
        curr_mod = (curr_mod + num) % k
        count += mod_freq[curr_mod]
        mod_freq[curr_mod] += 1
    return count
```

---

## 6 Minimal Skip to Align on k

**LeetCode 1590: Make Sum Divisible by P**
*If your **total trip distance** isn’t divisible by p, what’s the **shortest consecutive segment** to skip so that 
the remaining distance is exactly a multiple of p?*

```python
class Solution:
    def minSubarray(self, nums: list[int], p: int) -> int:
        total_mod = sum(nums) % p
        if total_mod == 0:
            return 0
        min_len = len(nums)
        cur = 0
        mod_seen = {0: -1}
        for i, num in enumerate(nums):
            cur = (cur + num) % p
            need = (cur - total_mod + p) % p
            if need in mod_seen:
                min_len = min(min_len, i - mod_seen[need])
            mod_seen[cur] = i
        return min_len if min_len < len(nums) else -1
```

---
## 7 Batch Calibration Corrections (Difference Array)

**LeetCode 370: Range Addition**

**Problem Description:**
Given a list of corrections `updates`, where each `[s, e, d]` means the sensor misreported by `d` km on days `s…e` (inclusive),
compute the **corrected nums** array.

**Road-Trip Scenario:**
* Your original logs `nums` = `[120, -30, 200, -50, 150]` had drift:
* `updates` = `[[0, 3, 50], [2, 4, -30]]`
* the corrected `nums` array is `[170, 20, 220, -30, 120]`



```python
class Solution:
    def getModifiedArray(self, updates):
        delta = [0] * (n + 1) # n=len(nums)
        for s, e, d in updates:
            delta[s]     += d
            delta[e + 1] -= d
        prefix = 0
        return [(prefix := prefix + delta[i]) for i in range(n)]
```

* **Time Complexity:** $O(n + u)$,  where $u$ = `len(updates)`
* **Space Complexity:** $O(n)$


---
## 8 Counting Valid Starting Odometer Readings

**LeetCode 2145**

**Problem Description:**
You have an array `nums` of daily **change** in odometer readings (`hidden[i+1] – hidden[i]`). You’ve lost the initial reading `H = hidden[0]`. Knowing that every actual reading must stay within `[lower, upper]`, count how many integer values of `H` make **all** readings valid.

**Road-Trip Scenario (adapted):**
Use our daily net array as the **differences**:

> [!example]
> `nums = [120, -30, 200, -50, 150]`   each = hidden[i+1] – hidden[i]
> `lower, upper = 0, 500`                odometer bounds
> 
> **Cumulative offsets from `H`:**
>   prefix = [120,  90, 290, 240, 390]
>   min_offset = 90,   max_offset = 390
> 
> **To keep every reading in \[0,500]:**
>  H + min_offset ≥  lower  ⇒  H ≥ −90  
>  H + max_offset ≤  upper  ⇒  H ≤ 110  
> * Valid H ∈ \[−90…110], count = 110 − (−90) + 1 = **201**.


```python
class Solution:
    def numberOfArrays(self, differences: list[int], lower: int, upper: int) -> int:
        prefix = min_s = max_s = 0
        for d in differences:
            prefix += d
            min_s = min(min_s, prefix)
            max_s = max(max_s, prefix)
        return max(0, (upper - max_s) - (lower - min_s) + 1)
```

* **Time Complexity:** O(n) 
* **Space Complexity:** O(1)
