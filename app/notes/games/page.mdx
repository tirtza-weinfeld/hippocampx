# Games

## Resizable Table of Contents


## Problems

### 1. Sudoku

#### 1.1 Valid Sudoku

[36. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)

*Given a partially filled 9×9 board with digits `$1$–$9$` and `$.$` for empty cells, determine if it is valid* 
*[19:]no duplicates in any row, column, or 3×3 sub-box. You do not need to solve it.*

```python file=backend/algorithms/games/valid_sudoku.py#method:Sudoku.isValidSudoku
```

> [!insight:collapse] *cube_index and think locally*
>
> - `cube_index := (r // 3) * 3 + (c // 3)` treats the 9×9 board as a 3×3 grid of 3×3 boxes:
>   - `r//3` gives which box-row (0,1,2) you’re in
>   - `c//3` gives which box-column (0,1,2)
> 	- Multiplying the box-row by 3 and adding the box-column yields a unique index 0–8 for each 3×3 cube
>
> - *Think locally* If a repeated digit is found in a row, column, or cube, instantly stop.


> [!timecomplexity:collapse] `$O(81)$` (*[19:]i.e.,* `$O(n^2)$`)
>
> Fixed 9×9 boards scan at most 81 cells. Generalized $n×n$ Sudoku validation runs in `$O(n^2)$` time.








#### 1.2 Sudoku Solver

[37. Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)

*Given a partially filled 9×9 board with digits `$1$–$9$` and `$.$` for empty cells, solve it.*
*[19:]It is guaranteed that the input board has only one solution*

```python file=backend/algorithms/games/sudoku_solver.py#method:SudokuSolver.solveSudoku
```

> [!insight:collapse] *MRV (Minimum Remaining Values)*
>
> * Candidates per cell: `{'1'..'9'} − (row $∪$ col $∪$ box)`.
> * **MRV:** pick the empty cell with the fewest candidates to prune hardest.
> * Place a digit *tentatively*, update sets, recurse; undo on failure (**backtrack**).
> * If any cell has **0 candidates**, the branch is impossible → backtrack immediately.



> [!complexity:collapse] *Sudoku Solver (MRV) — Complexity*
>
> Let **k** be the number of empty cells (≤ 81).
> * **Time:**
>   * worst case **$O(9^k)$**
>   * practically $\Theta\!\big(\prod_{t=1}^{k} m_t\big)$ where $m_t$ = MRV-picked cell’s candidate count at step $t$ (usually ≪ 9)
>   * MRV selection adds $O(k)$ per level (≤ $O(k^2)$ per path), dominated by the search
> * **Space:**
>   * board/bookkeeping is constant on fixed 9×9 ⇒ **$O(1)$**
>   * recursion depth **$O(k)$**

### 2. Stone Game

#### 2.1 Stone Game IV

*Alice and Bob start with `n` stones. On each turn, remove a non-zero perfect square. The player with no move loses. Decide if Alice (first) wins under optimal play.*

[1510. Stone Game IV](https://leetcode.com/problems/stone-game-iv/)

```python file=./backend/algorithms/dp.py#method:DP.winnerSquareGame
```

> [\!Intuition:collapse] *Minimax*
>
> **Paradigm**: This is a classic *impartial game* solved using the *Minimax* principle on game states.
>
> **Insight**: A position is defined as *winning* if you can make *any* move to a position that you know is *losing* for your opponent. The DP builds this win/loss classification for every number of stones up to `n`, starting from the base case that 0 stones is a losing position.


> [!timecomplexity:collapse] ***$O(n√n)$** (try all squares for each `x`)*

#### 2.2 Stone Game III

*Array `stoneValue`; players alternately take `1–3` stones from the left maximizing score difference. Return `"Alice"`, `"Bob"`, or `"Tie"` under optimal play.*

[1406. Stone Game III](https://leetcode.com/problems/stone-game-iii/)

```python file=./backend/algorithms/games/stone_3.py#method:StoneGameIII.stoneGameIII
```

> [!insight:collapse] *Score-difference DP*
>
> Let `dp[i]` = max score difference current player can achieve starting at index `i`.
> Transition: `dp[i] = max_{k∈{1,2,3}} (sum(i..i+k-1) − dp[i+k])`. Answer from `dp[0]`.

> [!timecomplexity:collapse] **$O(n)$** (constant 3 choices per `i`)

