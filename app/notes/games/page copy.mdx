

// ### 3. Jump Game

// #### 3.1 Jump Game IV


// *[1345. Jump Game IV](https://leetcode.com/problems/jump-game-iv/)*  
// *From index `i` you may move to `i-1`, `i+1`, or any `j` with `arr[j] == arr[i]`. Return the minimum jumps from `0` to `n-1`.*

// ```python file=problems/./backend/algorithms/games/JumpGameIV.py:JumpGameIV.minJumps
// ```

// > [!insight:collapse] *BFS on an implicit graph + one-time value expansion*
// >
// > * Treat each index as a node; edges: `{i-1, i+1} ∪ {j : arr[j]=arr[i]}`. Use *BFS* for shortest jumps.
// > * Build `value → [indices]`. When you pop `i`, push all unvisited neighbors and then *clear* `value[arr[i]]` so each same-value group is expanded *once* (prevents quadratic blowup).
// > * Track `visited` indices. Optional micro-opts: early return when you first see `n-1`; if `n ≤ 2`, return `n-1`.

// > [!timecomplexity:collapse] **$O(n)$**
// >
// > each index enqueued once; each value group expanded once; `{i±1}` adds `O(n)` total.




